<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worm - Taylor's Bug Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            user-select: none;
        }
        h1 {
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 1.5em;
        }
        #loading {
            font-size: 1.2em;
            color: #ffd700;
            margin-bottom: 10px;
        }
        #game-wrapper {
            display: flex;
            gap: 10px;
        }
        #game-container {
            position: relative;
        }
        #game-canvas {
            display: block;
            background: #2d4a3e;
            border: 3px solid #e94560;
            border-radius: 4px;
            cursor: crosshair;
        }
        #ui-panel {
            width: 200px;
            background: #16213e;
            border: 2px solid #e94560;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
        }
        .panel-section {
            margin-bottom: 15px;
        }
        .panel-title {
            color: #e94560;
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #e94560;
            padding-bottom: 3px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        .command-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }
        .cmd-btn {
            background: #0f3460;
            border: 1px solid #e94560;
            color: #fff;
            padding: 8px 4px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
            transition: all 0.1s;
        }
        .cmd-btn:hover {
            background: #e94560;
        }
        .cmd-btn:active {
            transform: scale(0.95);
        }
        .cmd-btn .key {
            display: block;
            font-weight: bold;
            font-size: 14px;
            color: #ffd700;
        }
        .control-groups {
            display: flex;
            gap: 4px;
        }
        .group-btn {
            flex: 1;
            background: #0f3460;
            border: 1px solid #444;
            color: #888;
            padding: 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
        }
        .group-btn.active {
            border-color: #e94560;
            color: #fff;
        }
        .group-btn.has-bugs {
            background: #1a4a1a;
            color: #4a4;
        }
        #help-text {
            color: #888;
            font-size: 10px;
            line-height: 1.4;
        }
        #help-text kbd {
            background: #333;
            padding: 1px 4px;
            border-radius: 2px;
            color: #ffd700;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <h1>Taylor's Bug Control</h1>
    <div id="loading">Loading Pyodide...</div>

    <div id="game-wrapper" class="hidden">
        <div id="game-container">
            <canvas id="game-canvas" width="900" height="600"></canvas>
        </div>
        <div id="ui-panel">
            <div class="panel-section">
                <div class="panel-title">LOCATION</div>
                <div id="location-info">Central District</div>
            </div>

            <div class="panel-section">
                <div class="panel-title">SELECTION</div>
                <div id="selection-info">No bugs selected</div>
            </div>

            <div class="panel-section">
                <div class="panel-title">COMMANDS</div>
                <div class="command-grid">
                    <div class="cmd-btn" data-cmd="attack"><span class="key">A</span>Attack</div>
                    <div class="cmd-btn" data-cmd="stop"><span class="key">S</span>Stop</div>
                    <div class="cmd-btn" data-cmd="guard"><span class="key">G</span>Guard</div>
                    <div class="cmd-btn" data-cmd="hide"><span class="key">H</span>Hide</div>
                    <div class="cmd-btn" data-cmd="swarm"><span class="key">J</span>Swarm</div>
                    <div class="cmd-btn" data-cmd="form"><span class="key">F</span>Form</div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">CONTROL GROUPS</div>
                <div class="control-groups">
                    <div class="group-btn" data-group="1">1</div>
                    <div class="group-btn" data-group="2">2</div>
                    <div class="group-btn" data-group="3">3</div>
                    <div class="group-btn" data-group="4">4</div>
                    <div class="group-btn" data-group="5">5</div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">TAYLOR</div>
                <div id="taylor-stats">
                    <div class="stat-row"><span>Health:</span><span id="taylor-hp">100/100</span></div>
                    <div class="stat-row"><span>Bugs:</span><span id="bug-count">0</span></div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">CONTROLS</div>
                <div id="help-text">
                    <kbd>WASD</kbd> Move Taylor<br>
                    <kbd>Click+Drag</kbd> Select bugs<br>
                    <kbd>Shift+Click</kbd> Add to selection<br>
                    <kbd>Ctrl+1-5</kbd> Assign group<br>
                    <kbd>1-5</kbd> Select group<br>
                    <kbd>Right-Click</kbd> Move/Attack<br>
                    <kbd>Tab</kbd> Swarm sense
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script>
        const loading = document.getElementById('loading');
        const gameWrapper = document.getElementById('game-wrapper');

        // Input state shared with Python
        window.inputState = {
            keys: {},
            mouse: { x: 0, y: 0, buttons: 0 },
            mouseDown: null,
            mouseUp: null,
            rightClick: null,
            cmdClick: null,
            wheelDelta: 0
        };

        window.uiState = {
            selectionInfo: '',
            taylorHp: '100/100',
            bugCount: '0',
            controlGroups: [0, 0, 0, 0, 0],
            activeGroup: -1,
            locationInfo: 'Central District'
        };

        async function main() {
            try {
                loading.textContent = 'Loading Python runtime...';
                const pyodide = await loadPyodide();

                loading.textContent = 'Starting game...';

                // Set up input handlers
                const canvas = document.getElementById('game-canvas');

                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    window.inputState.mouse.x = e.clientX - rect.left;
                    window.inputState.mouse.y = e.clientY - rect.top;
                });

                canvas.addEventListener('mousedown', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (e.button === 0) {
                        window.inputState.mouse.buttons |= 1;
                        window.inputState.mouseDown = { x, y, shift: e.shiftKey };
                    } else if (e.button === 2) {
                        window.inputState.rightClick = { x, y };
                    }
                    e.preventDefault();
                });

                canvas.addEventListener('mouseup', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (e.button === 0) {
                        window.inputState.mouse.buttons &= ~1;
                        window.inputState.mouseUp = { x, y, shift: e.shiftKey };
                    }
                });

                canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                document.addEventListener('keydown', (e) => {
                    window.inputState.keys[e.code] = true;

                    // Handle control groups
                    if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                        const num = parseInt(e.code.replace('Digit', ''));
                        if (e.ctrlKey || e.metaKey) {
                            window.inputState.cmdClick = { type: 'assign', group: num };
                            e.preventDefault();
                        } else {
                            window.inputState.cmdClick = { type: 'select', group: num, time: Date.now() };
                        }
                    }

                    // Prevent scrolling with space/arrows
                    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab'].includes(e.code)) {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    window.inputState.keys[e.code] = false;
                });

                // Command buttons
                document.querySelectorAll('.cmd-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const cmd = btn.dataset.cmd;
                        window.inputState.cmdClick = { type: 'command', command: cmd };
                    });
                });

                // Group buttons
                document.querySelectorAll('.group-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const group = parseInt(btn.dataset.group);
                        window.inputState.cmdClick = { type: 'select', group: group, time: Date.now() };
                    });
                });

                // Load the game
                await pyodide.runPythonAsync(`
${GAME_CODE}
                `);

                loading.classList.add('hidden');
                gameWrapper.classList.remove('hidden');

                // Update UI periodically
                setInterval(() => {
                    document.getElementById('selection-info').textContent = window.uiState.selectionInfo;
                    document.getElementById('taylor-hp').textContent = window.uiState.taylorHp;
                    document.getElementById('bug-count').textContent = window.uiState.bugCount;
                    document.getElementById('location-info').textContent = window.uiState.locationInfo;

                    document.querySelectorAll('.group-btn').forEach((btn, i) => {
                        const count = window.uiState.controlGroups[i];
                        btn.classList.toggle('has-bugs', count > 0);
                        btn.classList.toggle('active', window.uiState.activeGroup === i + 1);
                        btn.textContent = count > 0 ? `${i+1}(${count})` : `${i+1}`;
                    });
                }, 100);

            } catch (error) {
                loading.textContent = 'Error: ' + error.message;
                loading.style.color = '#ff4444';
                console.error(error);
            }
        }

        const GAME_CODE = `
import math
import random
from js import document, window, requestAnimationFrame
from pyodide.ffi import create_proxy

# ============== CONSTANTS ==============
CANVAS_WIDTH = 900
CANVAS_HEIGHT = 600
MAP_WIDTH = 2400
MAP_HEIGHT = 1800

TAYLOR_SPEED = 3
TAYLOR_CONTROL_RANGE = 200

BUG_TYPES = {
    'fly': {
        'color': '#ffeb3b',
        'speed': 4,
        'hp': 5,
        'damage': 1,
        'size': 4,
        'vision': 100
    },
    'spider': {
        'color': '#8b4513',
        'speed': 1.5,
        'hp': 15,
        'damage': 3,
        'size': 6,
        'vision': 40,
        'can_web': True
    },
    'wasp': {
        'color': '#ff9800',
        'speed': 3,
        'hp': 8,
        'damage': 8,
        'size': 5,
        'vision': 60,
        'sting_damage': 20,
        'can_sting': True
    },
    'beetle': {
        'color': '#2d5a27',
        'speed': 1,
        'hp': 25,
        'damage': 5,
        'size': 7,
        'vision': 30
    },
    'mosquito': {
        'color': '#666666',
        'speed': 5,
        'hp': 3,
        'damage': 2,
        'size': 3,
        'vision': 80
    }
}

# ============== MAP AREAS (Pokemon-style) ==============
AREAS = [
    {
        'name': 'Downtown Brockton',
        'x': 0, 'y': 0, 'width': 800, 'height': 600,
        'color': '#3d3d3d',
        'ground': '#4a4a4a',
        'bugs': ['fly', 'fly', 'mosquito'],
        'description': 'Urban streets with flies and mosquitoes'
    },
    {
        'name': 'The Docks',
        'x': 800, 'y': 0, 'width': 800, 'height': 600,
        'color': '#2a4858',
        'ground': '#1e3a47',
        'bugs': ['spider', 'beetle', 'fly'],
        'description': 'Abandoned warehouses, good for spiders'
    },
    {
        'name': 'Trainyard',
        'x': 1600, 'y': 0, 'width': 800, 'height': 600,
        'color': '#5c4033',
        'ground': '#4a3528',
        'bugs': ['beetle', 'spider', 'fly'],
        'description': 'Rusted trains and beetles'
    },
    {
        'name': 'Lord Street',
        'x': 0, 'y': 600, 'width': 800, 'height': 600,
        'color': '#2d4a3e',
        'ground': '#243d33',
        'bugs': ['wasp', 'fly', 'fly'],
        'description': 'Residential area with wasps'
    },
    {
        'name': 'Central Park',
        'x': 800, 'y': 600, 'width': 800, 'height': 600,
        'color': '#1a5c1a',
        'ground': '#144a14',
        'bugs': ['wasp', 'beetle', 'spider', 'fly'],
        'description': 'Green space, diverse bugs'
    },
    {
        'name': 'The Boardwalk',
        'x': 1600, 'y': 600, 'width': 800, 'height': 600,
        'color': '#c2a060',
        'ground': '#a88a50',
        'bugs': ['fly', 'mosquito', 'wasp'],
        'description': 'Tourist area near the beach'
    },
    {
        'name': 'Boat Graveyard',
        'x': 0, 'y': 1200, 'width': 800, 'height': 600,
        'color': '#1a3d4d',
        'ground': '#143240',
        'bugs': ['spider', 'spider', 'beetle'],
        'description': 'Shipwrecks full of spiders'
    },
    {
        'name': 'The Marsh',
        'x': 800, 'y': 1200, 'width': 800, 'height': 600,
        'color': '#3d4a30',
        'ground': '#2d3a22',
        'bugs': ['mosquito', 'mosquito', 'beetle', 'spider'],
        'description': 'Wetlands with mosquitoes'
    },
    {
        'name': 'ABB Territory',
        'x': 1600, 'y': 1200, 'width': 800, 'height': 600,
        'color': '#4a2020',
        'ground': '#3a1515',
        'bugs': ['wasp', 'wasp', 'fly'],
        'description': 'Dangerous gang territory'
    }
]

# ============== UTILITY ==============
def distance(x1, y1, x2, y2):
    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

def normalize(x, y):
    d = math.sqrt(x*x + y*y)
    if d == 0:
        return 0, 0
    return x/d, y/d

def clamp(val, min_val, max_val):
    return max(min_val, min(max_val, val))

def get_area_at(x, y):
    for area in AREAS:
        if (area['x'] <= x < area['x'] + area['width'] and
            area['y'] <= y < area['y'] + area['height']):
            return area
    return None

# ============== ENTITIES ==============
class Entity:
    next_id = 0

    def __init__(self, x, y):
        self.id = Entity.next_id
        Entity.next_id += 1
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.alive = True

class Taylor(Entity):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.hp = 100
        self.max_hp = 100
        self.control_range = TAYLOR_CONTROL_RANGE
        self.speed = TAYLOR_SPEED
        self.facing = 'down'
        self.walk_frame = 0
        self.walk_timer = 0

    def update(self, keys):
        dx, dy = 0, 0
        if keys.get('KeyW') or keys.get('ArrowUp'):
            dy -= 1
            self.facing = 'up'
        if keys.get('KeyS') or keys.get('ArrowDown'):
            dy += 1
            self.facing = 'down'
        if keys.get('KeyA') or keys.get('ArrowLeft'):
            dx -= 1
            self.facing = 'left'
        if keys.get('KeyD') or keys.get('ArrowRight'):
            dx += 1
            self.facing = 'right'

        if dx != 0 or dy != 0:
            dx, dy = normalize(dx, dy)
            self.x += dx * self.speed
            self.y += dy * self.speed
            self.walk_timer += 1
            if self.walk_timer >= 8:
                self.walk_timer = 0
                self.walk_frame = (self.walk_frame + 1) % 4
        else:
            self.walk_frame = 0
            self.walk_timer = 0

        # Clamp to map
        self.x = clamp(self.x, 20, MAP_WIDTH - 20)
        self.y = clamp(self.y, 20, MAP_HEIGHT - 20)

    def draw(self, ctx, screen_x, screen_y):
        # Taylor sprite - black costume with yellow lenses
        # 32x32 pixel art style

        # Body (black bodysuit)
        ctx.fillStyle = '#1a1a1a'

        # Draw based on facing direction
        if self.facing == 'down':
            # Torso
            ctx.fillRect(screen_x - 8, screen_y - 10, 16, 20)
            # Head
            ctx.fillStyle = '#2a2a2a'
            ctx.fillRect(screen_x - 7, screen_y - 16, 14, 8)
            # Mask/face with yellow lenses
            ctx.fillStyle = '#1a1a1a'
            ctx.fillRect(screen_x - 6, screen_y - 14, 12, 5)
            # Yellow lenses (eyes)
            ctx.fillStyle = '#ffd700'
            ctx.fillRect(screen_x - 4, screen_y - 13, 3, 3)
            ctx.fillRect(screen_x + 1, screen_y - 13, 3, 3)
            # Legs
            ctx.fillStyle = '#1a1a1a'
            leg_offset = [0, 2, 0, -2][self.walk_frame]
            ctx.fillRect(screen_x - 6, screen_y + 10, 5, 8 + leg_offset)
            ctx.fillRect(screen_x + 1, screen_y + 10, 5, 8 - leg_offset)
            # Hair (curly, dark)
            ctx.fillStyle = '#0a0a0a'
            ctx.fillRect(screen_x - 8, screen_y - 18, 16, 4)
            ctx.fillRect(screen_x - 9, screen_y - 16, 2, 6)
            ctx.fillRect(screen_x + 7, screen_y - 16, 2, 6)

        elif self.facing == 'up':
            # Torso
            ctx.fillRect(screen_x - 8, screen_y - 10, 16, 20)
            # Head (back of mask)
            ctx.fillStyle = '#2a2a2a'
            ctx.fillRect(screen_x - 7, screen_y - 16, 14, 8)
            # Hair from behind
            ctx.fillStyle = '#0a0a0a'
            ctx.fillRect(screen_x - 8, screen_y - 18, 16, 6)
            ctx.fillRect(screen_x - 9, screen_y - 14, 2, 8)
            ctx.fillRect(screen_x + 7, screen_y - 14, 2, 8)
            # Legs
            ctx.fillStyle = '#1a1a1a'
            leg_offset = [0, 2, 0, -2][self.walk_frame]
            ctx.fillRect(screen_x - 6, screen_y + 10, 5, 8 - leg_offset)
            ctx.fillRect(screen_x + 1, screen_y + 10, 5, 8 + leg_offset)

        elif self.facing == 'left':
            # Body (side view)
            ctx.fillRect(screen_x - 5, screen_y - 10, 10, 20)
            # Head
            ctx.fillStyle = '#2a2a2a'
            ctx.fillRect(screen_x - 6, screen_y - 16, 10, 8)
            # Mask with lens
            ctx.fillStyle = '#1a1a1a'
            ctx.fillRect(screen_x - 8, screen_y - 14, 8, 5)
            ctx.fillStyle = '#ffd700'
            ctx.fillRect(screen_x - 7, screen_y - 13, 3, 3)
            # Hair
            ctx.fillStyle = '#0a0a0a'
            ctx.fillRect(screen_x - 6, screen_y - 18, 12, 4)
            ctx.fillRect(screen_x + 4, screen_y - 14, 3, 8)
            # Legs
            ctx.fillStyle = '#1a1a1a'
            leg_offset = [0, 3, 0, -3][self.walk_frame]
            ctx.fillRect(screen_x - 4 + leg_offset, screen_y + 10, 4, 8)
            ctx.fillRect(screen_x - leg_offset, screen_y + 10, 4, 8)

        elif self.facing == 'right':
            # Body (side view)
            ctx.fillRect(screen_x - 5, screen_y - 10, 10, 20)
            # Head
            ctx.fillStyle = '#2a2a2a'
            ctx.fillRect(screen_x - 4, screen_y - 16, 10, 8)
            # Mask with lens
            ctx.fillStyle = '#1a1a1a'
            ctx.fillRect(screen_x, screen_y - 14, 8, 5)
            ctx.fillStyle = '#ffd700'
            ctx.fillRect(screen_x + 4, screen_y - 13, 3, 3)
            # Hair
            ctx.fillStyle = '#0a0a0a'
            ctx.fillRect(screen_x - 6, screen_y - 18, 12, 4)
            ctx.fillRect(screen_x - 7, screen_y - 14, 3, 8)
            # Legs
            ctx.fillStyle = '#1a1a1a'
            leg_offset = [0, 3, 0, -3][self.walk_frame]
            ctx.fillRect(screen_x - 4 - leg_offset, screen_y + 10, 4, 8)
            ctx.fillRect(screen_x + leg_offset, screen_y + 10, 4, 8)

class Bug(Entity):
    def __init__(self, x, y, bug_type):
        super().__init__(x, y)
        self.bug_type = bug_type
        stats = BUG_TYPES[bug_type]
        self.color = stats['color']
        self.speed = stats['speed']
        self.hp = stats['hp']
        self.max_hp = stats['hp']
        self.damage = stats['damage']
        self.size = stats['size']
        self.vision = stats['vision']
        self.can_web = stats.get('can_web', False)
        self.can_sting = stats.get('can_sting', False)
        self.sting_damage = stats.get('sting_damage', 0)
        self.has_stung = False

        self.selected = False
        self.controlled = True
        self.target = None
        self.target_entity = None
        self.command = 'idle'
        self.guard_angle = random.uniform(0, math.pi * 2)
        self.orbit_speed = random.uniform(0.02, 0.04)

        # Wandering behavior
        self.wander_angle = random.uniform(0, math.pi * 2)
        self.wander_timer = 0

        # Animation
        self.anim_offset = random.uniform(0, math.pi * 2)

    def update(self, taylor, enemies):
        if not self.alive:
            return

        # Check if in Taylor's control range
        dist_to_taylor = distance(self.x, self.y, taylor.x, taylor.y)
        self.controlled = dist_to_taylor <= taylor.control_range

        if not self.controlled:
            # Uncontrolled: wander randomly
            self.wander_timer -= 1
            if self.wander_timer <= 0:
                self.wander_angle += random.uniform(-0.5, 0.5)
                self.wander_timer = random.randint(30, 90)

            self.x += math.cos(self.wander_angle) * self.speed * 0.3
            self.y += math.sin(self.wander_angle) * self.speed * 0.3
            self.command = 'idle'
            self.selected = False
            # Keep in map
            self.x = clamp(self.x, 5, MAP_WIDTH - 5)
            self.y = clamp(self.y, 5, MAP_HEIGHT - 5)
            return

        # Execute command
        if self.command == 'idle':
            pass

        elif self.command == 'move' and self.target:
            tx, ty = self.target
            dx, dy = tx - self.x, ty - self.y
            dist = math.sqrt(dx*dx + dy*dy)
            if dist > 5:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed
            else:
                self.command = 'idle'
                self.target = None

        elif self.command == 'attack' and self.target:
            tx, ty = self.target
            dx, dy = tx - self.x, ty - self.y
            dist = math.sqrt(dx*dx + dy*dy)

            # Check for enemies along the way
            nearest_enemy = None
            nearest_dist = float('inf')
            for enemy in enemies:
                if enemy.alive:
                    ed = distance(self.x, self.y, enemy.x, enemy.y)
                    if ed < self.vision and ed < nearest_dist:
                        nearest_enemy = enemy
                        nearest_dist = ed

            if nearest_enemy and nearest_dist < 20:
                self.attack_enemy(nearest_enemy)
            elif nearest_enemy:
                dx, dy = normalize(nearest_enemy.x - self.x, nearest_enemy.y - self.y)
                self.x += dx * self.speed
                self.y += dy * self.speed
            elif dist > 5:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed
            else:
                self.command = 'idle'
                self.target = None

        elif self.command == 'guard':
            self.guard_angle += self.orbit_speed
            target_x = taylor.x + math.cos(self.guard_angle) * 50
            target_y = taylor.y + math.sin(self.guard_angle) * 50

            dx, dy = target_x - self.x, target_y - self.y
            dist = math.sqrt(dx*dx + dy*dy)
            if dist > 3:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed

            for enemy in enemies:
                if enemy.alive:
                    ed = distance(self.x, self.y, enemy.x, enemy.y)
                    if ed < 25:
                        self.attack_enemy(enemy)
                        break

        elif self.command == 'hide':
            dx, dy = self.x - taylor.x, self.y - taylor.y
            if dx != 0 or dy != 0:
                dx, dy = normalize(dx, dy)
                target_x = taylor.x + dx * taylor.control_range * 0.8
                target_y = taylor.y + dy * taylor.control_range * 0.8

                mx, my = target_x - self.x, target_y - self.y
                dist = math.sqrt(mx*mx + my*my)
                if dist > 5:
                    mx, my = normalize(mx, my)
                    self.x += mx * self.speed * 0.5
                    self.y += my * self.speed * 0.5

        elif self.command == 'swarm' and self.target_entity:
            enemy = self.target_entity
            if enemy.alive:
                dx, dy = enemy.x - self.x, enemy.y - self.y
                dist = math.sqrt(dx*dx + dy*dy)
                if dist < 15:
                    self.attack_enemy(enemy)
                else:
                    dx, dy = normalize(dx, dy)
                    self.x += dx * self.speed * 1.2
                    self.y += dy * self.speed * 1.2
            else:
                self.command = 'idle'
                self.target_entity = None

        self.x = clamp(self.x, 5, MAP_WIDTH - 5)
        self.y = clamp(self.y, 5, MAP_HEIGHT - 5)

    def attack_enemy(self, enemy):
        if self.can_sting and not self.has_stung:
            enemy.hp -= self.sting_damage
            self.has_stung = True
            self.hp = 0
            self.alive = False
        else:
            enemy.hp -= self.damage
            if enemy.hp <= 0:
                enemy.alive = False

    def draw(self, ctx, screen_x, screen_y, frame):
        # Animated bug drawing
        wobble = math.sin(frame * 0.2 + self.anim_offset) * 1

        if self.bug_type == 'fly':
            # Body
            ctx.fillStyle = self.color if self.controlled else '#666'
            ctx.beginPath()
            ctx.ellipse(screen_x, screen_y, self.size, self.size * 0.7, 0, 0, math.pi * 2)
            ctx.fill()
            # Wings
            ctx.fillStyle = 'rgba(200, 200, 200, 0.5)'
            wing_angle = math.sin(frame * 0.5 + self.anim_offset) * 0.3
            ctx.beginPath()
            ctx.ellipse(screen_x - 3, screen_y - 2 + wobble, 4, 2, wing_angle, 0, math.pi * 2)
            ctx.fill()
            ctx.beginPath()
            ctx.ellipse(screen_x + 3, screen_y - 2 + wobble, 4, 2, -wing_angle, 0, math.pi * 2)
            ctx.fill()

        elif self.bug_type == 'spider':
            # Body
            ctx.fillStyle = self.color if self.controlled else '#666'
            ctx.beginPath()
            ctx.arc(screen_x, screen_y, self.size, 0, math.pi * 2)
            ctx.fill()
            # Legs
            ctx.strokeStyle = self.color if self.controlled else '#666'
            ctx.lineWidth = 1
            for i in range(4):
                angle = i * 0.5 - 0.75 + math.sin(frame * 0.1 + i) * 0.1
                ctx.beginPath()
                ctx.moveTo(screen_x, screen_y)
                ctx.lineTo(screen_x - math.cos(angle) * 10, screen_y + math.sin(angle) * 8)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(screen_x, screen_y)
                ctx.lineTo(screen_x + math.cos(angle) * 10, screen_y + math.sin(angle) * 8)
                ctx.stroke()

        elif self.bug_type == 'wasp':
            # Body segments
            ctx.fillStyle = '#1a1a1a'
            ctx.beginPath()
            ctx.ellipse(screen_x - 2, screen_y, 3, 2, 0, 0, math.pi * 2)
            ctx.fill()
            ctx.fillStyle = self.color if self.controlled else '#666'
            ctx.beginPath()
            ctx.ellipse(screen_x + 2, screen_y, 4, 3, 0, 0, math.pi * 2)
            ctx.fill()
            # Stripes
            ctx.fillStyle = '#1a1a1a'
            ctx.fillRect(screen_x + 1, screen_y - 2, 1, 4)
            ctx.fillRect(screen_x + 4, screen_y - 2, 1, 4)
            # Wings
            ctx.fillStyle = 'rgba(200, 200, 200, 0.4)'
            wing_angle = math.sin(frame * 0.6 + self.anim_offset) * 0.4
            ctx.beginPath()
            ctx.ellipse(screen_x, screen_y - 3 + wobble, 5, 2, wing_angle, 0, math.pi * 2)
            ctx.fill()

        elif self.bug_type == 'beetle':
            # Shell
            ctx.fillStyle = self.color if self.controlled else '#666'
            ctx.beginPath()
            ctx.ellipse(screen_x, screen_y, self.size, self.size * 0.8, 0, 0, math.pi * 2)
            ctx.fill()
            # Shell line
            ctx.strokeStyle = '#1a3a14'
            ctx.lineWidth = 1
            ctx.beginPath()
            ctx.moveTo(screen_x, screen_y - self.size * 0.8)
            ctx.lineTo(screen_x, screen_y + self.size * 0.8)
            ctx.stroke()
            # Head
            ctx.fillStyle = '#1a1a1a'
            ctx.beginPath()
            ctx.arc(screen_x, screen_y - self.size, 3, 0, math.pi * 2)
            ctx.fill()

        elif self.bug_type == 'mosquito':
            # Tiny body
            ctx.fillStyle = self.color if self.controlled else '#666'
            ctx.beginPath()
            ctx.ellipse(screen_x, screen_y, 2, 3, 0, 0, math.pi * 2)
            ctx.fill()
            # Long legs
            ctx.strokeStyle = self.color if self.controlled else '#666'
            ctx.lineWidth = 0.5
            for i in range(3):
                angle = i * 0.4 - 0.4
                ctx.beginPath()
                ctx.moveTo(screen_x, screen_y)
                ctx.lineTo(screen_x - 4, screen_y + 5 + i * 2)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(screen_x, screen_y)
                ctx.lineTo(screen_x + 4, screen_y + 5 + i * 2)
                ctx.stroke()
            # Wings
            ctx.fillStyle = 'rgba(180, 180, 180, 0.3)'
            ctx.beginPath()
            ctx.ellipse(screen_x, screen_y - 2 + wobble, 4, 1.5, 0, 0, math.pi * 2)
            ctx.fill()

class Enemy(Entity):
    def __init__(self, x, y, enemy_type='grunt'):
        super().__init__(x, y)
        self.enemy_type = enemy_type
        if enemy_type == 'grunt':
            self.hp = 50
            self.max_hp = 50
            self.speed = 1.5
            self.damage = 10
            self.size = 16
            self.vision = 150
            self.color = '#e74c3c'
        elif enemy_type == 'thug':
            self.hp = 80
            self.max_hp = 80
            self.speed = 1.2
            self.damage = 15
            self.size = 20
            self.vision = 120
            self.color = '#c0392b'
        elif enemy_type == 'cape':
            self.hp = 150
            self.max_hp = 150
            self.speed = 2
            self.damage = 25
            self.size = 24
            self.vision = 200
            self.color = '#8e44ad'

        self.attack_range = 30
        self.attack_cooldown = 0
        self.patrol_points = []
        self.patrol_index = 0
        self.state = 'patrol'
        self.target = None

    def set_patrol(self, points):
        self.patrol_points = points
        self.patrol_index = 0

    def update(self, taylor, bugs):
        if not self.alive:
            return

        self.attack_cooldown = max(0, self.attack_cooldown - 1)
        dist_to_taylor = distance(self.x, self.y, taylor.x, taylor.y)

        nearest_bug = None
        nearest_bug_dist = float('inf')
        for bug in bugs:
            if bug.alive and bug.controlled:
                d = distance(self.x, self.y, bug.x, bug.y)
                if d < nearest_bug_dist:
                    nearest_bug = bug
                    nearest_bug_dist = d

        if dist_to_taylor < self.vision:
            self.state = 'chase'
            self.target = taylor
        elif nearest_bug and nearest_bug_dist < self.vision:
            self.state = 'chase'
            self.target = nearest_bug
        else:
            self.state = 'patrol'
            self.target = None

        if self.state == 'chase' and self.target:
            dx, dy = self.target.x - self.x, self.target.y - self.y
            dist = math.sqrt(dx*dx + dy*dy)

            if dist < self.attack_range:
                if self.attack_cooldown == 0:
                    self.target.hp -= self.damage
                    self.attack_cooldown = 60
                    if self.target.hp <= 0:
                        self.target.alive = False
            else:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed

        elif self.state == 'patrol' and self.patrol_points:
            px, py = self.patrol_points[self.patrol_index]
            dx, dy = px - self.x, py - self.y
            dist = math.sqrt(dx*dx + dy*dy)

            if dist < 10:
                self.patrol_index = (self.patrol_index + 1) % len(self.patrol_points)
            else:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed * 0.5
                self.y += dy * self.speed * 0.5

        self.x = clamp(self.x, 20, MAP_WIDTH - 20)
        self.y = clamp(self.y, 20, MAP_HEIGHT - 20)

    def draw(self, ctx, screen_x, screen_y):
        # Draw enemy as a person
        ctx.fillStyle = self.color
        # Body
        ctx.fillRect(screen_x - self.size//3, screen_y - self.size//2, self.size*2//3, self.size)
        # Head
        ctx.beginPath()
        ctx.arc(screen_x, screen_y - self.size//2 - 6, 6, 0, math.pi * 2)
        ctx.fill()

class WebTrap(Entity):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.radius = 40
        self.duration = 600
        self.slow_factor = 0.3

    def update(self):
        self.duration -= 1
        if self.duration <= 0:
            self.alive = False

# ============== GAME ==============
class Game:
    def __init__(self):
        self.canvas = document.getElementById('game-canvas')
        self.ctx = self.canvas.getContext('2d')

        # Start Taylor in Central Park
        self.taylor = Taylor(1200, 900)
        self.bugs = []
        self.enemies = []
        self.webs = []
        self.control_groups = {1: [], 2: [], 3: [], 4: [], 5: []}

        self.camera_x = self.taylor.x - CANVAS_WIDTH // 2
        self.camera_y = self.taylor.y - CANVAS_HEIGHT // 2

        self.selection_box = None
        self.current_command = None
        self.swarm_sense = False
        self.last_group_press = {'group': 0, 'time': 0}

        self.spawn_bugs_in_areas()
        self.spawn_enemies()

        self.running = True
        self.frame_count = 0

    def spawn_bugs_in_areas(self):
        # Spawn bugs in each area according to their bug types
        for area in AREAS:
            num_bugs = random.randint(15, 25)
            for _ in range(num_bugs):
                x = random.uniform(area['x'] + 50, area['x'] + area['width'] - 50)
                y = random.uniform(area['y'] + 50, area['y'] + area['height'] - 50)
                bug_type = random.choice(area['bugs'])
                self.bugs.append(Bug(x, y, bug_type))

        # Extra bugs near Taylor's starting position
        for _ in range(20):
            angle = random.uniform(0, math.pi * 2)
            dist = random.uniform(30, 150)
            x = self.taylor.x + math.cos(angle) * dist
            y = self.taylor.y + math.sin(angle) * dist
            bug_type = random.choice(['fly', 'fly', 'spider', 'wasp'])
            self.bugs.append(Bug(x, y, bug_type))

    def spawn_enemies(self):
        # Enemies in different areas
        # Downtown
        e = Enemy(400, 300, 'grunt')
        e.set_patrol([(300, 200), (500, 200), (500, 400), (300, 400)])
        self.enemies.append(e)

        # Docks - tougher enemies
        e = Enemy(1000, 300, 'thug')
        e.set_patrol([(900, 200), (1100, 200), (1100, 400), (900, 400)])
        self.enemies.append(e)

        # Trainyard
        e = Enemy(1900, 300, 'grunt')
        e.set_patrol([(1800, 200), (2000, 200), (2000, 400), (1800, 400)])
        self.enemies.append(e)

        # Lord Street
        e = Enemy(400, 900, 'grunt')
        e.set_patrol([(300, 800), (500, 800), (500, 1000), (300, 1000)])
        self.enemies.append(e)

        # Boardwalk
        e = Enemy(1900, 900, 'thug')
        e.set_patrol([(1800, 800), (2100, 800), (2100, 1000), (1800, 1000)])
        self.enemies.append(e)

        # Boat Graveyard - dangerous
        e = Enemy(400, 1500, 'thug')
        e.set_patrol([(300, 1400), (500, 1400), (500, 1600), (300, 1600)])
        self.enemies.append(e)

        # Marsh
        e = Enemy(1200, 1500, 'grunt')
        e.set_patrol([(1100, 1400), (1300, 1400), (1300, 1600), (1100, 1600)])
        self.enemies.append(e)

        # ABB Territory - cape (boss)
        e = Enemy(2000, 1500, 'cape')
        e.set_patrol([(1900, 1400), (2100, 1400), (2100, 1600), (1900, 1600)])
        self.enemies.append(e)

        # Additional grunt
        e = Enemy(2200, 1400, 'thug')
        self.enemies.append(e)

    def handle_input(self):
        input_state = window.inputState
        keys = dict(input_state.keys.object_entries())

        self.taylor.update(keys)

        if keys.get('Tab'):
            if not hasattr(self, '_tab_held'):
                self._tab_held = False
            if not self._tab_held:
                self.swarm_sense = not self.swarm_sense
                self._tab_held = True
        else:
            self._tab_held = False

        mouse_down = input_state.mouseDown
        mouse_up = input_state.mouseUp

        if mouse_down:
            start_x = mouse_down.x + self.camera_x
            start_y = mouse_down.y + self.camera_y
            self.selection_box = {
                'start_x': start_x,
                'start_y': start_y,
                'end_x': start_x,
                'end_y': start_y,
                'shift': mouse_down.shift
            }
            input_state.mouseDown = None

        if self.selection_box:
            mouse = input_state.mouse
            self.selection_box['end_x'] = mouse.x + self.camera_x
            self.selection_box['end_y'] = mouse.y + self.camera_y

        if mouse_up and self.selection_box:
            self.finish_selection(mouse_up.shift)
            self.selection_box = None
            input_state.mouseUp = None

        right_click = input_state.rightClick
        if right_click:
            target_x = right_click.x + self.camera_x
            target_y = right_click.y + self.camera_y

            clicked_enemy = None
            for enemy in self.enemies:
                if enemy.alive:
                    if distance(target_x, target_y, enemy.x, enemy.y) < enemy.size:
                        clicked_enemy = enemy
                        break

            if clicked_enemy:
                self.command_swarm(clicked_enemy)
            else:
                self.command_move(target_x, target_y)

            input_state.rightClick = None

        cmd_click = input_state.cmdClick
        if cmd_click:
            cmd_type = cmd_click.type if hasattr(cmd_click, 'type') else cmd_click.get('type')

            if cmd_type == 'command':
                cmd = cmd_click.command if hasattr(cmd_click, 'command') else cmd_click.get('command')
                self.execute_command(cmd)
            elif cmd_type == 'assign':
                group = cmd_click.group if hasattr(cmd_click, 'group') else cmd_click.get('group')
                self.assign_control_group(group)
            elif cmd_type == 'select':
                group = cmd_click.group if hasattr(cmd_click, 'group') else cmd_click.get('group')
                click_time = cmd_click.time if hasattr(cmd_click, 'time') else cmd_click.get('time')

                if (self.last_group_press['group'] == group and
                    click_time - self.last_group_press['time'] < 300):
                    self.center_on_group(group)
                else:
                    self.select_control_group(group)

                self.last_group_press = {'group': group, 'time': click_time}

            input_state.cmdClick = None

        if keys.get('KeyA'):
            if not hasattr(self, '_a_held') or not self._a_held:
                self.current_command = 'attack'
                self._a_held = True
        else:
            self._a_held = False

        if keys.get('KeyS'):
            if not hasattr(self, '_s_held') or not self._s_held:
                self.execute_command('stop')
                self._s_held = True
        else:
            self._s_held = False

        if keys.get('KeyG'):
            if not hasattr(self, '_g_held') or not self._g_held:
                self.execute_command('guard')
                self._g_held = True
        else:
            self._g_held = False

        if keys.get('KeyH'):
            if not hasattr(self, '_h_held') or not self._h_held:
                self.execute_command('hide')
                self._h_held = True
        else:
            self._h_held = False

        if keys.get('KeyJ'):
            if not hasattr(self, '_j_held') or not self._j_held:
                self.current_command = 'swarm'
                self._j_held = True
        else:
            self._j_held = False

    def finish_selection(self, shift):
        box = self.selection_box
        x1 = min(box['start_x'], box['end_x'])
        y1 = min(box['start_y'], box['end_y'])
        x2 = max(box['start_x'], box['end_x'])
        y2 = max(box['start_y'], box['end_y'])

        if abs(x2 - x1) < 5 and abs(y2 - y1) < 5:
            if not shift:
                for bug in self.bugs:
                    bug.selected = False

            for bug in self.bugs:
                if bug.alive and bug.controlled:
                    if distance(x1, y1, bug.x, bug.y) < 15:
                        bug.selected = not bug.selected if shift else True
                        break
        else:
            if not shift:
                for bug in self.bugs:
                    bug.selected = False

            for bug in self.bugs:
                if bug.alive and bug.controlled:
                    if x1 <= bug.x <= x2 and y1 <= bug.y <= y2:
                        bug.selected = True

    def command_move(self, x, y):
        selected = [b for b in self.bugs if b.selected and b.alive]
        if not selected:
            return

        count = len(selected)
        cols = int(math.ceil(math.sqrt(count)))
        spacing = 15

        for i, bug in enumerate(selected):
            row = i // cols
            col = i % cols
            offset_x = (col - cols // 2) * spacing
            offset_y = (row - count // cols // 2) * spacing

            if self.current_command == 'attack':
                bug.command = 'attack'
            else:
                bug.command = 'move'
            bug.target = (x + offset_x, y + offset_y)

        self.current_command = None

    def command_swarm(self, enemy):
        selected = [b for b in self.bugs if b.selected and b.alive]
        for bug in selected:
            bug.command = 'swarm'
            bug.target_entity = enemy

    def execute_command(self, cmd):
        selected = [b for b in self.bugs if b.selected and b.alive]

        if cmd == 'stop':
            for bug in selected:
                bug.command = 'idle'
                bug.target = None
                bug.target_entity = None
        elif cmd == 'guard':
            for bug in selected:
                bug.command = 'guard'
                bug.guard_angle = random.uniform(0, math.pi * 2)
        elif cmd == 'hide':
            for bug in selected:
                bug.command = 'hide'
        elif cmd == 'attack':
            self.current_command = 'attack'
        elif cmd == 'swarm':
            self.current_command = 'swarm'

    def assign_control_group(self, group):
        selected = [b for b in self.bugs if b.selected and b.alive]
        self.control_groups[group] = [b.id for b in selected]

    def select_control_group(self, group):
        for bug in self.bugs:
            bug.selected = False

        group_ids = self.control_groups[group]
        for bug in self.bugs:
            if bug.id in group_ids and bug.alive and bug.controlled:
                bug.selected = True

        window.uiState.activeGroup = group

    def center_on_group(self, group):
        group_ids = self.control_groups[group]
        bugs_in_group = [b for b in self.bugs if b.id in group_ids and b.alive]

        if bugs_in_group:
            avg_x = sum(b.x for b in bugs_in_group) / len(bugs_in_group)
            avg_y = sum(b.y for b in bugs_in_group) / len(bugs_in_group)
            self.camera_x = avg_x - CANVAS_WIDTH // 2
            self.camera_y = avg_y - CANVAS_HEIGHT // 2

    def update(self):
        self.frame_count += 1

        for bug in self.bugs:
            bug.update(self.taylor, self.enemies)

        for enemy in self.enemies:
            enemy.update(self.taylor, self.bugs)

        for web in self.webs:
            web.update()
        self.webs = [w for w in self.webs if w.alive]

        self.bugs = [b for b in self.bugs if b.alive]

        target_cam_x = self.taylor.x - CANVAS_WIDTH // 2
        target_cam_y = self.taylor.y - CANVAS_HEIGHT // 2
        self.camera_x += (target_cam_x - self.camera_x) * 0.1
        self.camera_y += (target_cam_y - self.camera_y) * 0.1

        self.camera_x = clamp(self.camera_x, 0, MAP_WIDTH - CANVAS_WIDTH)
        self.camera_y = clamp(self.camera_y, 0, MAP_HEIGHT - CANVAS_HEIGHT)

        # Update location
        area = get_area_at(self.taylor.x, self.taylor.y)
        if area:
            window.uiState.locationInfo = area['name']
        else:
            window.uiState.locationInfo = 'Unknown'

        selected = [b for b in self.bugs if b.selected]
        if selected:
            types = {}
            for b in selected:
                types[b.bug_type] = types.get(b.bug_type, 0) + 1
            info = f"{len(selected)} selected\\n"
            for t, c in types.items():
                info += f"  {t}: {c}\\n"
            window.uiState.selectionInfo = info
        else:
            window.uiState.selectionInfo = "No bugs selected"

        window.uiState.taylorHp = f"{int(self.taylor.hp)}/{self.taylor.max_hp}"
        controlled = len([b for b in self.bugs if b.controlled])
        window.uiState.bugCount = f"{controlled}/{len(self.bugs)}"

        for i in range(5):
            group_ids = self.control_groups[i + 1]
            count = len([b for b in self.bugs if b.id in group_ids and b.alive and b.controlled])
            window.uiState.controlGroups[i] = count

    def render(self):
        ctx = self.ctx
        cam_x, cam_y = self.camera_x, self.camera_y

        # Draw areas
        for area in AREAS:
            ax = area['x'] - cam_x
            ay = area['y'] - cam_y

            # Skip if off screen
            if ax + area['width'] < 0 or ax > CANVAS_WIDTH or ay + area['height'] < 0 or ay > CANVAS_HEIGHT:
                continue

            # Ground
            ctx.fillStyle = area['ground']
            ctx.fillRect(ax, ay, area['width'], area['height'])

            # Area border
            ctx.strokeStyle = area['color']
            ctx.lineWidth = 3
            ctx.strokeRect(ax, ay, area['width'], area['height'])

            # Area name (if visible)
            if 0 < ax < CANVAS_WIDTH - 100 and 0 < ay < CANVAS_HEIGHT - 20:
                ctx.fillStyle = 'rgba(0,0,0,0.6)'
                ctx.fillRect(ax + 5, ay + 5, 150, 20)
                ctx.fillStyle = '#fff'
                ctx.font = '12px monospace'
                ctx.fillText(area['name'], ax + 10, ay + 18)

        # Draw grid
        ctx.strokeStyle = 'rgba(255,255,255,0.05)'
        ctx.lineWidth = 1
        grid_size = 50
        start_x = -(cam_x % grid_size)
        start_y = -(cam_y % grid_size)

        for x in range(int(start_x), CANVAS_WIDTH + grid_size, grid_size):
            ctx.beginPath()
            ctx.moveTo(x, 0)
            ctx.lineTo(x, CANVAS_HEIGHT)
            ctx.stroke()

        for y in range(int(start_y), CANVAS_HEIGHT + grid_size, grid_size):
            ctx.beginPath()
            ctx.moveTo(0, y)
            ctx.lineTo(CANVAS_WIDTH, y)
            ctx.stroke()

        # Draw webs
        for web in self.webs:
            sx, sy = web.x - cam_x, web.y - cam_y
            ctx.fillStyle = 'rgba(255,255,255,0.2)'
            ctx.beginPath()
            ctx.arc(sx, sy, web.radius, 0, math.pi * 2)
            ctx.fill()

        # Draw control range
        tx, ty = self.taylor.x - cam_x, self.taylor.y - cam_y
        ctx.strokeStyle = 'rgba(155, 89, 182, 0.4)'
        ctx.lineWidth = 2
        ctx.setLineDash([5, 5])
        ctx.beginPath()
        ctx.arc(tx, ty, self.taylor.control_range, 0, math.pi * 2)
        ctx.stroke()
        ctx.setLineDash([])

        # Draw bugs
        for bug in self.bugs:
            bx, by = bug.x - cam_x, bug.y - cam_y

            if bx < -20 or bx > CANVAS_WIDTH + 20 or by < -20 or by > CANVAS_HEIGHT + 20:
                continue

            if bug.selected:
                ctx.strokeStyle = '#00ff00'
                ctx.lineWidth = 2
                ctx.beginPath()
                ctx.arc(bx, by, bug.size + 4, 0, math.pi * 2)
                ctx.stroke()

            bug.draw(ctx, bx, by, self.frame_count)

            if bug.command == 'guard':
                ctx.fillStyle = '#00ffff'
                ctx.beginPath()
                ctx.arc(bx, by - bug.size - 5, 2, 0, math.pi * 2)
                ctx.fill()
            elif bug.command == 'attack' or bug.command == 'swarm':
                ctx.fillStyle = '#ff0000'
                ctx.beginPath()
                ctx.arc(bx, by - bug.size - 5, 2, 0, math.pi * 2)
                ctx.fill()

        # Draw enemies
        for enemy in self.enemies:
            if not enemy.alive:
                continue

            ex, ey = enemy.x - cam_x, enemy.y - cam_y

            if ex < -30 or ex > CANVAS_WIDTH + 30 or ey < -30 or ey > CANVAS_HEIGHT + 30:
                continue

            enemy.draw(ctx, ex, ey)

            # Health bar
            ctx.fillStyle = '#333'
            ctx.fillRect(ex - 15, ey - enemy.size//2 - 12, 30, 4)
            ctx.fillStyle = '#2ecc71'
            health_width = 30 * (enemy.hp / enemy.max_hp)
            ctx.fillRect(ex - 15, ey - enemy.size//2 - 12, health_width, 4)

            # Enemy type label
            ctx.fillStyle = 'rgba(0,0,0,0.5)'
            ctx.font = '8px monospace'
            ctx.fillText(enemy.enemy_type, ex - 10, ey + enemy.size//2 + 10)

            if self.swarm_sense:
                ctx.strokeStyle = 'rgba(231, 76, 60, 0.3)'
                ctx.lineWidth = 1
                ctx.beginPath()
                ctx.arc(ex, ey, enemy.vision, 0, math.pi * 2)
                ctx.stroke()

        # Draw Taylor
        self.taylor.draw(ctx, tx, ty)

        # Taylor health bar
        ctx.fillStyle = '#333'
        ctx.fillRect(tx - 20, ty - 28, 40, 5)
        ctx.fillStyle = '#3498db'
        health_width = 40 * (self.taylor.hp / self.taylor.max_hp)
        ctx.fillRect(tx - 20, ty - 28, health_width, 5)

        # Draw selection box
        if self.selection_box:
            box = self.selection_box
            x1 = box['start_x'] - cam_x
            y1 = box['start_y'] - cam_y
            x2 = box['end_x'] - cam_x
            y2 = box['end_y'] - cam_y

            ctx.strokeStyle = '#00ff00'
            ctx.lineWidth = 1
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'
            ctx.beginPath()
            ctx.rect(x1, y1, x2 - x1, y2 - y1)
            ctx.fill()
            ctx.stroke()

        # Swarm sense overlay
        if self.swarm_sense:
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

            ctx.globalCompositeOperation = 'destination-out'

            ctx.beginPath()
            ctx.arc(tx, ty, 100, 0, math.pi * 2)
            ctx.fill()

            for bug in self.bugs:
                if bug.controlled:
                    bx, by = bug.x - cam_x, bug.y - cam_y
                    ctx.beginPath()
                    ctx.arc(bx, by, bug.vision, 0, math.pi * 2)
                    ctx.fill()

            ctx.globalCompositeOperation = 'source-over'

            ctx.fillStyle = 'rgba(155, 89, 182, 0.1)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

        # Current command indicator
        if self.current_command:
            ctx.fillStyle = '#ffd700'
            ctx.font = '14px monospace'
            ctx.fillText(f"Command: {self.current_command.upper()} (click target)", 10, CANVAS_HEIGHT - 10)

        # HUD
        ctx.fillStyle = 'rgba(0,0,0,0.7)'
        ctx.fillRect(5, 5, 220, 75)
        ctx.fillStyle = '#fff'
        ctx.font = '12px monospace'

        area = get_area_at(self.taylor.x, self.taylor.y)
        area_name = area['name'] if area else 'Unknown'
        ctx.fillText(f"Location: {area_name}", 10, 22)
        ctx.fillText(f"Taylor HP: {int(self.taylor.hp)}/{self.taylor.max_hp}", 10, 38)

        controlled = len([b for b in self.bugs if b.controlled])
        ctx.fillText(f"Bugs: {controlled} controlled / {len(self.bugs)} total", 10, 54)

        enemies_alive = len([e for e in self.enemies if e.alive])
        ctx.fillText(f"Enemies: {enemies_alive} remaining", 10, 70)

        if self.swarm_sense:
            ctx.fillStyle = '#9b59b6'
            ctx.fillText("[TAB] SWARM SENSE ACTIVE", CANVAS_WIDTH - 200, 22)

        # Minimap
        minimap_w, minimap_h = 120, 90
        minimap_x = CANVAS_WIDTH - minimap_w - 10
        minimap_y = CANVAS_HEIGHT - minimap_h - 10
        ctx.fillStyle = 'rgba(0,0,0,0.7)'
        ctx.fillRect(minimap_x - 2, minimap_y - 2, minimap_w + 4, minimap_h + 4)

        # Draw areas on minimap
        for area in AREAS:
            mx = minimap_x + (area['x'] / MAP_WIDTH) * minimap_w
            my = minimap_y + (area['y'] / MAP_HEIGHT) * minimap_h
            mw = (area['width'] / MAP_WIDTH) * minimap_w
            mh = (area['height'] / MAP_HEIGHT) * minimap_h
            ctx.fillStyle = area['ground']
            ctx.fillRect(mx, my, mw, mh)

        # Taylor on minimap
        mtx = minimap_x + (self.taylor.x / MAP_WIDTH) * minimap_w
        mty = minimap_y + (self.taylor.y / MAP_HEIGHT) * minimap_h
        ctx.fillStyle = '#9b59b6'
        ctx.fillRect(mtx - 2, mty - 2, 4, 4)

        # Enemies on minimap
        for enemy in self.enemies:
            if enemy.alive:
                mex = minimap_x + (enemy.x / MAP_WIDTH) * minimap_w
                mey = minimap_y + (enemy.y / MAP_HEIGHT) * minimap_h
                ctx.fillStyle = '#e74c3c'
                ctx.fillRect(mex - 1, mey - 1, 2, 2)

        # Camera viewport on minimap
        ctx.strokeStyle = '#fff'
        ctx.lineWidth = 1
        cvx = minimap_x + (self.camera_x / MAP_WIDTH) * minimap_w
        cvy = minimap_y + (self.camera_y / MAP_HEIGHT) * minimap_h
        cvw = (CANVAS_WIDTH / MAP_WIDTH) * minimap_w
        cvh = (CANVAS_HEIGHT / MAP_HEIGHT) * minimap_h
        ctx.strokeRect(cvx, cvy, cvw, cvh)

        # Win/Lose check
        if enemies_alive == 0:
            ctx.fillStyle = 'rgba(0,0,0,0.8)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)
            ctx.fillStyle = '#2ecc71'
            ctx.font = '48px monospace'
            ctx.fillText("VICTORY!", CANVAS_WIDTH//2 - 100, CANVAS_HEIGHT//2)
            ctx.fillStyle = '#fff'
            ctx.font = '16px monospace'
            ctx.fillText("Brockton Bay is safe... for now.", CANVAS_WIDTH//2 - 130, CANVAS_HEIGHT//2 + 40)

        if self.taylor.hp <= 0:
            ctx.fillStyle = 'rgba(0,0,0,0.8)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)
            ctx.fillStyle = '#e74c3c'
            ctx.font = '48px monospace'
            ctx.fillText("DEFEATED", CANVAS_WIDTH//2 - 100, CANVAS_HEIGHT//2)

    def game_loop(self, timestamp):
        self.handle_input()
        self.update()
        self.render()

        if self.running:
            requestAnimationFrame(create_proxy(self.game_loop))

# Start game
game = Game()
requestAnimationFrame(create_proxy(game.game_loop))
`;

        main();
    </script>
</body>
</html>
