<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worm - Taylor's Bug Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            user-select: none;
        }
        h1 {
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 1.5em;
        }
        #loading {
            font-size: 1.2em;
            color: #ffd700;
            margin-bottom: 10px;
        }
        #game-wrapper {
            display: flex;
            gap: 10px;
        }
        #game-container {
            position: relative;
        }
        #game-canvas {
            display: block;
            background: #2d4a3e;
            border: 3px solid #e94560;
            border-radius: 4px;
            cursor: crosshair;
        }
        #ui-panel {
            width: 200px;
            background: #16213e;
            border: 2px solid #e94560;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
        }
        .panel-section {
            margin-bottom: 15px;
        }
        .panel-title {
            color: #e94560;
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #e94560;
            padding-bottom: 3px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        .command-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }
        .cmd-btn {
            background: #0f3460;
            border: 1px solid #e94560;
            color: #fff;
            padding: 8px 4px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
            transition: all 0.1s;
        }
        .cmd-btn:hover {
            background: #e94560;
        }
        .cmd-btn:active {
            transform: scale(0.95);
        }
        .cmd-btn .key {
            display: block;
            font-weight: bold;
            font-size: 14px;
            color: #ffd700;
        }
        .control-groups {
            display: flex;
            gap: 4px;
        }
        .group-btn {
            flex: 1;
            background: #0f3460;
            border: 1px solid #444;
            color: #888;
            padding: 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
        }
        .group-btn.active {
            border-color: #e94560;
            color: #fff;
        }
        .group-btn.has-bugs {
            background: #1a4a1a;
            color: #4a4;
        }
        #help-text {
            color: #888;
            font-size: 10px;
            line-height: 1.4;
        }
        #help-text kbd {
            background: #333;
            padding: 1px 4px;
            border-radius: 2px;
            color: #ffd700;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <h1>Taylor's Bug Control</h1>
    <div id="loading">Loading Pyodide...</div>

    <div id="game-wrapper" class="hidden">
        <div id="game-container">
            <canvas id="game-canvas" width="900" height="600"></canvas>
        </div>
        <div id="ui-panel">
            <div class="panel-section">
                <div class="panel-title">SELECTION</div>
                <div id="selection-info">No bugs selected</div>
            </div>

            <div class="panel-section">
                <div class="panel-title">COMMANDS</div>
                <div class="command-grid">
                    <div class="cmd-btn" data-cmd="attack"><span class="key">A</span>Attack</div>
                    <div class="cmd-btn" data-cmd="stop"><span class="key">S</span>Stop</div>
                    <div class="cmd-btn" data-cmd="guard"><span class="key">G</span>Guard</div>
                    <div class="cmd-btn" data-cmd="hide"><span class="key">H</span>Hide</div>
                    <div class="cmd-btn" data-cmd="swarm"><span class="key">J</span>Swarm</div>
                    <div class="cmd-btn" data-cmd="form"><span class="key">F</span>Form</div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">CONTROL GROUPS</div>
                <div class="control-groups">
                    <div class="group-btn" data-group="1">1</div>
                    <div class="group-btn" data-group="2">2</div>
                    <div class="group-btn" data-group="3">3</div>
                    <div class="group-btn" data-group="4">4</div>
                    <div class="group-btn" data-group="5">5</div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">TAYLOR</div>
                <div id="taylor-stats">
                    <div class="stat-row"><span>Health:</span><span id="taylor-hp">100/100</span></div>
                    <div class="stat-row"><span>Bugs:</span><span id="bug-count">0</span></div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">CONTROLS</div>
                <div id="help-text">
                    <kbd>WASD</kbd> Move Taylor<br>
                    <kbd>Click+Drag</kbd> Select bugs<br>
                    <kbd>Shift+Click</kbd> Add to selection<br>
                    <kbd>Ctrl+1-5</kbd> Assign group<br>
                    <kbd>1-5</kbd> Select group<br>
                    <kbd>Right-Click</kbd> Move/Attack<br>
                    <kbd>Tab</kbd> Swarm sense
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script>
        const loading = document.getElementById('loading');
        const gameWrapper = document.getElementById('game-wrapper');

        // Input state shared with Python
        window.inputState = {
            keys: {},
            mouse: { x: 0, y: 0, buttons: 0 },
            mouseDown: null,
            mouseUp: null,
            rightClick: null,
            cmdClick: null,
            wheelDelta: 0
        };

        window.uiState = {
            selectionInfo: '',
            taylorHp: '100/100',
            bugCount: '0',
            controlGroups: [0, 0, 0, 0, 0],
            activeGroup: -1
        };

        async function main() {
            try {
                loading.textContent = 'Loading Python runtime...';
                const pyodide = await loadPyodide();

                loading.textContent = 'Starting game...';

                // Set up input handlers
                const canvas = document.getElementById('game-canvas');

                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    window.inputState.mouse.x = e.clientX - rect.left;
                    window.inputState.mouse.y = e.clientY - rect.top;
                });

                canvas.addEventListener('mousedown', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (e.button === 0) {
                        window.inputState.mouse.buttons |= 1;
                        window.inputState.mouseDown = { x, y, shift: e.shiftKey };
                    } else if (e.button === 2) {
                        window.inputState.rightClick = { x, y };
                    }
                    e.preventDefault();
                });

                canvas.addEventListener('mouseup', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (e.button === 0) {
                        window.inputState.mouse.buttons &= ~1;
                        window.inputState.mouseUp = { x, y, shift: e.shiftKey };
                    }
                });

                canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                document.addEventListener('keydown', (e) => {
                    window.inputState.keys[e.code] = true;

                    // Handle control groups
                    if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                        const num = parseInt(e.code.replace('Digit', ''));
                        if (e.ctrlKey || e.metaKey) {
                            window.inputState.cmdClick = { type: 'assign', group: num };
                            e.preventDefault();
                        } else {
                            window.inputState.cmdClick = { type: 'select', group: num, time: Date.now() };
                        }
                    }

                    // Prevent scrolling with space/arrows
                    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    window.inputState.keys[e.code] = false;
                });

                // Command buttons
                document.querySelectorAll('.cmd-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const cmd = btn.dataset.cmd;
                        window.inputState.cmdClick = { type: 'command', command: cmd };
                    });
                });

                // Group buttons
                document.querySelectorAll('.group-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const group = parseInt(btn.dataset.group);
                        window.inputState.cmdClick = { type: 'select', group: group, time: Date.now() };
                    });
                });

                // Load the game
                await pyodide.runPythonAsync(`
${GAME_CODE}
                `);

                loading.classList.add('hidden');
                gameWrapper.classList.remove('hidden');

                // Update UI periodically
                setInterval(() => {
                    document.getElementById('selection-info').textContent = window.uiState.selectionInfo;
                    document.getElementById('taylor-hp').textContent = window.uiState.taylorHp;
                    document.getElementById('bug-count').textContent = window.uiState.bugCount;

                    document.querySelectorAll('.group-btn').forEach((btn, i) => {
                        const count = window.uiState.controlGroups[i];
                        btn.classList.toggle('has-bugs', count > 0);
                        btn.classList.toggle('active', window.uiState.activeGroup === i + 1);
                        btn.textContent = count > 0 ? `${i+1}(${count})` : `${i+1}`;
                    });
                }, 100);

            } catch (error) {
                loading.textContent = 'Error: ' + error.message;
                loading.style.color = '#ff4444';
                console.error(error);
            }
        }

        const GAME_CODE = `
import math
import random
from js import document, window, requestAnimationFrame
from pyodide.ffi import create_proxy

# ============== CONSTANTS ==============
CANVAS_WIDTH = 900
CANVAS_HEIGHT = 600
MAP_WIDTH = 1800
MAP_HEIGHT = 1200

TAYLOR_SPEED = 3
TAYLOR_CONTROL_RANGE = 200

BUG_TYPES = {
    'fly': {
        'color': '#ffeb3b',
        'speed': 4,
        'hp': 5,
        'damage': 1,
        'size': 4,
        'vision': 100
    },
    'spider': {
        'color': '#8b4513',
        'speed': 1.5,
        'hp': 15,
        'damage': 3,
        'size': 6,
        'vision': 40,
        'can_web': True
    },
    'wasp': {
        'color': '#ff9800',
        'speed': 3,
        'hp': 8,
        'damage': 8,
        'size': 5,
        'vision': 60,
        'sting_damage': 20,
        'can_sting': True
    }
}

# ============== UTILITY ==============
def distance(x1, y1, x2, y2):
    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

def normalize(x, y):
    d = math.sqrt(x*x + y*y)
    if d == 0:
        return 0, 0
    return x/d, y/d

def clamp(val, min_val, max_val):
    return max(min_val, min(max_val, val))

# ============== ENTITIES ==============
class Entity:
    next_id = 0

    def __init__(self, x, y):
        self.id = Entity.next_id
        Entity.next_id += 1
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.alive = True

class Taylor(Entity):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.hp = 100
        self.max_hp = 100
        self.control_range = TAYLOR_CONTROL_RANGE
        self.speed = TAYLOR_SPEED

    def update(self, keys):
        dx, dy = 0, 0
        if keys.get('KeyW') or keys.get('ArrowUp'):
            dy -= 1
        if keys.get('KeyS') or keys.get('ArrowDown'):
            dy += 1
        if keys.get('KeyA') or keys.get('ArrowLeft'):
            dx -= 1
        if keys.get('KeyD') or keys.get('ArrowRight'):
            dx += 1

        if dx != 0 or dy != 0:
            dx, dy = normalize(dx, dy)
            self.x += dx * self.speed
            self.y += dy * self.speed

        # Clamp to map
        self.x = clamp(self.x, 20, MAP_WIDTH - 20)
        self.y = clamp(self.y, 20, MAP_HEIGHT - 20)

class Bug(Entity):
    def __init__(self, x, y, bug_type):
        super().__init__(x, y)
        self.bug_type = bug_type
        stats = BUG_TYPES[bug_type]
        self.color = stats['color']
        self.speed = stats['speed']
        self.hp = stats['hp']
        self.max_hp = stats['hp']
        self.damage = stats['damage']
        self.size = stats['size']
        self.vision = stats['vision']
        self.can_web = stats.get('can_web', False)
        self.can_sting = stats.get('can_sting', False)
        self.sting_damage = stats.get('sting_damage', 0)
        self.has_stung = False

        self.selected = False
        self.controlled = True
        self.target = None
        self.target_entity = None
        self.command = 'idle'
        self.guard_angle = random.uniform(0, math.pi * 2)
        self.orbit_speed = random.uniform(0.02, 0.04)

        # Wandering behavior
        self.wander_angle = random.uniform(0, math.pi * 2)
        self.wander_timer = 0

    def update(self, taylor, enemies):
        if not self.alive:
            return

        # Check if in Taylor's control range
        dist_to_taylor = distance(self.x, self.y, taylor.x, taylor.y)
        was_controlled = self.controlled
        self.controlled = dist_to_taylor <= taylor.control_range

        if not self.controlled:
            # Uncontrolled: wander randomly
            self.wander_timer -= 1
            if self.wander_timer <= 0:
                self.wander_angle += random.uniform(-0.5, 0.5)
                self.wander_timer = random.randint(30, 90)

            self.x += math.cos(self.wander_angle) * self.speed * 0.3
            self.y += math.sin(self.wander_angle) * self.speed * 0.3
            self.command = 'idle'
            self.selected = False
            return

        # Execute command
        if self.command == 'idle':
            pass

        elif self.command == 'move' and self.target:
            tx, ty = self.target
            dx, dy = tx - self.x, ty - self.y
            dist = math.sqrt(dx*dx + dy*dy)
            if dist > 5:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed
            else:
                self.command = 'idle'
                self.target = None

        elif self.command == 'attack' and self.target:
            tx, ty = self.target
            dx, dy = tx - self.x, ty - self.y
            dist = math.sqrt(dx*dx + dy*dy)

            # Check for enemies along the way
            nearest_enemy = None
            nearest_dist = float('inf')
            for enemy in enemies:
                if enemy.alive:
                    ed = distance(self.x, self.y, enemy.x, enemy.y)
                    if ed < self.vision and ed < nearest_dist:
                        nearest_enemy = enemy
                        nearest_dist = ed

            if nearest_enemy and nearest_dist < 20:
                # Attack!
                self.attack_enemy(nearest_enemy)
            elif nearest_enemy:
                # Move toward enemy
                dx, dy = normalize(nearest_enemy.x - self.x, nearest_enemy.y - self.y)
                self.x += dx * self.speed
                self.y += dy * self.speed
            elif dist > 5:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed
            else:
                self.command = 'idle'
                self.target = None

        elif self.command == 'guard':
            # Orbit around Taylor
            self.guard_angle += self.orbit_speed
            target_x = taylor.x + math.cos(self.guard_angle) * 50
            target_y = taylor.y + math.sin(self.guard_angle) * 50

            dx, dy = target_x - self.x, target_y - self.y
            dist = math.sqrt(dx*dx + dy*dy)
            if dist > 3:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed

            # Attack nearby enemies
            for enemy in enemies:
                if enemy.alive:
                    ed = distance(self.x, self.y, enemy.x, enemy.y)
                    if ed < 25:
                        self.attack_enemy(enemy)
                        break

        elif self.command == 'hide':
            # Spread out from other bugs
            push_x, push_y = 0, 0
            # Move away from Taylor slightly
            dx, dy = self.x - taylor.x, self.y - taylor.y
            if dx != 0 or dy != 0:
                dx, dy = normalize(dx, dy)
                target_x = taylor.x + dx * taylor.control_range * 0.8
                target_y = taylor.y + dy * taylor.control_range * 0.8

                mx, my = target_x - self.x, target_y - self.y
                dist = math.sqrt(mx*mx + my*my)
                if dist > 5:
                    mx, my = normalize(mx, my)
                    self.x += mx * self.speed * 0.5
                    self.y += my * self.speed * 0.5

        elif self.command == 'swarm' and self.target_entity:
            enemy = self.target_entity
            if enemy.alive:
                dx, dy = enemy.x - self.x, enemy.y - self.y
                dist = math.sqrt(dx*dx + dy*dy)
                if dist < 15:
                    self.attack_enemy(enemy)
                else:
                    dx, dy = normalize(dx, dy)
                    self.x += dx * self.speed * 1.2  # Faster when swarming
                    self.y += dy * self.speed * 1.2
            else:
                self.command = 'idle'
                self.target_entity = None

        # Clamp to map
        self.x = clamp(self.x, 5, MAP_WIDTH - 5)
        self.y = clamp(self.y, 5, MAP_HEIGHT - 5)

    def attack_enemy(self, enemy):
        if self.can_sting and not self.has_stung:
            enemy.hp -= self.sting_damage
            self.has_stung = True
            self.hp = 0
            self.alive = False
        else:
            enemy.hp -= self.damage
            if enemy.hp <= 0:
                enemy.alive = False

class Enemy(Entity):
    def __init__(self, x, y, enemy_type='grunt'):
        super().__init__(x, y)
        self.enemy_type = enemy_type
        self.hp = 50
        self.max_hp = 50
        self.speed = 1.5
        self.damage = 10
        self.size = 16
        self.vision = 150
        self.attack_range = 30
        self.attack_cooldown = 0

        # Patrol
        self.patrol_points = []
        self.patrol_index = 0
        self.state = 'patrol'
        self.target = None

    def set_patrol(self, points):
        self.patrol_points = points
        self.patrol_index = 0

    def update(self, taylor, bugs):
        if not self.alive:
            return

        self.attack_cooldown = max(0, self.attack_cooldown - 1)

        # Check for Taylor or bugs in vision
        dist_to_taylor = distance(self.x, self.y, taylor.x, taylor.y)

        # Find nearest threat
        nearest_bug = None
        nearest_bug_dist = float('inf')
        for bug in bugs:
            if bug.alive and bug.controlled:
                d = distance(self.x, self.y, bug.x, bug.y)
                if d < nearest_bug_dist:
                    nearest_bug = bug
                    nearest_bug_dist = d

        # Decide what to do
        if dist_to_taylor < self.vision:
            self.state = 'chase'
            self.target = taylor
        elif nearest_bug and nearest_bug_dist < self.vision:
            self.state = 'chase'
            self.target = nearest_bug
        else:
            self.state = 'patrol'
            self.target = None

        # Execute state
        if self.state == 'chase' and self.target:
            dx, dy = self.target.x - self.x, self.target.y - self.y
            dist = math.sqrt(dx*dx + dy*dy)

            if dist < self.attack_range:
                if self.attack_cooldown == 0:
                    self.target.hp -= self.damage
                    self.attack_cooldown = 60
                    if self.target.hp <= 0:
                        self.target.alive = False
            else:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed
                self.y += dy * self.speed

        elif self.state == 'patrol' and self.patrol_points:
            px, py = self.patrol_points[self.patrol_index]
            dx, dy = px - self.x, py - self.y
            dist = math.sqrt(dx*dx + dy*dy)

            if dist < 10:
                self.patrol_index = (self.patrol_index + 1) % len(self.patrol_points)
            else:
                dx, dy = normalize(dx, dy)
                self.x += dx * self.speed * 0.5
                self.y += dy * self.speed * 0.5

        self.x = clamp(self.x, 20, MAP_WIDTH - 20)
        self.y = clamp(self.y, 20, MAP_HEIGHT - 20)

class WebTrap(Entity):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.radius = 40
        self.duration = 600  # 10 seconds
        self.slow_factor = 0.3

    def update(self):
        self.duration -= 1
        if self.duration <= 0:
            self.alive = False

# ============== GAME ==============
class Game:
    def __init__(self):
        self.canvas = document.getElementById('game-canvas')
        self.ctx = self.canvas.getContext('2d')

        self.taylor = Taylor(MAP_WIDTH // 2, MAP_HEIGHT // 2)
        self.bugs = []
        self.enemies = []
        self.webs = []
        self.control_groups = {1: [], 2: [], 3: [], 4: [], 5: []}

        self.camera_x = self.taylor.x - CANVAS_WIDTH // 2
        self.camera_y = self.taylor.y - CANVAS_HEIGHT // 2

        self.selection_box = None
        self.current_command = None
        self.swarm_sense = False
        self.last_group_press = {'group': 0, 'time': 0}

        self.spawn_initial_bugs()
        self.spawn_enemies()

        self.running = True
        self.frame_count = 0

    def spawn_initial_bugs(self):
        # Spawn mixed swarm around Taylor
        for _ in range(30):
            angle = random.uniform(0, math.pi * 2)
            dist = random.uniform(30, 150)
            x = self.taylor.x + math.cos(angle) * dist
            y = self.taylor.y + math.sin(angle) * dist
            bug_type = random.choice(['fly', 'fly', 'fly', 'spider', 'wasp', 'wasp'])
            self.bugs.append(Bug(x, y, bug_type))

        # Spawn some bugs around the map
        for _ in range(50):
            x = random.uniform(100, MAP_WIDTH - 100)
            y = random.uniform(100, MAP_HEIGHT - 100)
            bug_type = random.choice(['fly', 'spider', 'wasp'])
            self.bugs.append(Bug(x, y, bug_type))

    def spawn_enemies(self):
        # Patrol group 1
        e1 = Enemy(300, 300)
        e1.set_patrol([(300, 300), (500, 300), (500, 500), (300, 500)])
        self.enemies.append(e1)

        # Patrol group 2
        e2 = Enemy(1400, 400)
        e2.set_patrol([(1400, 400), (1600, 400), (1600, 600), (1400, 600)])
        self.enemies.append(e2)

        # Patrol group 3
        e3 = Enemy(800, 900)
        e3.set_patrol([(800, 900), (1000, 900), (1000, 1100), (800, 1100)])
        self.enemies.append(e3)

        # Stationary guards
        self.enemies.append(Enemy(200, 800))
        self.enemies.append(Enemy(1500, 200))

    def handle_input(self):
        input_state = window.inputState
        keys = dict(input_state.keys.object_entries())

        # Taylor movement
        self.taylor.update(keys)

        # Swarm sense toggle
        if keys.get('Tab'):
            if not hasattr(self, '_tab_held'):
                self._tab_held = False
            if not self._tab_held:
                self.swarm_sense = not self.swarm_sense
                self._tab_held = True
        else:
            self._tab_held = False

        # Selection box
        mouse_down = input_state.mouseDown
        mouse_up = input_state.mouseUp

        if mouse_down:
            start_x = mouse_down.x + self.camera_x
            start_y = mouse_down.y + self.camera_y
            self.selection_box = {
                'start_x': start_x,
                'start_y': start_y,
                'end_x': start_x,
                'end_y': start_y,
                'shift': mouse_down.shift
            }
            input_state.mouseDown = None

        if self.selection_box:
            mouse = input_state.mouse
            self.selection_box['end_x'] = mouse.x + self.camera_x
            self.selection_box['end_y'] = mouse.y + self.camera_y

        if mouse_up and self.selection_box:
            self.finish_selection(mouse_up.shift)
            self.selection_box = None
            input_state.mouseUp = None

        # Right click - move/attack command
        right_click = input_state.rightClick
        if right_click:
            target_x = right_click.x + self.camera_x
            target_y = right_click.y + self.camera_y

            # Check if clicking on enemy
            clicked_enemy = None
            for enemy in self.enemies:
                if enemy.alive:
                    if distance(target_x, target_y, enemy.x, enemy.y) < enemy.size:
                        clicked_enemy = enemy
                        break

            if clicked_enemy:
                self.command_swarm(clicked_enemy)
            else:
                self.command_move(target_x, target_y)

            input_state.rightClick = None

        # Command buttons and groups
        cmd_click = input_state.cmdClick
        if cmd_click:
            cmd_type = cmd_click.type if hasattr(cmd_click, 'type') else cmd_click.get('type')

            if cmd_type == 'command':
                cmd = cmd_click.command if hasattr(cmd_click, 'command') else cmd_click.get('command')
                self.execute_command(cmd)
            elif cmd_type == 'assign':
                group = cmd_click.group if hasattr(cmd_click, 'group') else cmd_click.get('group')
                self.assign_control_group(group)
            elif cmd_type == 'select':
                group = cmd_click.group if hasattr(cmd_click, 'group') else cmd_click.get('group')
                click_time = cmd_click.time if hasattr(cmd_click, 'time') else cmd_click.get('time')

                # Double-tap detection
                if (self.last_group_press['group'] == group and
                    click_time - self.last_group_press['time'] < 300):
                    self.center_on_group(group)
                else:
                    self.select_control_group(group)

                self.last_group_press = {'group': group, 'time': click_time}

            input_state.cmdClick = None

        # Keyboard commands
        if keys.get('KeyA'):
            if not hasattr(self, '_a_held') or not self._a_held:
                self.current_command = 'attack'
                self._a_held = True
        else:
            self._a_held = False

        if keys.get('KeyS'):
            if not hasattr(self, '_s_held') or not self._s_held:
                self.execute_command('stop')
                self._s_held = True
        else:
            self._s_held = False

        if keys.get('KeyG'):
            if not hasattr(self, '_g_held') or not self._g_held:
                self.execute_command('guard')
                self._g_held = True
        else:
            self._g_held = False

        if keys.get('KeyH'):
            if not hasattr(self, '_h_held') or not self._h_held:
                self.execute_command('hide')
                self._h_held = True
        else:
            self._h_held = False

        if keys.get('KeyJ'):
            if not hasattr(self, '_j_held') or not self._j_held:
                self.current_command = 'swarm'
                self._j_held = True
        else:
            self._j_held = False

    def finish_selection(self, shift):
        box = self.selection_box
        x1 = min(box['start_x'], box['end_x'])
        y1 = min(box['start_y'], box['end_y'])
        x2 = max(box['start_x'], box['end_x'])
        y2 = max(box['start_y'], box['end_y'])

        # If box is tiny, treat as click
        if abs(x2 - x1) < 5 and abs(y2 - y1) < 5:
            # Click selection
            if not shift:
                for bug in self.bugs:
                    bug.selected = False

            for bug in self.bugs:
                if bug.alive and bug.controlled:
                    if distance(x1, y1, bug.x, bug.y) < 15:
                        bug.selected = not bug.selected if shift else True
                        break
        else:
            # Box selection
            if not shift:
                for bug in self.bugs:
                    bug.selected = False

            for bug in self.bugs:
                if bug.alive and bug.controlled:
                    if x1 <= bug.x <= x2 and y1 <= bug.y <= y2:
                        bug.selected = True

    def command_move(self, x, y):
        selected = [b for b in self.bugs if b.selected and b.alive]
        if not selected:
            return

        # Formation spread
        count = len(selected)
        cols = int(math.ceil(math.sqrt(count)))
        spacing = 15

        for i, bug in enumerate(selected):
            row = i // cols
            col = i % cols
            offset_x = (col - cols // 2) * spacing
            offset_y = (row - count // cols // 2) * spacing

            if self.current_command == 'attack':
                bug.command = 'attack'
            else:
                bug.command = 'move'
            bug.target = (x + offset_x, y + offset_y)

        self.current_command = None

    def command_swarm(self, enemy):
        selected = [b for b in self.bugs if b.selected and b.alive]
        for bug in selected:
            bug.command = 'swarm'
            bug.target_entity = enemy

    def execute_command(self, cmd):
        selected = [b for b in self.bugs if b.selected and b.alive]

        if cmd == 'stop':
            for bug in selected:
                bug.command = 'idle'
                bug.target = None
                bug.target_entity = None
        elif cmd == 'guard':
            for bug in selected:
                bug.command = 'guard'
                bug.guard_angle = random.uniform(0, math.pi * 2)
        elif cmd == 'hide':
            for bug in selected:
                bug.command = 'hide'
        elif cmd == 'attack':
            self.current_command = 'attack'
        elif cmd == 'swarm':
            self.current_command = 'swarm'

    def assign_control_group(self, group):
        selected = [b for b in self.bugs if b.selected and b.alive]
        self.control_groups[group] = [b.id for b in selected]

    def select_control_group(self, group):
        # Deselect all
        for bug in self.bugs:
            bug.selected = False

        # Select group members
        group_ids = self.control_groups[group]
        for bug in self.bugs:
            if bug.id in group_ids and bug.alive and bug.controlled:
                bug.selected = True

        window.uiState.activeGroup = group

    def center_on_group(self, group):
        group_ids = self.control_groups[group]
        bugs_in_group = [b for b in self.bugs if b.id in group_ids and b.alive]

        if bugs_in_group:
            avg_x = sum(b.x for b in bugs_in_group) / len(bugs_in_group)
            avg_y = sum(b.y for b in bugs_in_group) / len(bugs_in_group)
            self.camera_x = avg_x - CANVAS_WIDTH // 2
            self.camera_y = avg_y - CANVAS_HEIGHT // 2

    def update(self):
        self.frame_count += 1

        # Update bugs
        for bug in self.bugs:
            bug.update(self.taylor, self.enemies)

        # Update enemies
        for enemy in self.enemies:
            enemy.update(self.taylor, self.bugs)

        # Update webs
        for web in self.webs:
            web.update()
        self.webs = [w for w in self.webs if w.alive]

        # Remove dead bugs
        self.bugs = [b for b in self.bugs if b.alive]

        # Update camera to follow Taylor
        target_cam_x = self.taylor.x - CANVAS_WIDTH // 2
        target_cam_y = self.taylor.y - CANVAS_HEIGHT // 2
        self.camera_x += (target_cam_x - self.camera_x) * 0.1
        self.camera_y += (target_cam_y - self.camera_y) * 0.1

        # Clamp camera
        self.camera_x = clamp(self.camera_x, 0, MAP_WIDTH - CANVAS_WIDTH)
        self.camera_y = clamp(self.camera_y, 0, MAP_HEIGHT - CANVAS_HEIGHT)

        # Update UI state
        selected = [b for b in self.bugs if b.selected]
        if selected:
            types = {}
            for b in selected:
                types[b.bug_type] = types.get(b.bug_type, 0) + 1
            info = f"{len(selected)} selected\\n"
            for t, c in types.items():
                info += f"  {t}: {c}\\n"
            window.uiState.selectionInfo = info
        else:
            window.uiState.selectionInfo = "No bugs selected"

        window.uiState.taylorHp = f"{int(self.taylor.hp)}/{self.taylor.max_hp}"
        controlled = len([b for b in self.bugs if b.controlled])
        window.uiState.bugCount = f"{controlled}/{len(self.bugs)}"

        # Update control group counts
        for i in range(5):
            group_ids = self.control_groups[i + 1]
            count = len([b for b in self.bugs if b.id in group_ids and b.alive and b.controlled])
            window.uiState.controlGroups[i] = count

    def render(self):
        ctx = self.ctx
        cam_x, cam_y = self.camera_x, self.camera_y

        # Clear
        ctx.fillStyle = '#2d4a3e'
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

        # Draw grid
        ctx.strokeStyle = 'rgba(255,255,255,0.1)'
        ctx.lineWidth = 1
        grid_size = 50
        start_x = -(cam_x % grid_size)
        start_y = -(cam_y % grid_size)

        for x in range(int(start_x), CANVAS_WIDTH + grid_size, grid_size):
            ctx.beginPath()
            ctx.moveTo(x, 0)
            ctx.lineTo(x, CANVAS_HEIGHT)
            ctx.stroke()

        for y in range(int(start_y), CANVAS_HEIGHT + grid_size, grid_size):
            ctx.beginPath()
            ctx.moveTo(0, y)
            ctx.lineTo(CANVAS_WIDTH, y)
            ctx.stroke()

        # Draw map boundary
        ctx.strokeStyle = '#e94560'
        ctx.lineWidth = 3
        ctx.strokeRect(-cam_x, -cam_y, MAP_WIDTH, MAP_HEIGHT)

        # Draw webs
        for web in self.webs:
            sx, sy = web.x - cam_x, web.y - cam_y
            ctx.fillStyle = 'rgba(255,255,255,0.2)'
            ctx.beginPath()
            ctx.arc(sx, sy, web.radius, 0, math.pi * 2)
            ctx.fill()

        # Draw control range
        tx, ty = self.taylor.x - cam_x, self.taylor.y - cam_y
        ctx.strokeStyle = 'rgba(155, 89, 182, 0.4)'
        ctx.lineWidth = 2
        ctx.setLineDash([5, 5])
        ctx.beginPath()
        ctx.arc(tx, ty, self.taylor.control_range, 0, math.pi * 2)
        ctx.stroke()
        ctx.setLineDash([])

        # Draw bugs
        for bug in self.bugs:
            bx, by = bug.x - cam_x, bug.y - cam_y

            # Skip if off screen
            if bx < -20 or bx > CANVAS_WIDTH + 20 or by < -20 or by > CANVAS_HEIGHT + 20:
                continue

            # Selection highlight
            if bug.selected:
                ctx.strokeStyle = '#00ff00'
                ctx.lineWidth = 2
                ctx.beginPath()
                ctx.arc(bx, by, bug.size + 3, 0, math.pi * 2)
                ctx.stroke()

            # Bug body
            if bug.controlled:
                ctx.fillStyle = bug.color
            else:
                ctx.fillStyle = '#666'  # Gray for uncontrolled

            ctx.beginPath()
            ctx.arc(bx, by, bug.size, 0, math.pi * 2)
            ctx.fill()

            # Command indicator
            if bug.command == 'guard':
                ctx.fillStyle = '#00ffff'
                ctx.beginPath()
                ctx.arc(bx, by - bug.size - 4, 2, 0, math.pi * 2)
                ctx.fill()
            elif bug.command == 'attack' or bug.command == 'swarm':
                ctx.fillStyle = '#ff0000'
                ctx.beginPath()
                ctx.arc(bx, by - bug.size - 4, 2, 0, math.pi * 2)
                ctx.fill()

        # Draw enemies
        for enemy in self.enemies:
            if not enemy.alive:
                continue

            ex, ey = enemy.x - cam_x, enemy.y - cam_y

            if ex < -30 or ex > CANVAS_WIDTH + 30 or ey < -30 or ey > CANVAS_HEIGHT + 30:
                continue

            # Enemy body
            ctx.fillStyle = '#e74c3c'
            ctx.fillRect(ex - enemy.size//2, ey - enemy.size//2, enemy.size, enemy.size)

            # Health bar
            ctx.fillStyle = '#333'
            ctx.fillRect(ex - 15, ey - enemy.size//2 - 8, 30, 4)
            ctx.fillStyle = '#2ecc71'
            health_width = 30 * (enemy.hp / enemy.max_hp)
            ctx.fillRect(ex - 15, ey - enemy.size//2 - 8, health_width, 4)

            # Vision range (in swarm sense mode)
            if self.swarm_sense:
                ctx.strokeStyle = 'rgba(231, 76, 60, 0.3)'
                ctx.lineWidth = 1
                ctx.beginPath()
                ctx.arc(ex, ey, enemy.vision, 0, math.pi * 2)
                ctx.stroke()

        # Draw Taylor
        ctx.fillStyle = '#9b59b6'
        ctx.fillRect(tx - 16, ty - 16, 32, 32)

        # Taylor health bar
        ctx.fillStyle = '#333'
        ctx.fillRect(tx - 20, ty - 25, 40, 5)
        ctx.fillStyle = '#3498db'
        health_width = 40 * (self.taylor.hp / self.taylor.max_hp)
        ctx.fillRect(tx - 20, ty - 25, health_width, 5)

        # Draw selection box
        if self.selection_box:
            box = self.selection_box
            x1 = box['start_x'] - cam_x
            y1 = box['start_y'] - cam_y
            x2 = box['end_x'] - cam_x
            y2 = box['end_y'] - cam_y

            ctx.strokeStyle = '#00ff00'
            ctx.lineWidth = 1
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'
            ctx.beginPath()
            ctx.rect(x1, y1, x2 - x1, y2 - y1)
            ctx.fill()
            ctx.stroke()

        # Swarm sense overlay
        if self.swarm_sense:
            # Darken areas outside bug vision
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

            # Cut out vision circles
            ctx.globalCompositeOperation = 'destination-out'

            # Taylor's personal vision
            ctx.beginPath()
            ctx.arc(tx, ty, 100, 0, math.pi * 2)
            ctx.fill()

            # Bug vision
            for bug in self.bugs:
                if bug.controlled:
                    bx, by = bug.x - cam_x, bug.y - cam_y
                    ctx.beginPath()
                    ctx.arc(bx, by, bug.vision, 0, math.pi * 2)
                    ctx.fill()

            ctx.globalCompositeOperation = 'source-over'

            # Overlay tint
            ctx.fillStyle = 'rgba(155, 89, 182, 0.1)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

        # Current command indicator
        if self.current_command:
            ctx.fillStyle = '#ffd700'
            ctx.font = '14px monospace'
            ctx.fillText(f"Command: {self.current_command.upper()} (click target)", 10, CANVAS_HEIGHT - 10)

        # HUD
        ctx.fillStyle = 'rgba(0,0,0,0.7)'
        ctx.fillRect(5, 5, 200, 60)
        ctx.fillStyle = '#fff'
        ctx.font = '12px monospace'
        ctx.fillText(f"Taylor HP: {int(self.taylor.hp)}/{self.taylor.max_hp}", 10, 22)

        controlled = len([b for b in self.bugs if b.controlled])
        ctx.fillText(f"Bugs: {controlled} controlled / {len(self.bugs)} total", 10, 38)

        enemies_alive = len([e for e in self.enemies if e.alive])
        ctx.fillText(f"Enemies: {enemies_alive} remaining", 10, 54)

        # Swarm sense indicator
        if self.swarm_sense:
            ctx.fillStyle = '#9b59b6'
            ctx.fillText("[TAB] SWARM SENSE ACTIVE", CANVAS_WIDTH - 200, 22)

        # Win/Lose check
        if enemies_alive == 0:
            ctx.fillStyle = 'rgba(0,0,0,0.8)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)
            ctx.fillStyle = '#2ecc71'
            ctx.font = '48px monospace'
            ctx.fillText("VICTORY!", CANVAS_WIDTH//2 - 100, CANVAS_HEIGHT//2)

        if self.taylor.hp <= 0:
            ctx.fillStyle = 'rgba(0,0,0,0.8)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)
            ctx.fillStyle = '#e74c3c'
            ctx.font = '48px monospace'
            ctx.fillText("DEFEATED", CANVAS_WIDTH//2 - 100, CANVAS_HEIGHT//2)

    def game_loop(self, timestamp):
        self.handle_input()
        self.update()
        self.render()

        if self.running:
            requestAnimationFrame(create_proxy(self.game_loop))

# Start game
game = Game()
requestAnimationFrame(create_proxy(game.game_loop))
`;

        main();
    </script>
</body>
</html>
