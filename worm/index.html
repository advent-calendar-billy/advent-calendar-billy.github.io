<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worm: Gestation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0a0a0f;
            color: #c0c0c0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            user-select: none;
        }
        h1 {
            color: #8b7355;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 1.4em;
            letter-spacing: 2px;
        }
        .subtitle {
            color: #666;
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        #loading {
            font-size: 1em;
            color: #8b7355;
            margin-bottom: 10px;
        }
        #game-container {
            position: relative;
        }
        #game-canvas {
            display: block;
            background: #0f0f15;
            border: 2px solid #333;
            image-rendering: pixelated;
        }
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        .hp-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .hp-label {
            color: #8b7355;
            font-size: 10px;
            width: 50px;
        }
        .hp-bar-outer {
            width: 120px;
            height: 10px;
            background: #1a1a20;
            border: 1px solid #333;
        }
        .hp-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #4a6a5a 0%, #6a9a7a 100%);
            transition: width 0.3s;
        }
        .hp-bar-inner.enemy {
            background: linear-gradient(90deg, #6a4a4a 0%, #9a6a6a 100%);
        }
        .swarm-count {
            color: #7a7a5a;
            font-size: 10px;
        }
        #controls-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #444;
            font-size: 9px;
            pointer-events: none;
        }
        #controls-hint kbd {
            background: #1a1a20;
            padding: 1px 4px;
            border: 1px solid #333;
            color: #666;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <h1>WORM: GESTATION</h1>
    <div class="subtitle">The Docks - Brockton Bay</div>
    <div id="loading">Initializing...</div>

    <div id="game-container" class="hidden">
        <canvas id="game-canvas" width="900" height="600"></canvas>
        <div id="ui-overlay">
            <div class="hp-container">
                <span class="hp-label">TAYLOR</span>
                <div class="hp-bar-outer">
                    <div class="hp-bar-inner" id="taylor-hp" style="width: 100%"></div>
                </div>
            </div>
            <div class="hp-container hidden" id="boss-hp-container">
                <span class="hp-label">LUNG</span>
                <div class="hp-bar-outer">
                    <div class="hp-bar-inner enemy" id="boss-hp" style="width: 100%"></div>
                </div>
            </div>
            <div class="swarm-count" id="swarm-count">Swarm: 0</div>
        </div>
        <div id="controls-hint">
            <kbd>A/D</kbd> Move
            <kbd>SPACE</kbd> Jump
            <kbd>J</kbd> Sting
            <kbd>K</kbd> Bite
            <kbd>L</kbd> Blind
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script>
        const loading = document.getElementById('loading');
        const gameContainer = document.getElementById('game-container');

        window.keysHeld = {};
        window.keysJustPressed = [];

        window.uiState = {
            taylorHp: 100,
            bossHp: 100,
            bossVisible: false,
            swarmCount: 0
        };

        async function main() {
            try {
                loading.textContent = 'Loading Python runtime...';
                const pyodide = await loadPyodide();

                loading.textContent = 'Entering Brockton Bay...';

                document.addEventListener('keydown', (e) => {
                    if (!window.keysHeld[e.code]) {
                        window.keysJustPressed.push(e.code);
                    }
                    window.keysHeld[e.code] = true;
                    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    window.keysHeld[e.code] = false;
                });

                await pyodide.runPythonAsync(`
${GAME_CODE}
                `);

                loading.classList.add('hidden');
                gameContainer.classList.remove('hidden');

                // Update UI
                setInterval(() => {
                    document.getElementById('taylor-hp').style.width = window.uiState.taylorHp + '%';
                    document.getElementById('boss-hp').style.width = window.uiState.bossHp + '%';
                    document.getElementById('boss-hp-container').classList.toggle('hidden', !window.uiState.bossVisible);
                    document.getElementById('swarm-count').textContent = 'Swarm: ' + window.uiState.swarmCount;
                }, 100);

            } catch (error) {
                loading.textContent = 'Error: ' + error.message;
                loading.style.color = '#ff4444';
                console.error(error);
            }
        }

        const GAME_CODE = `
import math
import random
from js import document, window, requestAnimationFrame
from pyodide.ffi import create_proxy

# ============== CONSTANTS ==============
CANVAS_WIDTH = 900
CANVAS_HEIGHT = 600
WORLD_WIDTH = 2400
WORLD_HEIGHT = 900

GRAVITY = 0.5
JUMP_FORCE = -11
MAX_FALL_SPEED = 12
TAYLOR_SPEED = 3.5

# ============== UTILITY ==============
def clamp(val, min_val, max_val):
    return max(min_val, min(max_val, val))

def lerp(a, b, t):
    return a + (b - a) * t

def distance(x1, y1, x2, y2):
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def rect_intersect(x1, y1, w1, h1, x2, y2, w2, h2):
    return x1 < x2 + w2 and x1 + w1 > x2 and y1 < y2 + h2 and y1 + h1 > y2

# ============== PLATFORMS ==============
class Platform:
    def __init__(self, x, y, w, h, platform_type='solid'):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.platform_type = platform_type  # 'solid', 'one_way'

    def draw(self, ctx, cx, cy):
        sx, sy = self.x - cx, self.y - cy

        if self.platform_type == 'solid':
            # Main platform
            ctx.fillStyle = '#1a1a22'
            ctx.fillRect(sx, sy, self.w, self.h)

            # Top edge highlight
            ctx.fillStyle = '#2a2a35'
            ctx.fillRect(sx, sy, self.w, 3)

            # Texture lines
            ctx.strokeStyle = '#151518'
            ctx.lineWidth = 1
            for i in range(int(self.w // 40)):
                lx = sx + 20 + i * 40
                ctx.beginPath()
                ctx.moveTo(lx, sy + 4)
                ctx.lineTo(lx, sy + self.h)
                ctx.stroke()
        else:
            # One-way platform (thinner, can jump through from below)
            ctx.fillStyle = '#252530'
            ctx.fillRect(sx, sy, self.w, 8)
            ctx.fillStyle = '#3a3a45'
            ctx.fillRect(sx, sy, self.w, 2)

# ============== TAYLOR ==============
class Taylor:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.w = 20
        self.h = 40

        self.hp = 100
        self.max_hp = 100

        self.on_ground = False
        self.facing = 1  # 1 = right, -1 = left
        self.state = 'idle'  # idle, run, jump, fall, attack

        self.attack_timer = 0
        self.attack_type = None
        self.attack_cooldown = 0
        self.invuln_timer = 0

        self.anim_frame = 0
        self.anim_timer = 0

    def update(self, keys, key_pressed, platforms):
        # Movement
        move_x = 0
        if keys.get('KeyA') or keys.get('ArrowLeft'):
            move_x = -1
            self.facing = -1
        if keys.get('KeyD') or keys.get('ArrowRight'):
            move_x = 1
            self.facing = 1

        self.vx = move_x * TAYLOR_SPEED

        # Jumping
        if (key_pressed.get('Space') or key_pressed.get('KeyW') or key_pressed.get('ArrowUp')) and self.on_ground:
            self.vy = JUMP_FORCE
            self.on_ground = False

        # Gravity
        self.vy += GRAVITY
        self.vy = min(self.vy, MAX_FALL_SPEED)

        # Attack inputs
        if self.attack_cooldown <= 0:
            if key_pressed.get('KeyJ'):
                self.start_attack('sting')
            elif key_pressed.get('KeyK'):
                self.start_attack('bite')
            elif key_pressed.get('KeyL'):
                self.start_attack('blind')

        # Update attack
        if self.attack_timer > 0:
            self.attack_timer -= 1
            if self.attack_timer <= 0:
                self.attack_type = None

        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1

        if self.invuln_timer > 0:
            self.invuln_timer -= 1

        # Apply velocity
        self.x += self.vx
        self.y += self.vy

        # Collision with platforms
        self.on_ground = False
        for plat in platforms:
            if self.collide_platform(plat):
                pass  # Collision handled in method

        # World bounds
        self.x = clamp(self.x, 0, WORLD_WIDTH - self.w)
        self.y = clamp(self.y, 0, WORLD_HEIGHT - self.h)

        # Ground at bottom
        if self.y + self.h >= WORLD_HEIGHT - 50:
            self.y = WORLD_HEIGHT - 50 - self.h
            self.vy = 0
            self.on_ground = True

        # State
        if self.attack_timer > 0:
            self.state = 'attack'
        elif not self.on_ground:
            self.state = 'jump' if self.vy < 0 else 'fall'
        elif abs(self.vx) > 0.5:
            self.state = 'run'
        else:
            self.state = 'idle'

        # Animation
        self.anim_timer += 1
        if self.state == 'run':
            if self.anim_timer >= 8:
                self.anim_timer = 0
                self.anim_frame = (self.anim_frame + 1) % 4
        else:
            self.anim_frame = 0

    def collide_platform(self, plat):
        # Check if we're intersecting
        if not rect_intersect(self.x, self.y, self.w, self.h, plat.x, plat.y, plat.w, plat.h):
            return False

        if plat.platform_type == 'one_way':
            # Only collide if falling onto it from above
            feet_y = self.y + self.h
            if self.vy > 0 and feet_y - self.vy <= plat.y + 5:
                self.y = plat.y - self.h
                self.vy = 0
                self.on_ground = True
                return True
            return False

        # Solid platform - resolve collision
        overlap_left = (self.x + self.w) - plat.x
        overlap_right = (plat.x + plat.w) - self.x
        overlap_top = (self.y + self.h) - plat.y
        overlap_bottom = (plat.y + plat.h) - self.y

        min_overlap = min(overlap_left, overlap_right, overlap_top, overlap_bottom)

        if min_overlap == overlap_top and self.vy >= 0:
            self.y = plat.y - self.h
            self.vy = 0
            self.on_ground = True
        elif min_overlap == overlap_bottom and self.vy < 0:
            self.y = plat.y + plat.h
            self.vy = 0
        elif min_overlap == overlap_left:
            self.x = plat.x - self.w
        elif min_overlap == overlap_right:
            self.x = plat.x + plat.w

        return True

    def start_attack(self, attack_type):
        self.attack_type = attack_type
        self.attack_timer = 25
        self.attack_cooldown = 35

    def get_attack_hitbox(self):
        if not self.attack_type or self.attack_timer < 15:
            return None
        # Attack hitbox in front of Taylor
        hb_w, hb_h = 50, 30
        hb_x = self.x + self.w if self.facing > 0 else self.x - hb_w
        hb_y = self.y + 5
        return (hb_x, hb_y, hb_w, hb_h)

    def take_damage(self, amount):
        if self.invuln_timer > 0:
            return
        self.hp -= amount
        self.invuln_timer = 60
        if self.hp <= 0:
            self.hp = 0

    def draw(self, ctx, cx, cy):
        sx, sy = self.x - cx, self.y - cy

        # Flash when invulnerable
        if self.invuln_timer > 0 and (self.invuln_timer // 4) % 2 == 0:
            return

        # Taylor in her grey-black costume
        f = self.facing

        # Body
        ctx.fillStyle = '#1a1a1a'
        body_offset = 0
        if self.state == 'run':
            body_offset = [0, -1, 0, -1][self.anim_frame]
        ctx.fillRect(sx + 4, sy + 12 + body_offset, 12, 20)

        # Legs
        ctx.fillStyle = '#151515'
        if self.state == 'run':
            offsets = [(0, 3), (2, -2), (0, 3), (-2, -2)]
            l1, l2 = offsets[self.anim_frame]
            ctx.fillRect(sx + 5, sy + 32 + body_offset, 4, 8 + l1)
            ctx.fillRect(sx + 11, sy + 32 + body_offset, 4, 8 + l2)
        elif self.state in ['jump', 'fall']:
            ctx.fillRect(sx + 4, sy + 32, 5, 6)
            ctx.fillRect(sx + 11, sy + 30, 5, 8)
        else:
            ctx.fillRect(sx + 5, sy + 32, 4, 8)
            ctx.fillRect(sx + 11, sy + 32, 4, 8)

        # Head with mask
        ctx.fillStyle = '#202020'
        ctx.fillRect(sx + 5, sy + 2, 10, 12)

        # Yellow lenses
        ctx.fillStyle = '#c9a227'
        if f > 0:
            ctx.fillRect(sx + 10, sy + 5, 3, 3)
        else:
            ctx.fillRect(sx + 7, sy + 5, 3, 3)

        # Hair (curly, dark)
        ctx.fillStyle = '#0a0a0a'
        ctx.fillRect(sx + 4, sy, 12, 5)
        ctx.fillRect(sx + 3, sy + 2, 2, 6)
        ctx.fillRect(sx + 15, sy + 2, 2, 6)

        # Arm
        ctx.fillStyle = '#1a1a1a'
        arm_y = sy + 14 + body_offset
        if self.state == 'attack':
            # Arm extended
            if f > 0:
                ctx.fillRect(sx + 14, arm_y, 12, 4)
            else:
                ctx.fillRect(sx - 6, arm_y, 12, 4)
        else:
            if f > 0:
                ctx.fillRect(sx + 14, arm_y, 4, 10)
            else:
                ctx.fillRect(sx + 2, arm_y, 4, 10)

        # Attack effect
        if self.attack_type and self.attack_timer > 15:
            hb = self.get_attack_hitbox()
            if hb:
                hx, hy, hw, hh = hb
                hx -= cx
                hy -= cy
                if self.attack_type == 'sting':
                    ctx.fillStyle = 'rgba(200, 180, 50, 0.4)'
                elif self.attack_type == 'bite':
                    ctx.fillStyle = 'rgba(100, 200, 100, 0.4)'
                else:
                    ctx.fillStyle = 'rgba(150, 150, 200, 0.4)'
                ctx.fillRect(hx, hy, hw, hh)

# ============== BUG ==============
class Bug:
    def __init__(self, x, y, bug_type='fly'):
        self.x = x
        self.y = y
        self.bug_type = bug_type
        self.alive = True
        self.following = False
        self.target_x = x
        self.target_y = y
        self.anim_phase = random.uniform(0, math.pi * 2)

        if bug_type == 'fly':
            self.color = '#6a6a4a'
            self.size = 3
            self.speed = 2.5
        elif bug_type == 'spider':
            self.color = '#4a3a2a'
            self.size = 5
            self.speed = 1.5
        elif bug_type == 'wasp':
            self.color = '#8a6a20'
            self.size = 4
            self.speed = 2.0
        elif bug_type == 'beetle':
            self.color = '#2a3a2a'
            self.size = 5
            self.speed = 1.0

    def update(self, taylor):
        # Check if within Taylor's range
        dist = distance(self.x, self.y, taylor.x + taylor.w/2, taylor.y + taylor.h/2)
        if dist < 150:
            self.following = True

        if self.following:
            # Swarm around Taylor
            angle = math.atan2(self.y - taylor.y - taylor.h/2, self.x - taylor.x - taylor.w/2)
            angle += math.sin(self.anim_phase) * 0.5
            self.anim_phase += 0.08

            # Target position in swarm
            swarm_dist = 30 + math.sin(self.anim_phase * 0.7) * 15
            self.target_x = taylor.x + taylor.w/2 + math.cos(self.anim_phase) * swarm_dist
            self.target_y = taylor.y + taylor.h/2 + math.sin(self.anim_phase * 1.3) * swarm_dist * 0.6

            # Move toward target
            dx = self.target_x - self.x
            dy = self.target_y - self.y
            dist = math.sqrt(dx*dx + dy*dy)
            if dist > 2:
                self.x += (dx / dist) * self.speed
                self.y += (dy / dist) * self.speed

    def draw(self, ctx, cx, cy, frame):
        sx, sy = self.x - cx, self.y - cy

        ctx.fillStyle = self.color

        if self.bug_type in ['fly', 'wasp']:
            # Body
            ctx.beginPath()
            ctx.ellipse(sx, sy, self.size, self.size * 0.6, 0, 0, math.pi * 2)
            ctx.fill()
            # Wings
            wing_flap = math.sin(frame * 0.5 + self.anim_phase) * 0.4
            ctx.fillStyle = 'rgba(100, 100, 100, 0.3)'
            ctx.beginPath()
            ctx.ellipse(sx - 2, sy - 2, 3, 1.5, wing_flap, 0, math.pi * 2)
            ctx.fill()
            ctx.beginPath()
            ctx.ellipse(sx + 2, sy - 2, 3, 1.5, -wing_flap, 0, math.pi * 2)
            ctx.fill()
        elif self.bug_type == 'spider':
            ctx.beginPath()
            ctx.arc(sx, sy, self.size, 0, math.pi * 2)
            ctx.fill()
            # Legs
            ctx.strokeStyle = self.color
            ctx.lineWidth = 0.8
            for i in range(4):
                angle = i * 0.4 - 0.6 + math.sin(frame * 0.05 + i) * 0.1
                ctx.beginPath()
                ctx.moveTo(sx, sy)
                ctx.lineTo(sx - math.cos(angle) * 7, sy + math.sin(angle) * 5)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(sx, sy)
                ctx.lineTo(sx + math.cos(angle) * 7, sy + math.sin(angle) * 5)
                ctx.stroke()
        else:
            ctx.beginPath()
            ctx.ellipse(sx, sy, self.size, self.size * 0.7, 0, 0, math.pi * 2)
            ctx.fill()

# ============== ENEMY ==============
class Enemy:
    def __init__(self, x, y, enemy_type='thug'):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.w = 24
        self.h = 44

        self.enemy_type = enemy_type
        self.alive = True
        self.facing = -1

        if enemy_type == 'thug':
            self.hp = 40
            self.max_hp = 40
            self.damage = 10
            self.color = '#5a3535'
        else:  # abb
            self.hp = 60
            self.max_hp = 60
            self.damage = 15
            self.color = '#6a3030'

        self.patrol_left = x - 80
        self.patrol_right = x + 80
        self.state = 'patrol'
        self.attack_cooldown = 0
        self.stun_timer = 0

        self.effects = {}

    def add_effect(self, name, duration):
        self.effects[name] = duration

    def take_damage(self, amount, effect=None):
        self.hp -= amount
        self.stun_timer = 15
        if effect:
            if effect == 'sting':
                pass  # Just damage
            elif effect == 'bite':
                self.add_effect('venom', 180)
            elif effect == 'blind':
                self.add_effect('blind', 180)
        if self.hp <= 0:
            self.alive = False

    def update(self, taylor, platforms):
        if not self.alive:
            return

        # Update effects
        for name in list(self.effects.keys()):
            self.effects[name] -= 1
            if name == 'venom':
                self.hp -= 0.1
                if self.hp <= 0:
                    self.alive = False
            if self.effects[name] <= 0:
                del self.effects[name]

        if self.stun_timer > 0:
            self.stun_timer -= 1
            self.vy += GRAVITY
            self.y += self.vy
            self.check_ground(platforms)
            return

        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1

        # AI
        dist_to_taylor = distance(self.x, self.y, taylor.x, taylor.y)
        can_see = 'blind' not in self.effects

        speed = 1.5 if can_see else 0.5

        if can_see and dist_to_taylor < 200:
            self.state = 'chase'
            if taylor.x < self.x:
                self.vx = -speed
                self.facing = -1
            else:
                self.vx = speed
                self.facing = 1

            # Attack if close
            if dist_to_taylor < 35 and self.attack_cooldown <= 0:
                taylor.take_damage(self.damage)
                self.attack_cooldown = 90
        else:
            self.state = 'patrol'
            if self.x <= self.patrol_left:
                self.facing = 1
            elif self.x >= self.patrol_right:
                self.facing = -1
            self.vx = self.facing * speed * 0.5

        # Physics
        self.vy += GRAVITY
        self.x += self.vx
        self.y += self.vy

        self.check_ground(platforms)
        self.x = clamp(self.x, 0, WORLD_WIDTH - self.w)

    def check_ground(self, platforms):
        # Ground
        if self.y + self.h >= WORLD_HEIGHT - 50:
            self.y = WORLD_HEIGHT - 50 - self.h
            self.vy = 0

        for plat in platforms:
            if plat.platform_type == 'solid':
                if rect_intersect(self.x, self.y, self.w, self.h, plat.x, plat.y, plat.w, plat.h):
                    if self.vy > 0:
                        self.y = plat.y - self.h
                        self.vy = 0

    def draw(self, ctx, cx, cy):
        sx, sy = self.x - cx, self.y - cy

        color = self.color
        if 'venom' in self.effects:
            color = '#4a5a4a'
        if 'blind' in self.effects:
            color = '#4a4a5a'

        # Body
        ctx.fillStyle = color
        ctx.fillRect(sx + 4, sy + 14, 16, 22)

        # Head
        ctx.beginPath()
        ctx.arc(sx + 12, sy + 10, 8, 0, math.pi * 2)
        ctx.fill()

        # Legs
        ctx.fillRect(sx + 6, sy + 36, 5, 8)
        ctx.fillRect(sx + 13, sy + 36, 5, 8)

        # HP bar
        ctx.fillStyle = '#1a1a1a'
        ctx.fillRect(sx, sy - 8, self.w, 4)
        ctx.fillStyle = '#5a4a4a'
        ctx.fillRect(sx, sy - 8, self.w * (self.hp / self.max_hp), 4)

# ============== LUNG ==============
class Lung:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.w = 40
        self.h = 60

        self.hp = 300
        self.max_hp = 300
        self.damage = 20
        self.alive = True
        self.facing = -1

        self.stage = 1
        self.stage_timer = 0
        self.engaged = False

        self.attack_cooldown = 0
        self.state = 'idle'
        self.effects = {}

    def add_effect(self, name, duration):
        # Lung resists effects
        duration = int(duration * (1 - (self.stage - 1) * 0.15))
        if duration > 0:
            self.effects[name] = duration

    def take_damage(self, amount, effect=None):
        # Damage reduction at higher stages
        reduction = 1 - (self.stage - 1) * 0.1
        self.hp -= amount * reduction
        self.engaged = True
        if effect:
            if effect == 'bite':
                self.add_effect('venom', 180)
            elif effect == 'blind':
                self.add_effect('blind', 120)
        if self.hp <= 0:
            self.alive = False

    def update(self, taylor, platforms):
        if not self.alive:
            return

        # Stage up when engaged
        if self.engaged:
            self.stage_timer += 1
            if self.stage_timer >= 900 and self.stage < 5:  # 15 seconds
                self.stage += 1
                self.stage_timer = 0
                self.max_hp += 30
                self.hp = min(self.hp + 50, self.max_hp)

        # Update effects
        for name in list(self.effects.keys()):
            self.effects[name] -= 1
            if name == 'venom':
                self.hp -= 0.15 * (1 - (self.stage - 1) * 0.1)
            if self.effects[name] <= 0:
                del self.effects[name]

        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1

        # AI - always chase when engaged
        speed = 1.2 + self.stage * 0.3
        if 'blind' in self.effects:
            speed *= 0.5

        dist = distance(self.x, self.y, taylor.x, taylor.y)

        if dist < 400 or self.engaged:
            self.engaged = True
            self.state = 'chase'

            if taylor.x < self.x:
                self.vx = -speed
                self.facing = -1
            else:
                self.vx = speed
                self.facing = 1

            # Attack
            attack_range = 50 + self.stage * 10
            if dist < attack_range and self.attack_cooldown <= 0:
                taylor.take_damage(self.damage + self.stage * 5)
                self.attack_cooldown = max(60, 90 - self.stage * 5)
        else:
            self.state = 'idle'
            self.vx = 0

        # Physics
        self.vy += GRAVITY
        self.x += self.vx
        self.y += self.vy

        # Ground
        if self.y + self.h >= WORLD_HEIGHT - 50:
            self.y = WORLD_HEIGHT - 50 - self.h
            self.vy = 0

        self.x = clamp(self.x, 0, WORLD_WIDTH - self.w)

    def draw(self, ctx, cx, cy, frame):
        sx, sy = self.x - cx, self.y - cy

        # Scale size with stage
        scale = 1 + (self.stage - 1) * 0.15
        w = int(self.w * scale)
        h = int(self.h * scale)

        # Color shifts with stage
        colors = ['#704020', '#804030', '#904035', '#a54530', '#c05525']
        color = colors[self.stage - 1]

        # Fire aura at high stages
        if self.stage >= 3:
            ctx.fillStyle = f'rgba(255, {100 - self.stage * 15}, 0, {0.15 + math.sin(frame * 0.15) * 0.05})'
            ctx.beginPath()
            ctx.arc(sx + w//2, sy + h//2, w//2 + 15 + self.stage * 5, 0, math.pi * 2)
            ctx.fill()

        # Body
        ctx.fillStyle = color
        ctx.fillRect(sx, sy + 15, w, h - 25)

        # Head
        head_size = 12 + self.stage * 2
        ctx.beginPath()
        ctx.arc(sx + w//2, sy + head_size, head_size, 0, math.pi * 2)
        ctx.fill()

        # Legs
        ctx.fillRect(sx + 5, sy + h - 12, w//3, 12)
        ctx.fillRect(sx + w - w//3 - 5, sy + h - 12, w//3, 12)

        # Scales at high stages
        if self.stage >= 4:
            ctx.fillStyle = '#2a2020'
            for i in range(self.stage - 3):
                ctx.fillRect(sx + 5, sy + 25 + i * 10, w - 10, 3)

        # Effect indicators
        if 'blind' in self.effects:
            ctx.fillStyle = '#ffff00'
            ctx.font = '14px monospace'
            ctx.fillText('*', sx + w//2 - 4, sy + 5)

# ============== GAME ==============
class Game:
    def __init__(self):
        self.canvas = document.getElementById('game-canvas')
        self.ctx = self.canvas.getContext('2d')

        self.taylor = Taylor(150, WORLD_HEIGHT - 150)
        self.platforms = []
        self.bugs = []
        self.enemies = []
        self.lung = None

        self.camera_x = 0
        self.camera_y = 0

        self.frame = 0
        self.game_over = False
        self.victory = False

        self.create_level()
        self.spawn_bugs()
        self.spawn_enemies()

    def create_level(self):
        # Ground
        self.platforms.append(Platform(0, WORLD_HEIGHT - 50, WORLD_WIDTH, 50, 'solid'))

        # Warehouse platforms - multiple levels
        # Area 1: Starting area
        self.platforms.append(Platform(100, WORLD_HEIGHT - 150, 200, 20, 'solid'))
        self.platforms.append(Platform(50, WORLD_HEIGHT - 250, 150, 15, 'one_way'))
        self.platforms.append(Platform(250, WORLD_HEIGHT - 300, 180, 20, 'solid'))

        # Area 2: Mid section
        self.platforms.append(Platform(500, WORLD_HEIGHT - 180, 250, 25, 'solid'))
        self.platforms.append(Platform(600, WORLD_HEIGHT - 320, 200, 15, 'one_way'))
        self.platforms.append(Platform(450, WORLD_HEIGHT - 450, 180, 20, 'solid'))
        self.platforms.append(Platform(700, WORLD_HEIGHT - 500, 150, 15, 'one_way'))

        # Area 3: Vertical section
        self.platforms.append(Platform(900, WORLD_HEIGHT - 150, 200, 20, 'solid'))
        self.platforms.append(Platform(950, WORLD_HEIGHT - 280, 150, 20, 'solid'))
        self.platforms.append(Platform(850, WORLD_HEIGHT - 400, 200, 15, 'one_way'))
        self.platforms.append(Platform(1000, WORLD_HEIGHT - 520, 180, 20, 'solid'))

        # Area 4: Upper platforms
        self.platforms.append(Platform(1200, WORLD_HEIGHT - 200, 250, 25, 'solid'))
        self.platforms.append(Platform(1300, WORLD_HEIGHT - 350, 200, 15, 'one_way'))
        self.platforms.append(Platform(1150, WORLD_HEIGHT - 480, 220, 20, 'solid'))

        # Area 5: Lung's arena
        self.platforms.append(Platform(1550, WORLD_HEIGHT - 150, 350, 30, 'solid'))
        self.platforms.append(Platform(1600, WORLD_HEIGHT - 300, 250, 20, 'solid'))
        self.platforms.append(Platform(1700, WORLD_HEIGHT - 450, 200, 15, 'one_way'))
        self.platforms.append(Platform(1500, WORLD_HEIGHT - 550, 300, 20, 'solid'))

        # Final area
        self.platforms.append(Platform(2000, WORLD_HEIGHT - 180, 300, 25, 'solid'))
        self.platforms.append(Platform(2100, WORLD_HEIGHT - 350, 200, 20, 'solid'))

    def spawn_bugs(self):
        # Bugs scattered throughout
        bug_types = ['fly', 'fly', 'spider', 'wasp', 'beetle', 'fly']

        # Near start
        for i in range(20):
            x = random.uniform(50, 400)
            y = random.uniform(WORLD_HEIGHT - 400, WORLD_HEIGHT - 100)
            self.bugs.append(Bug(x, y, random.choice(bug_types)))

        # Mid area
        for i in range(25):
            x = random.uniform(450, 900)
            y = random.uniform(WORLD_HEIGHT - 550, WORLD_HEIGHT - 100)
            self.bugs.append(Bug(x, y, random.choice(bug_types)))

        # Near Lung
        for i in range(30):
            x = random.uniform(1400, 2200)
            y = random.uniform(WORLD_HEIGHT - 600, WORLD_HEIGHT - 100)
            self.bugs.append(Bug(x, y, random.choice(bug_types)))

    def spawn_enemies(self):
        # ABB thugs patrolling
        positions = [
            (400, WORLD_HEIGHT - 100, 'thug'),
            (650, WORLD_HEIGHT - 230, 'abb'),
            (550, WORLD_HEIGHT - 500, 'thug'),
            (950, WORLD_HEIGHT - 200, 'abb'),
            (1100, WORLD_HEIGHT - 330, 'thug'),
            (1250, WORLD_HEIGHT - 250, 'abb'),
            (1400, WORLD_HEIGHT - 200, 'thug'),
        ]

        for x, y, etype in positions:
            self.enemies.append(Enemy(x, y, etype))

        # Lung at the back
        self.lung = Lung(1800, WORLD_HEIGHT - 150)

    def update(self):
        if self.game_over:
            return

        self.frame += 1

        # Get input
        keys = {k: True for k in window.keysHeld.object_keys() if window.keysHeld[k]}
        key_pressed = {k: True for k in list(window.keysJustPressed)}
        window.keysJustPressed.splice(0, len(window.keysJustPressed))

        # Update Taylor
        self.taylor.update(keys, key_pressed, self.platforms)

        # Update bugs
        for bug in self.bugs:
            bug.update(self.taylor)

        # Update enemies
        for enemy in self.enemies:
            enemy.update(self.taylor, self.platforms)

        # Update Lung
        if self.lung and self.lung.alive:
            self.lung.update(self.taylor, self.platforms)

        # Check Taylor's attacks hitting enemies
        hitbox = self.taylor.get_attack_hitbox()
        if hitbox:
            hx, hy, hw, hh = hitbox
            for enemy in self.enemies:
                if enemy.alive and rect_intersect(hx, hy, hw, hh, enemy.x, enemy.y, enemy.w, enemy.h):
                    dmg = 15 if self.taylor.attack_type == 'sting' else 8
                    enemy.take_damage(dmg, self.taylor.attack_type)

            if self.lung and self.lung.alive:
                if rect_intersect(hx, hy, hw, hh, self.lung.x, self.lung.y, self.lung.w, self.lung.h):
                    dmg = 20 if self.taylor.attack_type == 'sting' else 10
                    self.lung.take_damage(dmg, self.taylor.attack_type)

        # Clean up dead enemies
        self.enemies = [e for e in self.enemies if e.alive]

        # Camera
        target_x = self.taylor.x - CANVAS_WIDTH // 2 + self.taylor.w // 2
        target_y = self.taylor.y - CANVAS_HEIGHT // 2 + self.taylor.h // 2
        self.camera_x = lerp(self.camera_x, target_x, 0.08)
        self.camera_y = lerp(self.camera_y, target_y, 0.08)
        self.camera_x = clamp(self.camera_x, 0, WORLD_WIDTH - CANVAS_WIDTH)
        self.camera_y = clamp(self.camera_y, 0, WORLD_HEIGHT - CANVAS_HEIGHT)

        # UI
        window.uiState.taylorHp = (self.taylor.hp / self.taylor.max_hp) * 100
        if self.lung and self.lung.engaged:
            window.uiState.bossVisible = True
            window.uiState.bossHp = (self.lung.hp / self.lung.max_hp) * 100
        swarm = len([b for b in self.bugs if b.following])
        window.uiState.swarmCount = swarm

        # Win/lose
        if self.taylor.hp <= 0:
            self.game_over = True
        if self.lung and not self.lung.alive:
            self.victory = True
            self.game_over = True

    def render(self):
        ctx = self.ctx
        cx, cy = self.camera_x, self.camera_y

        # Background gradient (night sky)
        gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT)
        gradient.addColorStop(0, '#050508')
        gradient.addColorStop(1, '#0a0a12')
        ctx.fillStyle = gradient
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

        # Background buildings (parallax)
        self.draw_background(ctx, cx, cy)

        # Platforms
        for plat in self.platforms:
            plat.draw(ctx, cx, cy)

        # Bugs
        for bug in self.bugs:
            bug.draw(ctx, cx, cy, self.frame)

        # Enemies
        for enemy in self.enemies:
            if enemy.alive:
                enemy.draw(ctx, cx, cy)

        # Lung
        if self.lung and self.lung.alive:
            self.lung.draw(ctx, cx, cy, self.frame)

        # Taylor
        self.taylor.draw(ctx, cx, cy)

        # Game over screen
        if self.game_over:
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

            if self.victory:
                ctx.fillStyle = '#6a8a6a'
                ctx.font = '32px monospace'
                ctx.fillText('LUNG DEFEATED', CANVAS_WIDTH//2 - 120, CANVAS_HEIGHT//2 - 20)
                ctx.fillStyle = '#888'
                ctx.font = '14px monospace'
                ctx.fillText('The Undersiders arrive... Taylor escapes into the night.', CANVAS_WIDTH//2 - 200, CANVAS_HEIGHT//2 + 30)
            else:
                ctx.fillStyle = '#8a5050'
                ctx.font = '32px monospace'
                ctx.fillText('DEFEATED', CANVAS_WIDTH//2 - 70, CANVAS_HEIGHT//2)

    def draw_background(self, ctx, cx, cy):
        # Parallax city silhouette
        parallax = 0.3
        bx = -cx * parallax

        ctx.fillStyle = '#08080c'

        # Distant buildings
        buildings = [
            (100, 200), (180, 280), (300, 220), (400, 300),
            (550, 250), (700, 320), (850, 240), (1000, 290),
            (1150, 260), (1300, 310), (1450, 230), (1600, 280),
        ]

        for bldg_x, height in buildings:
            x = bldg_x + bx
            y = CANVAS_HEIGHT - height
            w = 60
            ctx.fillRect(x, y, w, height)
            # Windows
            ctx.fillStyle = 'rgba(40, 35, 25, 0.4)'
            for wy in range(int(y + 20), int(CANVAS_HEIGHT - 20), 25):
                for wx in range(int(x + 8), int(x + w - 8), 15):
                    if random.random() > 0.7:
                        ctx.fillRect(wx, wy, 6, 8)
            ctx.fillStyle = '#08080c'

        # Moon
        ctx.fillStyle = '#1a1a25'
        ctx.beginPath()
        ctx.arc(700 - cx * 0.1, 80, 30, 0, math.pi * 2)
        ctx.fill()

    def game_loop(self, timestamp):
        self.update()
        self.render()
        requestAnimationFrame(create_proxy(self.game_loop))

# Start
game = Game()
requestAnimationFrame(create_proxy(game.game_loop))
`;

        main();
    </script>
</body>
</html>
