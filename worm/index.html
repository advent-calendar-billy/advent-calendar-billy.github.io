<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worm: First Steps</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --sky-top: #87CEEB;
            --sky-bottom: #E8F4F8;
            --sun-glow: #FFF8E7;
            --warm-cream: #FDF6E3;
            --terracotta: #C4A484;
            --sage: #9CAF88;
            --deep-green: #2D4A3E;
            --taylor-costume: #2A2D2E;
            --silk-white: #FAFBFC;
            --silk-shimmer: rgba(255, 255, 255, 0.9);
            --ui-bg: rgba(255, 255, 255, 0.92);
            --ui-shadow: rgba(0, 0, 0, 0.08);
            --text-dark: #2C3E50;
            --text-muted: #7F8C8D;
            --accent-gold: #E6A23C;
            --accent-soft: #A8D8EA;
            --success: #7CB342;
            --wasp-yellow: #F4D03F;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: linear-gradient(180deg, var(--sky-top) 0%, var(--sky-bottom) 60%, var(--warm-cream) 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: var(--text-dark);
            overflow-x: hidden;
        }

        header {
            text-align: center;
            margin-bottom: 16px;
        }

        h1 {
            font-family: 'Crimson Pro', serif;
            font-size: 2.2rem;
            font-weight: 600;
            color: var(--deep-green);
            letter-spacing: 0.02em;
            text-shadow: 0 2px 8px rgba(255, 255, 255, 0.6);
        }

        .subtitle {
            font-family: 'Crimson Pro', serif;
            font-style: italic;
            color: var(--text-muted);
            font-size: 1rem;
            margin-top: 4px;
        }

        #game-wrapper {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow:
                0 4px 24px rgba(0, 0, 0, 0.1),
                0 1px 3px rgba(0, 0, 0, 0.05),
                inset 0 0 0 1px rgba(255, 255, 255, 0.5);
        }

        #game-canvas {
            display: block;
            background: var(--sky-bottom);
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .ui-panel {
            background: var(--ui-bg);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            box-shadow:
                0 4px 16px var(--ui-shadow),
                0 1px 3px rgba(0, 0, 0, 0.04);
            pointer-events: auto;
        }

        /* Mission Panel */
        #mission-panel {
            position: absolute;
            top: 16px;
            left: 16px;
            padding: 16px 20px;
            max-width: 280px;
            border-left: 3px solid var(--accent-gold);
        }

        #mission-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-gold);
            font-weight: 600;
            margin-bottom: 6px;
        }

        #mission-text {
            font-family: 'Crimson Pro', serif;
            font-size: 1.05rem;
            line-height: 1.4;
            color: var(--text-dark);
        }

        #mission-hint {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.06);
        }

        /* Powers Panel */
        #powers-panel {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 10px 14px;
        }

        .power-btn {
            width: 56px;
            height: 56px;
            border-radius: 10px;
            border: 2px solid transparent;
            background: linear-gradient(145deg, #fff 0%, #f5f5f5 100%);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
        }

        .power-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .power-btn.active {
            border-color: var(--accent-gold);
            background: linear-gradient(145deg, #FFF8E7 0%, #FDF6E3 100%);
        }

        .power-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .power-icon {
            font-size: 1.4rem;
            margin-bottom: 2px;
        }

        .power-key {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-weight: 600;
        }

        /* Swarm indicator */
        #swarm-panel {
            position: absolute;
            top: 16px;
            right: 16px;
            padding: 12px 16px;
            text-align: center;
        }

        #swarm-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        #swarm-count {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--deep-green);
        }

        #swarm-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.06);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        #swarm-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--sage) 0%, var(--deep-green) 100%);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Controls hint */
        #controls-hint {
            position: absolute;
            bottom: 16px;
            right: 16px;
            padding: 10px 14px;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        #controls-hint kbd {
            display: inline-block;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.04);
            border-radius: 4px;
            font-family: inherit;
            font-weight: 500;
            margin: 0 2px;
        }

        /* Success overlay */
        #success-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            padding: 32px 48px;
            text-align: center;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
        }

        #success-overlay.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        #success-overlay h2 {
            font-family: 'Crimson Pro', serif;
            font-size: 1.6rem;
            color: var(--success);
            margin-bottom: 8px;
        }

        #success-overlay p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Silk aiming indicator */
        #silk-aim {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid var(--silk-shimmer);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        #silk-aim.active {
            opacity: 1;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <header>
        <h1>Worm: First Steps</h1>
        <p class="subtitle">Brockton Bay ‚Äî A quiet afternoon</p>
    </header>

    <div id="game-wrapper">
        <canvas id="game-canvas" width="960" height="540"></canvas>

        <div id="ui-layer">
            <div id="mission-panel" class="ui-panel">
                <div id="mission-label">Current Task</div>
                <div id="mission-text">Walk through the neighborhood and get familiar with your powers.</div>
                <div id="mission-hint">Use A/D to move, Space to jump</div>
            </div>

            <div id="swarm-panel" class="ui-panel">
                <div id="swarm-label">Swarm</div>
                <div id="swarm-count">0</div>
                <div id="swarm-bar">
                    <div id="swarm-fill" style="width: 0%"></div>
                </div>
            </div>

            <div id="powers-panel" class="ui-panel">
                <button class="power-btn" data-power="silk" title="Spider Silk">
                    <span class="power-icon">üï∏Ô∏è</span>
                    <span class="power-key">Q</span>
                </button>
                <button class="power-btn" data-power="wasps" title="Send Wasps">
                    <span class="power-icon">üêù</span>
                    <span class="power-key">W</span>
                </button>
                <button class="power-btn" data-power="scout" title="Bug Scout">
                    <span class="power-icon">üëÅÔ∏è</span>
                    <span class="power-key">E</span>
                </button>
            </div>

            <div id="controls-hint" class="ui-panel">
                <kbd>A</kbd><kbd>D</kbd> Move
                <kbd>Space</kbd> Jump
                <kbd>Click</kbd> Aim power
            </div>

            <div id="success-overlay" class="ui-panel">
                <h2>Task Complete!</h2>
                <p>Moving to next area...</p>
            </div>
        </div>
    </div>

    <script>
// ============== GAME ENGINE ==============
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const CANVAS_WIDTH = canvas.width;
const CANVAS_HEIGHT = canvas.height;

// World dimensions
const WORLD_WIDTH = 3200;
const WORLD_HEIGHT = 540;
const GROUND_Y = WORLD_HEIGHT - 80;

// Physics
const GRAVITY = 0.4;
const FRICTION = 0.92;

// Input state
const keys = {};
const keysJustPressed = new Set();
let mouseX = 0, mouseY = 0;
let mouseDown = false;
let mouseClicked = false;

// Game state
let camera = { x: 0, y: 0 };
let frame = 0;
let currentPower = null;
let missionIndex = 0;
let missionComplete = false;

// ============== MISSIONS ==============
const missions = [
    {
        text: "Walk through the neighborhood and gather some insects.",
        hint: "Move with A/D, bugs will join your swarm automatically",
        check: (game) => game.swarmCount >= 15,
        area: { x: 0, w: 800 }
    },
    {
        text: "Two kids are fighting near the park. Send some wasps to distract them.",
        hint: "Press W to select wasps, then click near the kids",
        check: (game) => game.kidsCalmed,
        area: { x: 600, w: 600 }
    },
    {
        text: "A cat is stuck in that tree! Use spider silk to create a path down.",
        hint: "Press Q to select silk, click to anchor points",
        check: (game) => game.catSaved,
        area: { x: 1100, w: 700 }
    },
    {
        text: "Excellent work, Taylor. You're learning fast.",
        hint: "Continue exploring...",
        check: () => false,
        area: { x: 1700, w: 800 }
    }
];

// ============== COLOR UTILITIES ==============
function rgb(r, g, b, a = 1) {
    return `rgba(${r}, ${g}, ${b}, ${a})`;
}

function gradient(ctx, x1, y1, x2, y2, stops) {
    const g = ctx.createLinearGradient(x1, y1, x2, y2);
    stops.forEach(([pos, color]) => g.addColorStop(pos, color));
    return g;
}

function lerp(a, b, t) {
    return a + (b - a) * t;
}

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
}

function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

// ============== VERLET ROPE (SILK) ==============
class SilkRope {
    constructor(x1, y1, x2, y2, segments = 12) {
        this.points = [];
        this.stiffness = 0.8;
        this.gravity = 0.15;
        this.anchored = [true, true]; // Both ends anchored initially

        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            this.points.push({
                x: lerp(x1, y1, t) + (Math.random() - 0.5) * 2,
                y: lerp(x2, y2, t),
                oldX: lerp(x1, y1, t),
                oldY: lerp(x2, y2, t),
                pinned: i === 0 || i === segments
            });
        }
        // Fix initial positions
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            this.points[i].x = lerp(x1, x2, t);
            this.points[i].y = lerp(y1, y2, t);
            this.points[i].oldX = this.points[i].x;
            this.points[i].oldY = this.points[i].y;
        }

        this.restLength = dist(x1, y1, x2, y2) / segments;
        this.shimmerPhase = Math.random() * Math.PI * 2;
    }

    update() {
        // Verlet integration
        for (let i = 0; i < this.points.length; i++) {
            const p = this.points[i];
            if (p.pinned) continue;

            const vx = (p.x - p.oldX) * FRICTION;
            const vy = (p.y - p.oldY) * FRICTION;

            p.oldX = p.x;
            p.oldY = p.y;
            p.x += vx;
            p.y += vy + this.gravity;
        }

        // Constraints (multiple iterations for stability)
        for (let iter = 0; iter < 5; iter++) {
            for (let i = 0; i < this.points.length - 1; i++) {
                const p1 = this.points[i];
                const p2 = this.points[i + 1];

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                const diff = (this.restLength - d) / d * this.stiffness;

                const offsetX = dx * diff * 0.5;
                const offsetY = dy * diff * 0.5;

                if (!p1.pinned) {
                    p1.x -= offsetX;
                    p1.y -= offsetY;
                }
                if (!p2.pinned) {
                    p2.x += offsetX;
                    p2.y += offsetY;
                }
            }
        }
    }

    draw(ctx, cx, cy) {
        this.shimmerPhase += 0.05;

        // Draw silk strand
        ctx.beginPath();
        ctx.moveTo(this.points[0].x - cx, this.points[0].y - cy);

        for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x - cx, this.points[i].y - cy);
        }

        // Main strand
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Shimmer effect
        const shimmer = Math.sin(this.shimmerPhase) * 0.3 + 0.7;
        ctx.strokeStyle = `rgba(255, 255, 255, ${shimmer * 0.5})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        // Anchor points
        for (let i = 0; i < this.points.length; i++) {
            if (this.points[i].pinned) {
                const p = this.points[i];
                ctx.beginPath();
                ctx.arc(p.x - cx, p.y - cy, 4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
    }

    checkCollision(x, y, radius = 10) {
        for (const p of this.points) {
            if (dist(x, y, p.x, p.y) < radius) return true;
        }
        return false;
    }
}

// ============== TAYLOR ==============
class Taylor {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.w = 24;
        this.h = 48;
        this.onGround = false;
        this.facing = 1;
        this.walkFrame = 0;
        this.walkTimer = 0;
    }

    update(structures) {
        // Movement
        let moveX = 0;
        if (keys['KeyA'] || keys['ArrowLeft']) { moveX = -1; this.facing = -1; }
        if (keys['KeyD'] || keys['ArrowRight']) { moveX = 1; this.facing = 1; }

        this.vx = moveX * 3.5;

        // Jump
        if ((keysJustPressed.has('Space') || keysJustPressed.has('KeyW')) && this.onGround) {
            this.vy = -9;
            this.onGround = false;
        }

        // Gravity
        this.vy += GRAVITY;
        this.vy = Math.min(this.vy, 12);

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Ground collision
        this.onGround = false;
        if (this.y + this.h >= GROUND_Y) {
            this.y = GROUND_Y - this.h;
            this.vy = 0;
            this.onGround = true;
        }

        // Structure collision
        for (const s of structures) {
            if (this.x < s.x + s.w && this.x + this.w > s.x &&
                this.y < s.y + s.h && this.y + this.h > s.y) {

                // Top collision
                if (this.vy > 0 && this.y + this.h - this.vy <= s.y + 5) {
                    this.y = s.y - this.h;
                    this.vy = 0;
                    this.onGround = true;
                }
            }
        }

        // World bounds
        this.x = clamp(this.x, 0, WORLD_WIDTH - this.w);

        // Animation
        if (Math.abs(this.vx) > 0.5 && this.onGround) {
            this.walkTimer++;
            if (this.walkTimer >= 8) {
                this.walkTimer = 0;
                this.walkFrame = (this.walkFrame + 1) % 4;
            }
        } else {
            this.walkFrame = 0;
        }
    }

    draw(ctx, cx, cy) {
        const sx = this.x - cx;
        const sy = this.y - cy;
        const f = this.facing;

        const bodyBob = this.onGround && Math.abs(this.vx) > 0.5 ?
            [0, -2, 0, -2][this.walkFrame] : 0;

        // Shadow
        ctx.beginPath();
        ctx.ellipse(sx + this.w/2, GROUND_Y - cy, 16, 5, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fill();

        // Legs
        ctx.fillStyle = '#1a1a1a';
        if (this.onGround && Math.abs(this.vx) > 0.5) {
            const legOffsets = [[0, 4], [3, -2], [0, 4], [-3, -2]];
            const [l1, l2] = legOffsets[this.walkFrame];
            this.drawLeg(ctx, sx + 7, sy + 30 + bodyBob, 4, 18 + l1);
            this.drawLeg(ctx, sx + 13, sy + 30 + bodyBob, 4, 18 + l2);
        } else {
            this.drawLeg(ctx, sx + 7, sy + 30, 4, 18);
            this.drawLeg(ctx, sx + 13, sy + 30, 4, 18);
        }

        // Body
        ctx.fillStyle = '#2a2d2e';
        this.roundRect(ctx, sx + 4, sy + 12 + bodyBob, 16, 20, 3);
        ctx.fill();

        // Head
        ctx.fillStyle = '#2d3030';
        ctx.beginPath();
        ctx.ellipse(sx + 12, sy + 8 + bodyBob, 9, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // Yellow lenses
        ctx.fillStyle = '#d4b030';
        const lensX = f > 0 ? sx + 14 : sx + 6;
        ctx.beginPath();
        ctx.ellipse(lensX, sy + 7 + bodyBob, 3, 2.5, f * 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = '#1a1512';
        ctx.beginPath();
        ctx.moveTo(sx + 3, sy + 8 + bodyBob);
        ctx.quadraticCurveTo(sx + 12, sy - 4 + bodyBob, sx + 21, sy + 8 + bodyBob);
        ctx.quadraticCurveTo(sx + 18, sy + 2 + bodyBob, sx + 12, sy + 1 + bodyBob);
        ctx.quadraticCurveTo(sx + 6, sy + 2 + bodyBob, sx + 3, sy + 8 + bodyBob);
        ctx.fill();

        // Control range indicator (subtle)
        ctx.beginPath();
        ctx.arc(sx + this.w/2, sy + this.h/2, 120, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(159, 168, 136, 0.15)';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 8]);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    drawLeg(ctx, x, y, w, h) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + w, y);
        ctx.lineTo(x + w + 1, y + h);
        ctx.lineTo(x - 1, y + h);
        ctx.closePath();
        ctx.fill();
    }

    roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }
}

// ============== BUG ==============
class Bug {
    constructor(x, y, type = 'fly') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.following = false;
        this.phase = Math.random() * Math.PI * 2;
        this.targetX = x;
        this.targetY = y;

        this.speed = type === 'spider' ? 1.5 : type === 'wasp' ? 2.5 : 2.2;
        this.size = type === 'spider' ? 5 : type === 'wasp' ? 4 : 3;
    }

    update(taylor) {
        const tcx = taylor.x + taylor.w/2;
        const tcy = taylor.y + taylor.h/2;
        const d = dist(this.x, this.y, tcx, tcy);

        if (d < 120 && !this.following) {
            this.following = true;
        }

        if (d > 180 && this.following) {
            this.following = false;
        }

        if (this.following) {
            this.phase += 0.04;
            const orbitDist = 25 + Math.sin(this.phase * 0.8) * 12;
            this.targetX = tcx + Math.cos(this.phase) * orbitDist;
            this.targetY = tcy + Math.sin(this.phase * 1.2) * orbitDist * 0.5 - 10;

            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const td = Math.sqrt(dx*dx + dy*dy);

            if (td > 2) {
                const urgency = Math.min(1.3, td / 50);
                this.x += (dx / td) * this.speed * urgency;
                this.y += (dy / td) * this.speed * urgency;
            }
        }

        // Ground bugs
        if (this.type === 'spider') {
            if (this.y < GROUND_Y - 5) this.y += 1.5;
            if (this.y > GROUND_Y) this.y = GROUND_Y;
        }
    }

    draw(ctx, cx, cy, frame) {
        const sx = this.x - cx;
        const sy = this.y - cy;

        if (this.type === 'wasp') {
            // Body
            ctx.fillStyle = this.following ? '#f4d03f' : '#a0a080';
            ctx.beginPath();
            ctx.ellipse(sx, sy, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Stripes
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(sx - 2, sy - 1, 1.5, 2);
            ctx.fillRect(sx + 1, sy - 1, 1.5, 2);

            // Wings
            const wingFlap = Math.sin(frame * 0.6 + this.phase) * 0.5;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.ellipse(sx - 2, sy - 3, 3, 2, wingFlap, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(sx + 2, sy - 3, 3, 2, -wingFlap, 0, Math.PI * 2);
            ctx.fill();

        } else if (this.type === 'spider') {
            ctx.fillStyle = this.following ? '#5a4a3a' : '#4a4a4a';
            ctx.beginPath();
            ctx.arc(sx, sy, this.size, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = ctx.fillStyle;
            ctx.lineWidth = 0.8;
            for (let i = 0; i < 4; i++) {
                const angle = i * 0.4 - 0.6 + Math.sin(frame * 0.04 + i) * 0.1;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx - Math.cos(angle) * 7, sy + Math.sin(angle) * 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx + Math.cos(angle) * 7, sy + Math.sin(angle) * 5);
                ctx.stroke();
            }

        } else {
            // Fly
            ctx.fillStyle = this.following ? '#6a7a5a' : '#5a5a5a';
            ctx.beginPath();
            ctx.ellipse(sx, sy, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wings
            const wingFlap = Math.sin(frame * 0.5 + this.phase) * 0.4;
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.beginPath();
            ctx.ellipse(sx - 2, sy - 2, 2.5, 1.5, wingFlap, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(sx + 2, sy - 2, 2.5, 1.5, -wingFlap, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// ============== INTERACTABLE OBJECTS ==============
class FightingKids {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.calmed = false;
        this.waspCount = 0;
        this.animPhase = 0;
    }

    addWasp() {
        this.waspCount++;
        if (this.waspCount >= 3) {
            this.calmed = true;
        }
    }

    draw(ctx, cx, cy, frame) {
        const sx = this.x - cx;
        const sy = this.y - cy;

        if (this.calmed) {
            // Kids standing apart, calm
            this.drawKid(ctx, sx - 20, sy, '#e74c3c', 0);
            this.drawKid(ctx, sx + 20, sy, '#3498db', 0);

            // Speech bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            this.roundRect(ctx, sx - 15, sy - 50, 30, 20, 5);
            ctx.fill();
            ctx.fillStyle = '#2c3e50';
            ctx.font = '10px DM Sans';
            ctx.textAlign = 'center';
            ctx.fillText('Sorry!', sx, sy - 36);
        } else {
            // Animated fighting
            this.animPhase += 0.1;
            const shake = Math.sin(this.animPhase * 3) * 3;

            this.drawKid(ctx, sx - 8 + shake, sy, '#e74c3c', shake * 0.1);
            this.drawKid(ctx, sx + 8 - shake, sy, '#3498db', -shake * 0.1);

            // Dust cloud
            ctx.fillStyle = 'rgba(200, 180, 150, 0.3)';
            for (let i = 0; i < 5; i++) {
                const px = sx + Math.sin(this.animPhase + i) * 15;
                const py = sy + 15 + Math.cos(this.animPhase * 0.7 + i) * 5;
                ctx.beginPath();
                ctx.arc(px, py, 4 + Math.sin(i) * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Exclamation marks
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 14px DM Sans';
            ctx.fillText('!', sx - 15, sy - 30 + Math.sin(this.animPhase * 2) * 3);
            ctx.fillText('!', sx + 15, sy - 30 + Math.cos(this.animPhase * 2) * 3);
        }

        // Indicator if wasps nearby
        if (this.waspCount > 0 && !this.calmed) {
            ctx.fillStyle = 'rgba(244, 208, 63, 0.5)';
            ctx.beginPath();
            ctx.arc(sx, sy, 30 + this.waspCount * 5, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawKid(ctx, x, y, color, rotation) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);

        // Body
        ctx.fillStyle = color;
        ctx.fillRect(-6, 0, 12, 18);

        // Head
        ctx.fillStyle = '#f5d5c8';
        ctx.beginPath();
        ctx.arc(0, -5, 8, 0, Math.PI * 2);
        ctx.fill();

        // Legs
        ctx.fillStyle = '#4a4a5a';
        ctx.fillRect(-5, 18, 4, 10);
        ctx.fillRect(1, 18, 4, 10);

        ctx.restore();
    }

    roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }
}

class TreeWithCat {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.catY = y - 140; // Cat stuck high up
        this.catSaved = false;
        this.catDescending = false;
        this.silkPath = null;
    }

    attachSilk(silk) {
        this.silkPath = silk;
        this.catDescending = true;
    }

    update() {
        if (this.catDescending && this.silkPath) {
            // Cat walks down the silk
            if (this.catY < GROUND_Y - 20) {
                this.catY += 0.8;
            } else {
                this.catSaved = true;
                this.catDescending = false;
            }
        }
    }

    draw(ctx, cx, cy, frame) {
        const sx = this.x - cx;
        const sy = this.y - cy;

        // Tree trunk
        ctx.fillStyle = '#6b5344';
        ctx.fillRect(sx - 15, sy - 180, 30, 180);

        // Tree bark texture
        ctx.strokeStyle = '#5a4535';
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.moveTo(sx - 12 + (i % 3) * 8, sy - 170 + i * 20);
            ctx.lineTo(sx - 10 + (i % 3) * 8, sy - 150 + i * 20);
            ctx.stroke();
        }

        // Foliage (multiple layers)
        const foliageColors = ['#4a7c59', '#5d8a66', '#6b9b70'];
        for (let layer = 0; layer < 3; layer++) {
            ctx.fillStyle = foliageColors[layer];
            const yOff = layer * -20;
            const size = 70 - layer * 10;

            ctx.beginPath();
            ctx.arc(sx, sy - 200 + yOff, size, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(sx - 35, sy - 170 + yOff, size * 0.7, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(sx + 35, sy - 175 + yOff, size * 0.65, 0, Math.PI * 2);
            ctx.fill();
        }

        // Branch for cat
        ctx.fillStyle = '#6b5344';
        ctx.fillRect(sx, sy - 150, 50, 8);

        // Cat
        const catX = sx + 35;
        const catY = this.catY - cy;

        if (!this.catSaved) {
            // Cat body
            ctx.fillStyle = '#f5a623';
            ctx.beginPath();
            ctx.ellipse(catX, catY, 12, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cat head
            ctx.beginPath();
            ctx.arc(catX + 10, catY - 3, 7, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.beginPath();
            ctx.moveTo(catX + 6, catY - 9);
            ctx.lineTo(catX + 9, catY - 15);
            ctx.lineTo(catX + 12, catY - 9);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(catX + 11, catY - 9);
            ctx.lineTo(catX + 14, catY - 14);
            ctx.lineTo(catX + 17, catY - 8);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#2a2a2a';
            ctx.beginPath();
            ctx.arc(catX + 8, catY - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(catX + 13, catY - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Tail
            ctx.strokeStyle = '#f5a623';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(catX - 10, catY);
            ctx.quadraticCurveTo(catX - 18, catY - 15, catX - 12, catY - 20);
            ctx.stroke();

            // Meow indicator if not saved
            if (!this.catDescending) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.ellipse(catX + 25, catY - 15, 20, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#2c3e50';
                ctx.font = '10px DM Sans';
                ctx.textAlign = 'center';
                ctx.fillText('Meow!', catX + 25, catY - 12);
            }
        } else {
            // Happy cat on ground
            const groundCatX = sx + 20;
            const groundCatY = GROUND_Y - cy - 10;

            ctx.fillStyle = '#f5a623';
            ctx.beginPath();
            ctx.ellipse(groundCatX, groundCatY, 10, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(groundCatX + 8, groundCatY - 2, 6, 0, Math.PI * 2);
            ctx.fill();

            // Happy eyes (closed)
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(groundCatX + 6, groundCatY - 3, 2, 0.2, Math.PI - 0.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(groundCatX + 11, groundCatY - 3, 2, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Heart
            ctx.fillStyle = '#e74c3c';
            ctx.font = '12px sans-serif';
            ctx.fillText('‚ô•', groundCatX + 18, groundCatY - 10);
        }
    }
}

// ============== ENVIRONMENT ==============
class Building {
    constructor(x, w, h, color, details = {}) {
        this.x = x;
        this.w = w;
        this.h = h;
        this.color = color;
        this.details = details;
    }

    draw(ctx, cx, cy) {
        const sx = this.x - cx;
        const sy = GROUND_Y - cy - this.h;

        // Building shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(sx + 10, sy + 10, this.w, this.h);

        // Main building
        ctx.fillStyle = this.color;
        ctx.fillRect(sx, sy, this.w, this.h);

        // Windows
        const windowRows = Math.floor(this.h / 50);
        const windowCols = Math.floor(this.w / 40);

        for (let row = 0; row < windowRows; row++) {
            for (let col = 0; col < windowCols; col++) {
                const wx = sx + 15 + col * 40;
                const wy = sy + 20 + row * 50;

                // Window frame
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(wx, wy, 22, 30);

                // Window glass
                ctx.fillStyle = 'rgba(135, 206, 235, 0.4)';
                ctx.fillRect(wx + 2, wy + 2, 18, 26);

                // Window divider
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(wx + 10, wy + 2, 2, 26);
            }
        }

        // Roof detail
        ctx.fillStyle = this.details.roofColor || '#5a5a6a';
        ctx.fillRect(sx - 5, sy - 8, this.w + 10, 10);

        // Door
        if (this.details.hasDoor) {
            ctx.fillStyle = '#5a4a3a';
            ctx.fillRect(sx + this.w/2 - 15, sy + this.h - 50, 30, 50);
            ctx.fillStyle = '#d4af37';
            ctx.beginPath();
            ctx.arc(sx + this.w/2 + 8, sy + this.h - 25, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

class Tree {
    constructor(x, size = 1) {
        this.x = x;
        this.size = size;
    }

    draw(ctx, cx, cy) {
        const sx = this.x - cx;
        const sy = GROUND_Y - cy;
        const s = this.size;

        // Trunk shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        ctx.beginPath();
        ctx.ellipse(sx + 5, sy, 15 * s, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Trunk
        ctx.fillStyle = '#6b5344';
        ctx.fillRect(sx - 8 * s, sy - 80 * s, 16 * s, 80 * s);

        // Foliage
        ctx.fillStyle = '#5d8a66';
        ctx.beginPath();
        ctx.arc(sx, sy - 100 * s, 40 * s, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#4a7c59';
        ctx.beginPath();
        ctx.arc(sx - 25 * s, sy - 85 * s, 30 * s, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(sx + 25 * s, sy - 90 * s, 28 * s, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Bench {
    constructor(x) {
        this.x = x;
    }

    draw(ctx, cx, cy) {
        const sx = this.x - cx;
        const sy = GROUND_Y - cy;

        // Legs
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(sx, sy - 25, 5, 25);
        ctx.fillRect(sx + 55, sy - 25, 5, 25);

        // Seat
        ctx.fillStyle = '#8b7355';
        ctx.fillRect(sx - 5, sy - 30, 70, 8);

        // Back
        ctx.fillRect(sx - 5, sy - 55, 70, 5);
        ctx.fillRect(sx - 5, sy - 45, 70, 5);
    }
}

// ============== MAIN GAME CLASS ==============
class Game {
    constructor() {
        this.taylor = new Taylor(100, GROUND_Y - 60);
        this.bugs = [];
        this.silkRopes = [];
        this.buildings = [];
        this.trees = [];
        this.benches = [];
        this.structures = []; // For collision

        // Interactables
        this.fightingKids = null;
        this.treeWithCat = null;

        // Mission state
        this.kidsCalmed = false;
        this.catSaved = false;
        this.swarmCount = 0;

        // Silk aiming
        this.aimingsilk = false;
        this.silkStart = null;

        // Wasp sending
        this.sendingWasps = false;

        this.initLevel();
        this.spawnBugs();
    }

    initLevel() {
        // Buildings (background layer)
        this.buildings.push(new Building(50, 120, 200, '#d4c4b0', { hasDoor: true, roofColor: '#7a6a5a' }));
        this.buildings.push(new Building(200, 100, 160, '#c9b99a', { roofColor: '#6a5a4a' }));
        this.buildings.push(new Building(350, 140, 220, '#e8dcc8', { hasDoor: true, roofColor: '#8a7a6a' }));
        this.buildings.push(new Building(550, 90, 140, '#d9c9b9', { roofColor: '#7a6a5a' }));
        this.buildings.push(new Building(700, 160, 240, '#c4b4a4', { hasDoor: true, roofColor: '#6a5a4a' }));
        this.buildings.push(new Building(920, 110, 180, '#ddd0c0', { roofColor: '#8a7a6a' }));
        this.buildings.push(new Building(1100, 130, 200, '#cfc0b0', { hasDoor: true, roofColor: '#7a6a5a' }));
        this.buildings.push(new Building(1300, 100, 150, '#e5d8c8', { roofColor: '#6a5a4a' }));
        this.buildings.push(new Building(1480, 150, 230, '#d0c0b0', { hasDoor: true, roofColor: '#8a7a6a' }));
        this.buildings.push(new Building(1700, 120, 190, '#c8b8a8', { roofColor: '#7a6a5a' }));
        this.buildings.push(new Building(1900, 140, 210, '#dcd0c0', { hasDoor: true, roofColor: '#6a5a4a' }));
        this.buildings.push(new Building(2100, 95, 155, '#d5c5b5', { roofColor: '#8a7a6a' }));
        this.buildings.push(new Building(2280, 135, 205, '#c0b0a0', { hasDoor: true, roofColor: '#7a6a5a' }));
        this.buildings.push(new Building(2480, 115, 175, '#e0d0c0', { roofColor: '#6a5a4a' }));
        this.buildings.push(new Building(2650, 145, 225, '#d8c8b8', { hasDoor: true, roofColor: '#8a7a6a' }));
        this.buildings.push(new Building(2850, 125, 195, '#ccc0b0', { roofColor: '#7a6a5a' }));

        // Trees
        this.trees.push(new Tree(180, 0.9));
        this.trees.push(new Tree(480, 1.1));
        this.trees.push(new Tree(680, 0.85));
        this.trees.push(new Tree(1050, 1.0));
        this.trees.push(new Tree(1580, 0.95));
        this.trees.push(new Tree(1850, 1.05));
        this.trees.push(new Tree(2200, 0.9));
        this.trees.push(new Tree(2500, 1.0));
        this.trees.push(new Tree(2750, 0.88));
        this.trees.push(new Tree(3000, 1.02));

        // Benches
        this.benches.push(new Bench(250));
        this.benches.push(new Bench(600));
        this.benches.push(new Bench(1200));
        this.benches.push(new Bench(1700));
        this.benches.push(new Bench(2300));
        this.benches.push(new Bench(2900));

        // Mission objects
        this.fightingKids = new FightingKids(850, GROUND_Y - 28);
        this.treeWithCat = new TreeWithCat(1400, GROUND_Y);

        // Collision structures (benches)
        for (const bench of this.benches) {
            this.structures.push({ x: bench.x - 5, y: GROUND_Y - 30, w: 70, h: 8 });
        }
    }

    spawnBugs() {
        const types = ['fly', 'fly', 'fly', 'wasp', 'spider', 'fly'];

        for (let i = 0; i < 60; i++) {
            const x = 50 + Math.random() * (WORLD_WIDTH - 100);
            const y = GROUND_Y - 20 - Math.random() * 150;
            const type = types[Math.floor(Math.random() * types.length)];
            this.bugs.push(new Bug(x, y, type));
        }
    }

    handlePowerClick(worldX, worldY) {
        if (currentPower === 'silk') {
            if (!this.silkStart) {
                // First click - anchor start
                this.silkStart = { x: worldX, y: worldY };
            } else {
                // Second click - create rope
                const silk = new SilkRope(
                    this.silkStart.x, this.silkStart.y,
                    worldX, worldY,
                    15
                );
                this.silkRopes.push(silk);

                // Check if near tree with cat
                if (this.treeWithCat && !this.treeWithCat.catSaved) {
                    const catX = this.treeWithCat.x + 35;
                    const catY = this.treeWithCat.catY;

                    // Check if silk connects tree area to ground
                    const nearCat = dist(this.silkStart.x, this.silkStart.y, catX, catY) < 60 ||
                                   dist(worldX, worldY, catX, catY) < 60;
                    const touchesGround = this.silkStart.y > GROUND_Y - 50 || worldY > GROUND_Y - 50;

                    if (nearCat && touchesGround) {
                        this.treeWithCat.attachSilk(silk);
                    }
                }

                this.silkStart = null;
            }
        } else if (currentPower === 'wasps') {
            // Send wasps to clicked location
            let waspsSent = 0;
            for (const bug of this.bugs) {
                if (bug.type === 'wasp' && bug.following && waspsSent < 3) {
                    // Send wasp to location
                    bug.targetX = worldX;
                    bug.targetY = worldY;
                    bug.following = false; // Temporarily unfollowed
                    waspsSent++;

                    // Check if near fighting kids
                    if (this.fightingKids && !this.fightingKids.calmed) {
                        if (dist(worldX, worldY, this.fightingKids.x, this.fightingKids.y) < 50) {
                            setTimeout(() => this.fightingKids.addWasp(), 500);
                        }
                    }
                }
            }
        }
    }

    update() {
        // Update Taylor
        this.taylor.update(this.structures);

        // Update bugs
        for (const bug of this.bugs) {
            bug.update(this.taylor);
        }

        // Update silk ropes
        for (const silk of this.silkRopes) {
            silk.update();
        }

        // Update interactables
        if (this.treeWithCat) {
            this.treeWithCat.update();
            this.catSaved = this.treeWithCat.catSaved;
        }

        if (this.fightingKids) {
            this.kidsCalmed = this.fightingKids.calmed;
        }

        // Count swarm
        this.swarmCount = this.bugs.filter(b => b.following).length;

        // Camera follow
        const targetX = this.taylor.x - CANVAS_WIDTH / 2 + this.taylor.w / 2;
        camera.x = lerp(camera.x, targetX, 0.06);
        camera.x = clamp(camera.x, 0, WORLD_WIDTH - CANVAS_WIDTH);

        // Mission check
        const mission = missions[missionIndex];
        if (mission && mission.check(this) && !missionComplete) {
            missionComplete = true;
            showSuccess();
            setTimeout(() => {
                missionIndex++;
                missionComplete = false;
                hideSuccess();
                updateMissionUI();
            }, 2000);
        }
    }

    render() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Sky gradient
        const skyGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
        skyGrad.addColorStop(0, '#87CEEB');
        skyGrad.addColorStop(0.5, '#B0E0F0');
        skyGrad.addColorStop(1, '#E8F4F8');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Sun
        ctx.beginPath();
        ctx.arc(750, 80, 50, 0, Math.PI * 2);
        const sunGrad = ctx.createRadialGradient(750, 80, 0, 750, 80, 60);
        sunGrad.addColorStop(0, 'rgba(255, 250, 220, 1)');
        sunGrad.addColorStop(0.5, 'rgba(255, 245, 200, 0.8)');
        sunGrad.addColorStop(1, 'rgba(255, 240, 180, 0)');
        ctx.fillStyle = sunGrad;
        ctx.fill();

        // Clouds
        this.drawClouds();

        // Background buildings
        for (const building of this.buildings) {
            building.draw(ctx, camera.x * 0.6, 0);
        }

        // Trees (behind characters)
        for (const tree of this.trees) {
            tree.draw(ctx, camera.x, camera.y);
        }

        // Ground
        const groundGrad = ctx.createLinearGradient(0, GROUND_Y - camera.y, 0, CANVAS_HEIGHT);
        groundGrad.addColorStop(0, '#90a868');
        groundGrad.addColorStop(0.1, '#7a9858');
        groundGrad.addColorStop(1, '#6a8848');
        ctx.fillStyle = groundGrad;
        ctx.fillRect(0, GROUND_Y - camera.y, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Sidewalk
        ctx.fillStyle = '#c8c0b0';
        ctx.fillRect(-camera.x, GROUND_Y - camera.y - 20, WORLD_WIDTH, 25);
        ctx.fillStyle = '#b8b0a0';
        ctx.fillRect(-camera.x, GROUND_Y - camera.y - 20, WORLD_WIDTH, 3);

        // Benches
        for (const bench of this.benches) {
            bench.draw(ctx, camera.x, camera.y);
        }

        // Tree with cat
        if (this.treeWithCat) {
            this.treeWithCat.draw(ctx, camera.x, camera.y, frame);
        }

        // Silk ropes
        for (const silk of this.silkRopes) {
            silk.draw(ctx, camera.x, camera.y);
        }

        // Silk aiming line
        if (this.silkStart && currentPower === 'silk') {
            ctx.beginPath();
            ctx.moveTo(this.silkStart.x - camera.x, this.silkStart.y - camera.y);
            ctx.lineTo(mouseX, mouseY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Fighting kids
        if (this.fightingKids) {
            this.fightingKids.draw(ctx, camera.x, camera.y, frame);
        }

        // Bugs
        for (const bug of this.bugs) {
            bug.draw(ctx, camera.x, camera.y, frame);
        }

        // Taylor
        this.taylor.draw(ctx, camera.x, camera.y);
    }

    drawClouds() {
        const cloudPositions = [
            { x: 100, y: 60, s: 1 },
            { x: 350, y: 90, s: 0.7 },
            { x: 600, y: 50, s: 0.9 },
            { x: 850, y: 100, s: 0.6 },
        ];

        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';

        for (const cloud of cloudPositions) {
            const cx = (cloud.x - camera.x * 0.1) % (CANVAS_WIDTH + 200) - 50;
            const cy = cloud.y;
            const s = cloud.s;

            ctx.beginPath();
            ctx.arc(cx, cy, 30 * s, 0, Math.PI * 2);
            ctx.arc(cx + 25 * s, cy - 10 * s, 25 * s, 0, Math.PI * 2);
            ctx.arc(cx + 50 * s, cy, 28 * s, 0, Math.PI * 2);
            ctx.arc(cx + 25 * s, cy + 10 * s, 22 * s, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// ============== UI FUNCTIONS ==============
function updateMissionUI() {
    const mission = missions[missionIndex];
    if (mission) {
        document.getElementById('mission-text').textContent = mission.text;
        document.getElementById('mission-hint').textContent = mission.hint;
    }
}

function updateSwarmUI(count, max = 60) {
    document.getElementById('swarm-count').textContent = count;
    document.getElementById('swarm-fill').style.width = (count / max * 100) + '%';
}

function showSuccess() {
    document.getElementById('success-overlay').classList.add('show');
}

function hideSuccess() {
    document.getElementById('success-overlay').classList.remove('show');
}

function setActivePower(power) {
    currentPower = currentPower === power ? null : power;

    document.querySelectorAll('.power-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.power === currentPower);
    });

    // Reset silk aiming
    if (power !== 'silk') {
        game.silkStart = null;
    }
}

// ============== INPUT HANDLERS ==============
document.addEventListener('keydown', (e) => {
    if (!keys[e.code]) {
        keysJustPressed.add(e.code);
    }
    keys[e.code] = true;

    // Power hotkeys
    if (e.code === 'KeyQ') setActivePower('silk');
    if (e.code === 'KeyW' && !keys['Space']) setActivePower('wasps');
    if (e.code === 'KeyE') setActivePower('scout');

    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', (e) => {
    mouseDown = true;
    mouseClicked = true;

    if (currentPower) {
        const worldX = mouseX + camera.x;
        const worldY = mouseY + camera.y;
        game.handlePowerClick(worldX, worldY);
    }
});

canvas.addEventListener('mouseup', () => {
    mouseDown = false;
});

// Power button clicks
document.querySelectorAll('.power-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        setActivePower(btn.dataset.power);
    });
});

// ============== GAME LOOP ==============
let game;

function gameLoop() {
    frame++;

    game.update();
    game.render();

    // Update UI
    updateSwarmUI(game.swarmCount);

    // Clear just-pressed keys
    keysJustPressed.clear();
    mouseClicked = false;

    requestAnimationFrame(gameLoop);
}

// Start game
game = new Game();
updateMissionUI();
gameLoop();
    </script>
</body>
</html>
