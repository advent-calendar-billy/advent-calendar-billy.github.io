<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worm: Gestation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a24;
            color: #c0c0c0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            user-select: none;
        }
        h1 {
            color: #a08060;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 1.4em;
            letter-spacing: 2px;
        }
        .subtitle {
            color: #888;
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        #loading {
            font-size: 1em;
            color: #a08060;
            margin-bottom: 10px;
        }
        #game-container {
            position: relative;
        }
        #game-canvas {
            display: block;
            background: #1a1a24;
            border: 2px solid #444;
            image-rendering: pixelated;
        }
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        .hp-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .hp-label {
            color: #a08060;
            font-size: 10px;
            width: 50px;
        }
        .hp-bar-outer {
            width: 120px;
            height: 10px;
            background: #2a2a34;
            border: 1px solid #444;
        }
        .hp-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #5a8a6a 0%, #7aba8a 100%);
            transition: width 0.3s;
        }
        .hp-bar-inner.enemy {
            background: linear-gradient(90deg, #8a5a5a 0%, #ba7a7a 100%);
        }
        .swarm-count {
            color: #9a9a7a;
            font-size: 10px;
        }
        #controls-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #666;
            font-size: 9px;
            pointer-events: none;
        }
        #controls-hint kbd {
            background: #2a2a34;
            padding: 1px 4px;
            border: 1px solid #444;
            color: #888;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <h1>WORM: GESTATION</h1>
    <div class="subtitle">The Docks - Brockton Bay</div>
    <div id="loading">Initializing...</div>

    <div id="game-container" class="hidden">
        <canvas id="game-canvas" width="900" height="600"></canvas>
        <div id="ui-overlay">
            <div class="hp-container">
                <span class="hp-label">TAYLOR</span>
                <div class="hp-bar-outer">
                    <div class="hp-bar-inner" id="taylor-hp" style="width: 100%"></div>
                </div>
            </div>
            <div class="hp-container hidden" id="boss-hp-container">
                <span class="hp-label">LUNG</span>
                <div class="hp-bar-outer">
                    <div class="hp-bar-inner enemy" id="boss-hp" style="width: 100%"></div>
                </div>
            </div>
            <div class="swarm-count" id="swarm-count">Swarm: 0</div>
        </div>
        <div id="controls-hint">
            <kbd>A/D</kbd> Move
            <kbd>SPACE</kbd> Jump
            <kbd>J</kbd> Sting
            <kbd>K</kbd> Bite
            <kbd>L</kbd> Blind
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script>
        const loading = document.getElementById('loading');
        const gameContainer = document.getElementById('game-container');

        window.keysHeld = {};
        window.keysJustPressed = [];

        window.uiState = {
            taylorHp: 100,
            bossHp: 100,
            bossVisible: false,
            swarmCount: 0
        };

        async function main() {
            try {
                loading.textContent = 'Loading Python runtime...';
                const pyodide = await loadPyodide();

                loading.textContent = 'Entering Brockton Bay...';

                document.addEventListener('keydown', (e) => {
                    if (!window.keysHeld[e.code]) {
                        window.keysJustPressed.push(e.code);
                    }
                    window.keysHeld[e.code] = true;
                    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    window.keysHeld[e.code] = false;
                });

                await pyodide.runPythonAsync(`
${GAME_CODE}
                `);

                loading.classList.add('hidden');
                gameContainer.classList.remove('hidden');

                // Update UI
                setInterval(() => {
                    document.getElementById('taylor-hp').style.width = window.uiState.taylorHp + '%';
                    document.getElementById('boss-hp').style.width = window.uiState.bossHp + '%';
                    document.getElementById('boss-hp-container').classList.toggle('hidden', !window.uiState.bossVisible);
                    document.getElementById('swarm-count').textContent = 'Swarm: ' + window.uiState.swarmCount;
                }, 100);

            } catch (error) {
                loading.textContent = 'Error: ' + error.message;
                loading.style.color = '#ff4444';
                console.error(error);
            }
        }

        const GAME_CODE = `
import math
import random
from js import document, window, requestAnimationFrame
from pyodide.ffi import create_proxy

# ============== CONSTANTS ==============
CANVAS_WIDTH = 900
CANVAS_HEIGHT = 600
WORLD_WIDTH = 2800
WORLD_HEIGHT = 700

GRAVITY = 0.45
JUMP_FORCE = -10
MAX_FALL_SPEED = 11
TAYLOR_SPEED = 3.2
CONTROL_RANGE = 140
LOSE_RANGE = 190

# Ground level
GROUND_Y = WORLD_HEIGHT - 60

# ============== UTILITY ==============
def clamp(val, min_val, max_val):
    return max(min_val, min(max_val, val))

def lerp(a, b, t):
    return a + (b - a) * t

def distance(x1, y1, x2, y2):
    return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def rect_intersect(x1, y1, w1, h1, x2, y2, w2, h2):
    return x1 < x2 + w2 and x1 + w1 > x2 and y1 < y2 + h2 and y1 + h1 > y2

# ============== STRUCTURES ==============
class Structure:
    def __init__(self, x, y, w, h, struct_type='crate'):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.struct_type = struct_type

    def get_top_surface(self):
        # Returns (x, y, width) of walkable top
        return (self.x, self.y, self.w)

    def draw(self, ctx, cx, cy):
        sx, sy = self.x - cx, self.y - cy

        if self.struct_type == 'crate':
            # Wooden crate
            ctx.fillStyle = '#5a4a35'
            ctx.fillRect(sx, sy, self.w, self.h)
            # Wood grain
            ctx.strokeStyle = '#4a3a28'
            ctx.lineWidth = 1
            ctx.strokeRect(sx + 2, sy + 2, self.w - 4, self.h - 4)
            # Cross boards
            ctx.beginPath()
            ctx.moveTo(sx + 3, sy + 3)
            ctx.lineTo(sx + self.w - 3, sy + self.h - 3)
            ctx.stroke()
            ctx.beginPath()
            ctx.moveTo(sx + self.w - 3, sy + 3)
            ctx.lineTo(sx + 3, sy + self.h - 3)
            ctx.stroke()
            # Highlight
            ctx.fillStyle = '#6a5a45'
            ctx.fillRect(sx, sy, self.w, 3)

        elif self.struct_type == 'container':
            # Shipping container
            ctx.fillStyle = '#4a5560'
            ctx.fillRect(sx, sy, self.w, self.h)
            # Ridges
            ctx.fillStyle = '#3a4550'
            for i in range(int(self.w // 30)):
                ctx.fillRect(sx + 10 + i * 30, sy, 3, self.h)
            # Top highlight
            ctx.fillStyle = '#5a6570'
            ctx.fillRect(sx, sy, self.w, 4)
            # Door lines
            ctx.strokeStyle = '#3a4550'
            ctx.lineWidth = 2
            ctx.strokeRect(sx + 5, sy + 10, self.w - 10, self.h - 15)

        elif self.struct_type == 'warehouse_floor':
            # Metal floor/catwalk
            ctx.fillStyle = '#4a4a50'
            ctx.fillRect(sx, sy, self.w, self.h)
            # Grating pattern
            ctx.strokeStyle = '#3a3a40'
            ctx.lineWidth = 1
            for i in range(int(self.w // 15)):
                ctx.beginPath()
                ctx.moveTo(sx + i * 15, sy)
                ctx.lineTo(sx + i * 15, sy + self.h)
                ctx.stroke()
            # Edge
            ctx.fillStyle = '#5a5a60'
            ctx.fillRect(sx, sy, self.w, 2)
            # Support beams underneath
            ctx.fillStyle = '#3a3a40'
            ctx.fillRect(sx + 10, sy + self.h, 8, 30)
            ctx.fillRect(sx + self.w - 18, sy + self.h, 8, 30)

        elif self.struct_type == 'stairs':
            # Stairs going up-right
            ctx.fillStyle = '#4a4a50'
            steps = 5
            step_w = self.w // steps
            step_h = self.h // steps
            for i in range(steps):
                ctx.fillRect(sx + i * step_w, sy + self.h - (i + 1) * step_h, step_w + 2, (i + 1) * step_h)
                ctx.fillStyle = '#5a5a60'
                ctx.fillRect(sx + i * step_w, sy + self.h - (i + 1) * step_h, step_w + 2, 2)
                ctx.fillStyle = '#4a4a50'

        elif self.struct_type == 'warehouse_wall':
            # Background warehouse wall (not collidable, just visual)
            ctx.fillStyle = '#2a2a30'
            ctx.fillRect(sx, sy, self.w, self.h)
            # Windows
            ctx.fillStyle = '#1a2a35'
            win_y = sy + 30
            for i in range(int(self.w // 80)):
                ctx.fillRect(sx + 20 + i * 80, win_y, 40, 50)
                # Window frame
                ctx.strokeStyle = '#3a3a40'
                ctx.lineWidth = 2
                ctx.strokeRect(sx + 20 + i * 80, win_y, 40, 50)
            # Corrugated metal lines
            ctx.strokeStyle = '#353540'
            ctx.lineWidth = 1
            for i in range(int(self.w // 20)):
                ctx.beginPath()
                ctx.moveTo(sx + i * 20, sy)
                ctx.lineTo(sx + i * 20, sy + self.h)
                ctx.stroke()

# ============== TAYLOR ==============
class Taylor:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.w = 18
        self.h = 38

        self.hp = 100
        self.max_hp = 100

        self.on_ground = False
        self.facing = 1
        self.state = 'idle'

        self.attack_timer = 0
        self.attack_type = None
        self.attack_cooldown = 0
        self.invuln_timer = 0

        self.anim_frame = 0
        self.anim_timer = 0

    def update(self, keys, key_pressed, structures):
        move_x = 0
        if keys.get('KeyA') or keys.get('ArrowLeft'):
            move_x = -1
            self.facing = -1
        if keys.get('KeyD') or keys.get('ArrowRight'):
            move_x = 1
            self.facing = 1

        self.vx = move_x * TAYLOR_SPEED

        if (key_pressed.get('Space') or key_pressed.get('KeyW') or key_pressed.get('ArrowUp')) and self.on_ground:
            self.vy = JUMP_FORCE
            self.on_ground = False

        self.vy += GRAVITY
        self.vy = min(self.vy, MAX_FALL_SPEED)

        if self.attack_cooldown <= 0:
            if key_pressed.get('KeyJ'):
                self.start_attack('sting')
            elif key_pressed.get('KeyK'):
                self.start_attack('bite')
            elif key_pressed.get('KeyL'):
                self.start_attack('blind')

        if self.attack_timer > 0:
            self.attack_timer -= 1
            if self.attack_timer <= 0:
                self.attack_type = None

        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1

        if self.invuln_timer > 0:
            self.invuln_timer -= 1

        # Horizontal movement
        self.x += self.vx
        # Check horizontal collision
        for struct in structures:
            if struct.struct_type in ['crate', 'container', 'warehouse_floor']:
                if rect_intersect(self.x, self.y, self.w, self.h, struct.x, struct.y, struct.w, struct.h):
                    if self.vx > 0:
                        self.x = struct.x - self.w
                    elif self.vx < 0:
                        self.x = struct.x + struct.w

        # Vertical movement
        self.y += self.vy
        self.on_ground = False

        # Check vertical collision
        for struct in structures:
            if struct.struct_type in ['crate', 'container', 'warehouse_floor', 'stairs']:
                if rect_intersect(self.x, self.y, self.w, self.h, struct.x, struct.y, struct.w, struct.h):
                    if self.vy > 0:
                        self.y = struct.y - self.h
                        self.vy = 0
                        self.on_ground = True
                    elif self.vy < 0 and struct.struct_type != 'stairs':
                        self.y = struct.y + struct.h
                        self.vy = 0

        # Ground
        if self.y + self.h >= GROUND_Y:
            self.y = GROUND_Y - self.h
            self.vy = 0
            self.on_ground = True

        self.x = clamp(self.x, 0, WORLD_WIDTH - self.w)

        # State
        if self.attack_timer > 0:
            self.state = 'attack'
        elif not self.on_ground:
            self.state = 'jump' if self.vy < 0 else 'fall'
        elif abs(self.vx) > 0.5:
            self.state = 'run'
        else:
            self.state = 'idle'

        # Animation
        self.anim_timer += 1
        if self.state == 'run':
            if self.anim_timer >= 6:
                self.anim_timer = 0
                self.anim_frame = (self.anim_frame + 1) % 4
        else:
            self.anim_frame = 0

    def start_attack(self, attack_type):
        self.attack_type = attack_type
        self.attack_timer = 25
        self.attack_cooldown = 30

    def get_attack_hitbox(self):
        if not self.attack_type or self.attack_timer < 15:
            return None
        hb_w, hb_h = 45, 28
        hb_x = self.x + self.w if self.facing > 0 else self.x - hb_w
        hb_y = self.y + 5
        return (hb_x, hb_y, hb_w, hb_h)

    def take_damage(self, amount):
        if self.invuln_timer > 0:
            return
        self.hp -= amount
        self.invuln_timer = 60
        if self.hp <= 0:
            self.hp = 0

    def draw(self, ctx, cx, cy):
        sx, sy = self.x - cx, self.y - cy

        if self.invuln_timer > 0 and (self.invuln_timer // 4) % 2 == 0:
            return

        f = self.facing
        body_offset = 0
        if self.state == 'run':
            body_offset = [0, -1, 0, -1][self.anim_frame]

        # Body (grey-black costume)
        ctx.fillStyle = '#2a2a2a'
        ctx.fillRect(sx + 3, sy + 11 + body_offset, 12, 18)

        # Legs
        ctx.fillStyle = '#222222'
        if self.state == 'run':
            offsets = [(0, 3), (2, -2), (0, 3), (-2, -2)]
            l1, l2 = offsets[self.anim_frame]
            ctx.fillRect(sx + 4, sy + 29 + body_offset, 4, 9 + l1)
            ctx.fillRect(sx + 10, sy + 29 + body_offset, 4, 9 + l2)
        elif self.state in ['jump', 'fall']:
            ctx.fillRect(sx + 3, sy + 29, 5, 7)
            ctx.fillRect(sx + 10, sy + 27, 5, 9)
        else:
            ctx.fillRect(sx + 4, sy + 29, 4, 9)
            ctx.fillRect(sx + 10, sy + 29, 4, 9)

        # Head with mask
        ctx.fillStyle = '#303030'
        ctx.fillRect(sx + 4, sy + 1, 10, 11)

        # Yellow lenses
        ctx.fillStyle = '#d4b030'
        if f > 0:
            ctx.fillRect(sx + 9, sy + 4, 3, 3)
        else:
            ctx.fillRect(sx + 6, sy + 4, 3, 3)

        # Dark curly hair
        ctx.fillStyle = '#151515'
        ctx.fillRect(sx + 3, sy - 1, 12, 4)
        ctx.fillRect(sx + 2, sy + 1, 2, 5)
        ctx.fillRect(sx + 14, sy + 1, 2, 5)

        # Arm
        ctx.fillStyle = '#2a2a2a'
        arm_y = sy + 13 + body_offset
        if self.state == 'attack':
            if f > 0:
                ctx.fillRect(sx + 13, arm_y, 10, 4)
            else:
                ctx.fillRect(sx - 5, arm_y, 10, 4)
        else:
            if f > 0:
                ctx.fillRect(sx + 13, arm_y, 4, 9)
            else:
                ctx.fillRect(sx + 1, arm_y, 4, 9)

        # Attack effect (swarm of bugs)
        if self.attack_type and self.attack_timer > 15:
            hb = self.get_attack_hitbox()
            if hb:
                hx, hy, hw, hh = hb
                hx -= cx
                hy -= cy
                # Draw swarm particles
                if self.attack_type == 'sting':
                    ctx.fillStyle = 'rgba(200, 180, 60, 0.5)'
                elif self.attack_type == 'bite':
                    ctx.fillStyle = 'rgba(120, 200, 120, 0.5)'
                else:
                    ctx.fillStyle = 'rgba(160, 160, 200, 0.5)'

                for i in range(8):
                    px = hx + random.uniform(0, hw)
                    py = hy + random.uniform(0, hh)
                    ctx.beginPath()
                    ctx.arc(px, py, 2, 0, math.pi * 2)
                    ctx.fill()

# ============== BUG ==============
class Bug:
    def __init__(self, x, y, bug_type='fly'):
        self.x = x
        self.y = y
        self.bug_type = bug_type
        self.alive = True
        self.following = False
        self.target_x = x
        self.target_y = y
        self.anim_phase = random.uniform(0, math.pi * 2)

        if bug_type == 'fly':
            self.color = '#7a7a5a'
            self.size = 3
            self.speed = 2.0
        elif bug_type == 'spider':
            self.color = '#5a4a3a'
            self.size = 5
            self.speed = 1.0
        elif bug_type == 'wasp':
            self.color = '#9a7a30'
            self.size = 4
            self.speed = 1.8
        elif bug_type == 'beetle':
            self.color = '#3a4a3a'
            self.size = 5
            self.speed = 0.7

    def update(self, taylor, structures):
        taylor_cx = taylor.x + taylor.w/2
        taylor_cy = taylor.y + taylor.h/2
        dist = distance(self.x, self.y, taylor_cx, taylor_cy)

        if dist < CONTROL_RANGE and not self.following:
            self.following = True

        if self.following and dist > LOSE_RANGE:
            self.following = False

        if self.following:
            self.anim_phase += 0.05

            swarm_dist = 22 + math.sin(self.anim_phase * 0.7) * 10
            self.target_x = taylor_cx + math.cos(self.anim_phase) * swarm_dist
            self.target_y = taylor_cy + math.sin(self.anim_phase * 1.3) * swarm_dist * 0.4

            dx = self.target_x - self.x
            dy = self.target_y - self.y
            move_dist = math.sqrt(dx*dx + dy*dy)

            if move_dist > 3:
                urgency = min(1.4, move_dist / 60)
                speed = self.speed * urgency
                self.x += (dx / move_dist) * speed
                self.y += (dy / move_dist) * speed

            # Ground bugs affected by gravity and structures
            if self.bug_type in ['spider', 'beetle']:
                self.y += 1.2
                for struct in structures:
                    if struct.struct_type in ['crate', 'container', 'warehouse_floor']:
                        if (self.x > struct.x and self.x < struct.x + struct.w and
                            self.y > struct.y and self.y < struct.y + 10):
                            self.y = struct.y
                if self.y > GROUND_Y:
                    self.y = GROUND_Y

    def draw(self, ctx, cx, cy, frame):
        sx, sy = self.x - cx, self.y - cy

        # Dim if not following
        if self.following:
            ctx.fillStyle = self.color
        else:
            ctx.fillStyle = '#4a4a4a'

        if self.bug_type in ['fly', 'wasp']:
            ctx.beginPath()
            ctx.ellipse(sx, sy, self.size, self.size * 0.6, 0, 0, math.pi * 2)
            ctx.fill()
            wing_flap = math.sin(frame * 0.5 + self.anim_phase) * 0.4
            ctx.fillStyle = 'rgba(120, 120, 120, 0.3)'
            ctx.beginPath()
            ctx.ellipse(sx - 2, sy - 2, 3, 1.5, wing_flap, 0, math.pi * 2)
            ctx.fill()
            ctx.beginPath()
            ctx.ellipse(sx + 2, sy - 2, 3, 1.5, -wing_flap, 0, math.pi * 2)
            ctx.fill()
        elif self.bug_type == 'spider':
            ctx.beginPath()
            ctx.arc(sx, sy, self.size, 0, math.pi * 2)
            ctx.fill()
            ctx.strokeStyle = self.color if self.following else '#4a4a4a'
            ctx.lineWidth = 0.8
            for i in range(4):
                angle = i * 0.4 - 0.6 + math.sin(frame * 0.05 + i) * 0.1
                ctx.beginPath()
                ctx.moveTo(sx, sy)
                ctx.lineTo(sx - math.cos(angle) * 6, sy + math.sin(angle) * 4)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(sx, sy)
                ctx.lineTo(sx + math.cos(angle) * 6, sy + math.sin(angle) * 4)
                ctx.stroke()
        else:
            ctx.beginPath()
            ctx.ellipse(sx, sy, self.size, self.size * 0.7, 0, 0, math.pi * 2)
            ctx.fill()

# ============== ENEMY ==============
class Enemy:
    def __init__(self, x, y, enemy_type='thug'):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.w = 22
        self.h = 42

        self.enemy_type = enemy_type
        self.alive = True
        self.facing = -1

        if enemy_type == 'thug':
            self.hp = 40
            self.max_hp = 40
            self.damage = 10
            self.color = '#6a4545'
        else:
            self.hp = 55
            self.max_hp = 55
            self.damage = 14
            self.color = '#7a4040'

        self.patrol_left = x - 60
        self.patrol_right = x + 60
        self.state = 'patrol'
        self.attack_cooldown = 0
        self.stun_timer = 0
        self.effects = {}

    def add_effect(self, name, duration):
        self.effects[name] = duration

    def take_damage(self, amount, effect=None):
        self.hp -= amount
        self.stun_timer = 12
        if effect:
            if effect == 'bite':
                self.add_effect('venom', 180)
            elif effect == 'blind':
                self.add_effect('blind', 180)
        if self.hp <= 0:
            self.alive = False

    def update(self, taylor, structures):
        if not self.alive:
            return

        for name in list(self.effects.keys()):
            self.effects[name] -= 1
            if name == 'venom':
                self.hp -= 0.1
                if self.hp <= 0:
                    self.alive = False
            if self.effects[name] <= 0:
                del self.effects[name]

        if self.stun_timer > 0:
            self.stun_timer -= 1
            self.vy += GRAVITY
            self.y += self.vy
            self.check_ground(structures)
            return

        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1

        dist_to_taylor = distance(self.x, self.y, taylor.x, taylor.y)
        can_see = 'blind' not in self.effects
        speed = 1.4 if can_see else 0.4

        if can_see and dist_to_taylor < 180:
            self.state = 'chase'
            if taylor.x < self.x:
                self.vx = -speed
                self.facing = -1
            else:
                self.vx = speed
                self.facing = 1

            if dist_to_taylor < 30 and self.attack_cooldown <= 0:
                taylor.take_damage(self.damage)
                self.attack_cooldown = 80
        else:
            self.state = 'patrol'
            if self.x <= self.patrol_left:
                self.facing = 1
            elif self.x >= self.patrol_right:
                self.facing = -1
            self.vx = self.facing * speed * 0.4

        self.vy += GRAVITY
        self.x += self.vx
        self.y += self.vy
        self.check_ground(structures)
        self.x = clamp(self.x, 0, WORLD_WIDTH - self.w)

    def check_ground(self, structures):
        if self.y + self.h >= GROUND_Y:
            self.y = GROUND_Y - self.h
            self.vy = 0

        for struct in structures:
            if struct.struct_type in ['crate', 'container', 'warehouse_floor']:
                if rect_intersect(self.x, self.y, self.w, self.h, struct.x, struct.y, struct.w, struct.h):
                    if self.vy > 0:
                        self.y = struct.y - self.h
                        self.vy = 0

    def draw(self, ctx, cx, cy):
        sx, sy = self.x - cx, self.y - cy

        color = self.color
        if 'venom' in self.effects:
            color = '#5a6a5a'
        if 'blind' in self.effects:
            color = '#5a5a6a'

        ctx.fillStyle = color
        ctx.fillRect(sx + 4, sy + 12, 14, 20)

        ctx.beginPath()
        ctx.arc(sx + 11, sy + 9, 7, 0, math.pi * 2)
        ctx.fill()

        ctx.fillRect(sx + 5, sy + 32, 5, 10)
        ctx.fillRect(sx + 12, sy + 32, 5, 10)

        # HP bar
        ctx.fillStyle = '#2a2a2a'
        ctx.fillRect(sx, sy - 8, self.w, 4)
        ctx.fillStyle = '#6a5555'
        ctx.fillRect(sx, sy - 8, self.w * (self.hp / self.max_hp), 4)

# ============== LUNG ==============
class Lung:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.vx = 0
        self.vy = 0
        self.w = 36
        self.h = 55

        self.hp = 280
        self.max_hp = 280
        self.damage = 18
        self.alive = True
        self.facing = -1

        self.stage = 1
        self.stage_timer = 0
        self.engaged = False

        self.attack_cooldown = 0
        self.state = 'idle'
        self.effects = {}

    def add_effect(self, name, duration):
        duration = int(duration * (1 - (self.stage - 1) * 0.12))
        if duration > 0:
            self.effects[name] = duration

    def take_damage(self, amount, effect=None):
        reduction = 1 - (self.stage - 1) * 0.08
        self.hp -= amount * reduction
        self.engaged = True
        if effect:
            if effect == 'bite':
                self.add_effect('venom', 180)
            elif effect == 'blind':
                self.add_effect('blind', 100)
        if self.hp <= 0:
            self.alive = False

    def update(self, taylor, structures):
        if not self.alive:
            return

        if self.engaged:
            self.stage_timer += 1
            if self.stage_timer >= 800 and self.stage < 5:
                self.stage += 1
                self.stage_timer = 0
                self.max_hp += 25
                self.hp = min(self.hp + 40, self.max_hp)

        for name in list(self.effects.keys()):
            self.effects[name] -= 1
            if name == 'venom':
                self.hp -= 0.12 * (1 - (self.stage - 1) * 0.08)
            if self.effects[name] <= 0:
                del self.effects[name]

        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1

        speed = 1.0 + self.stage * 0.25
        if 'blind' in self.effects:
            speed *= 0.5

        dist = distance(self.x, self.y, taylor.x, taylor.y)

        if dist < 350 or self.engaged:
            self.engaged = True
            self.state = 'chase'

            if taylor.x < self.x:
                self.vx = -speed
                self.facing = -1
            else:
                self.vx = speed
                self.facing = 1

            attack_range = 45 + self.stage * 8
            if dist < attack_range and self.attack_cooldown <= 0:
                taylor.take_damage(self.damage + self.stage * 4)
                self.attack_cooldown = max(55, 85 - self.stage * 5)
        else:
            self.state = 'idle'
            self.vx = 0

        self.vy += GRAVITY
        self.x += self.vx
        self.y += self.vy

        if self.y + self.h >= GROUND_Y:
            self.y = GROUND_Y - self.h
            self.vy = 0

        self.x = clamp(self.x, 0, WORLD_WIDTH - self.w)

    def draw(self, ctx, cx, cy, frame):
        sx, sy = self.x - cx, self.y - cy

        scale = 1 + (self.stage - 1) * 0.12
        w = int(self.w * scale)
        h = int(self.h * scale)

        colors = ['#805030', '#905040', '#a04540', '#b54535', '#c55030']
        color = colors[self.stage - 1]

        # Fire aura
        if self.stage >= 3:
            ctx.fillStyle = f'rgba(255, {120 - self.stage * 15}, 20, {0.12 + math.sin(frame * 0.12) * 0.04})'
            ctx.beginPath()
            ctx.arc(sx + w//2, sy + h//2, w//2 + 12 + self.stage * 4, 0, math.pi * 2)
            ctx.fill()

        ctx.fillStyle = color
        ctx.fillRect(sx, sy + 14, w, h - 24)

        head_size = 10 + self.stage * 2
        ctx.beginPath()
        ctx.arc(sx + w//2, sy + head_size, head_size, 0, math.pi * 2)
        ctx.fill()

        ctx.fillRect(sx + 4, sy + h - 10, w//3, 10)
        ctx.fillRect(sx + w - w//3 - 4, sy + h - 10, w//3, 10)

        if self.stage >= 4:
            ctx.fillStyle = '#302525'
            for i in range(self.stage - 3):
                ctx.fillRect(sx + 4, sy + 22 + i * 8, w - 8, 2)

        if 'blind' in self.effects:
            ctx.fillStyle = '#ffff00'
            ctx.font = '12px monospace'
            ctx.fillText('*', sx + w//2 - 3, sy + 4)

# ============== GAME ==============
class Game:
    def __init__(self):
        self.canvas = document.getElementById('game-canvas')
        self.ctx = self.canvas.getContext('2d')

        self.taylor = Taylor(100, GROUND_Y - 50)
        self.structures = []
        self.bg_structures = []  # Background visuals
        self.bugs = []
        self.enemies = []
        self.lung = None

        self.camera_x = 0
        self.camera_y = 0

        self.frame = 0
        self.game_over = False
        self.victory = False

        self.create_level()
        self.spawn_bugs()
        self.spawn_enemies()

    def create_level(self):
        # Background warehouse walls (visual only)
        self.bg_structures.append(Structure(0, GROUND_Y - 300, 400, 300, 'warehouse_wall'))
        self.bg_structures.append(Structure(600, GROUND_Y - 350, 500, 350, 'warehouse_wall'))
        self.bg_structures.append(Structure(1300, GROUND_Y - 320, 450, 320, 'warehouse_wall'))
        self.bg_structures.append(Structure(2000, GROUND_Y - 380, 600, 380, 'warehouse_wall'))

        # Area 1: Starting dock - crates and containers
        self.structures.append(Structure(80, GROUND_Y - 45, 50, 45, 'crate'))
        self.structures.append(Structure(130, GROUND_Y - 45, 50, 45, 'crate'))
        self.structures.append(Structure(95, GROUND_Y - 90, 50, 45, 'crate'))
        self.structures.append(Structure(220, GROUND_Y - 70, 120, 70, 'container'))

        # Area 2: Warehouse section
        self.structures.append(Structure(450, GROUND_Y - 50, 55, 50, 'crate'))
        self.structures.append(Structure(505, GROUND_Y - 50, 55, 50, 'crate'))
        self.structures.append(Structure(470, GROUND_Y - 95, 55, 45, 'crate'))
        self.structures.append(Structure(620, GROUND_Y - 80, 140, 80, 'container'))
        self.structures.append(Structure(620, GROUND_Y - 130, 100, 50, 'warehouse_floor'))

        # Area 3: Catwalks and vertical
        self.structures.append(Structure(850, GROUND_Y - 55, 60, 55, 'crate'))
        self.structures.append(Structure(910, GROUND_Y - 55, 60, 55, 'crate'))
        self.structures.append(Structure(850, GROUND_Y - 100, 120, 45, 'warehouse_floor'))
        self.structures.append(Structure(1000, GROUND_Y - 80, 150, 80, 'container'))
        self.structures.append(Structure(1000, GROUND_Y - 135, 150, 55, 'warehouse_floor'))

        # Area 4: More complex
        self.structures.append(Structure(1220, GROUND_Y - 50, 55, 50, 'crate'))
        self.structures.append(Structure(1275, GROUND_Y - 50, 55, 50, 'crate'))
        self.structures.append(Structure(1330, GROUND_Y - 50, 55, 50, 'crate'))
        self.structures.append(Structure(1240, GROUND_Y - 95, 110, 45, 'crate'))
        self.structures.append(Structure(1450, GROUND_Y - 90, 180, 90, 'container'))
        self.structures.append(Structure(1450, GROUND_Y - 145, 130, 55, 'warehouse_floor'))

        # Area 5: Lung's arena
        self.structures.append(Structure(1750, GROUND_Y - 60, 70, 60, 'crate'))
        self.structures.append(Structure(1820, GROUND_Y - 60, 70, 60, 'crate'))
        self.structures.append(Structure(1950, GROUND_Y - 100, 200, 100, 'container'))
        self.structures.append(Structure(2200, GROUND_Y - 55, 60, 55, 'crate'))
        self.structures.append(Structure(2260, GROUND_Y - 55, 60, 55, 'crate'))
        self.structures.append(Structure(2400, GROUND_Y - 80, 160, 80, 'container'))

    def spawn_bugs(self):
        bug_types = ['fly', 'fly', 'fly', 'spider', 'wasp', 'beetle']

        for i in range(25):
            x = random.uniform(50, 500)
            y = random.uniform(GROUND_Y - 200, GROUND_Y - 20)
            self.bugs.append(Bug(x, y, random.choice(bug_types)))

        for i in range(30):
            x = random.uniform(550, 1200)
            y = random.uniform(GROUND_Y - 250, GROUND_Y - 20)
            self.bugs.append(Bug(x, y, random.choice(bug_types)))

        for i in range(35):
            x = random.uniform(1400, 2600)
            y = random.uniform(GROUND_Y - 200, GROUND_Y - 20)
            self.bugs.append(Bug(x, y, random.choice(bug_types)))

    def spawn_enemies(self):
        positions = [
            (350, GROUND_Y - 50, 'thug'),
            (700, GROUND_Y - 50, 'abb'),
            (1050, GROUND_Y - 50, 'thug'),
            (1350, GROUND_Y - 50, 'abb'),
            (1600, GROUND_Y - 50, 'thug'),
            (2100, GROUND_Y - 50, 'abb'),
        ]

        for x, y, etype in positions:
            self.enemies.append(Enemy(x, y, etype))

        self.lung = Lung(2350, GROUND_Y - 60)

    def update(self):
        if self.game_over:
            return

        self.frame += 1

        keys = {k: True for k in window.keysHeld.object_keys() if window.keysHeld[k]}
        key_pressed = {k: True for k in list(window.keysJustPressed)}
        window.keysJustPressed.splice(0, len(window.keysJustPressed))

        self.taylor.update(keys, key_pressed, self.structures)

        for bug in self.bugs:
            bug.update(self.taylor, self.structures)

        for enemy in self.enemies:
            enemy.update(self.taylor, self.structures)

        if self.lung and self.lung.alive:
            self.lung.update(self.taylor, self.structures)

        hitbox = self.taylor.get_attack_hitbox()
        if hitbox:
            hx, hy, hw, hh = hitbox
            for enemy in self.enemies:
                if enemy.alive and rect_intersect(hx, hy, hw, hh, enemy.x, enemy.y, enemy.w, enemy.h):
                    dmg = 14 if self.taylor.attack_type == 'sting' else 7
                    enemy.take_damage(dmg, self.taylor.attack_type)

            if self.lung and self.lung.alive:
                if rect_intersect(hx, hy, hw, hh, self.lung.x, self.lung.y, self.lung.w, self.lung.h):
                    dmg = 18 if self.taylor.attack_type == 'sting' else 9
                    self.lung.take_damage(dmg, self.taylor.attack_type)

        self.enemies = [e for e in self.enemies if e.alive]

        # Camera
        target_x = self.taylor.x - CANVAS_WIDTH // 2 + self.taylor.w // 2
        target_y = self.taylor.y - CANVAS_HEIGHT // 2 + self.taylor.h // 2
        self.camera_x = lerp(self.camera_x, target_x, 0.07)
        self.camera_y = lerp(self.camera_y, target_y, 0.07)
        self.camera_x = clamp(self.camera_x, 0, WORLD_WIDTH - CANVAS_WIDTH)
        self.camera_y = clamp(self.camera_y, 0, WORLD_HEIGHT - CANVAS_HEIGHT)

        window.uiState.taylorHp = (self.taylor.hp / self.taylor.max_hp) * 100
        if self.lung and self.lung.engaged:
            window.uiState.bossVisible = True
            window.uiState.bossHp = (self.lung.hp / self.lung.max_hp) * 100
        swarm = len([b for b in self.bugs if b.following])
        window.uiState.swarmCount = swarm

        if self.taylor.hp <= 0:
            self.game_over = True
        if self.lung and not self.lung.alive:
            self.victory = True
            self.game_over = True

    def render(self):
        ctx = self.ctx
        cx, cy = self.camera_x, self.camera_y

        # Sky gradient (not too dark)
        gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT)
        gradient.addColorStop(0, '#1a1a28')
        gradient.addColorStop(0.6, '#1e2030')
        gradient.addColorStop(1, '#252535')
        ctx.fillStyle = gradient
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

        # Moon
        ctx.fillStyle = '#3a3a50'
        ctx.beginPath()
        ctx.arc(700 - cx * 0.05, 60, 25, 0, math.pi * 2)
        ctx.fill()

        # Background warehouse walls
        for struct in self.bg_structures:
            struct.draw(ctx, cx * 0.5, cy * 0.5)

        # Ground
        ctx.fillStyle = '#353540'
        ctx.fillRect(-cx, GROUND_Y - cy, WORLD_WIDTH, 60)
        # Ground line
        ctx.fillStyle = '#454550'
        ctx.fillRect(-cx, GROUND_Y - cy, WORLD_WIDTH, 3)

        # Structures
        for struct in self.structures:
            struct.draw(ctx, cx, cy)

        # Control range indicator around Taylor
        tx = self.taylor.x + self.taylor.w/2 - cx
        ty = self.taylor.y + self.taylor.h/2 - cy

        # Outer ring (lose range)
        ctx.strokeStyle = 'rgba(100, 80, 60, 0.15)'
        ctx.lineWidth = 1
        ctx.setLineDash([4, 4])
        ctx.beginPath()
        ctx.arc(tx, ty, LOSE_RANGE, 0, math.pi * 2)
        ctx.stroke()

        # Inner ring (control range)
        ctx.strokeStyle = 'rgba(140, 120, 80, 0.25)'
        ctx.lineWidth = 2
        ctx.setLineDash([])
        ctx.beginPath()
        ctx.arc(tx, ty, CONTROL_RANGE, 0, math.pi * 2)
        ctx.stroke()

        # Bugs
        for bug in self.bugs:
            bug.draw(ctx, cx, cy, self.frame)

        # Enemies
        for enemy in self.enemies:
            if enemy.alive:
                enemy.draw(ctx, cx, cy)

        # Lung
        if self.lung and self.lung.alive:
            self.lung.draw(ctx, cx, cy, self.frame)

        # Taylor
        self.taylor.draw(ctx, cx, cy)

        # Game over
        if self.game_over:
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

            if self.victory:
                ctx.fillStyle = '#7a9a7a'
                ctx.font = '30px monospace'
                ctx.fillText('LUNG DEFEATED', CANVAS_WIDTH//2 - 110, CANVAS_HEIGHT//2 - 20)
                ctx.fillStyle = '#999'
                ctx.font = '13px monospace'
                ctx.fillText('The Undersiders arrive... Taylor escapes into the night.', CANVAS_WIDTH//2 - 195, CANVAS_HEIGHT//2 + 25)
            else:
                ctx.fillStyle = '#9a6060'
                ctx.font = '30px monospace'
                ctx.fillText('DEFEATED', CANVAS_WIDTH//2 - 65, CANVAS_HEIGHT//2)

    def game_loop(self, timestamp):
        self.update()
        self.render()
        requestAnimationFrame(create_proxy(self.game_loop))

# Start
game = Game()
requestAnimationFrame(create_proxy(game.game_loop))
`;

        main();
    </script>
</body>
</html>
