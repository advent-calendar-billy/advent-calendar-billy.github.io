<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duo Escape</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Press Start 2P', monospace;
            background: #0a0a0a;
            overflow: hidden;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .back-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 100, 100, 0.9);
            border: 3px solid #aa0000;
            border-radius: 8px;
            color: white;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            padding: 10px 20px;
            cursor: pointer;
            z-index: 1000;
        }
        .back-button:hover { background: rgba(255, 50, 50, 1); }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            border: 2px solid #444;
            border-radius: 8px;
            color: #888;
            font-size: 8px;
            padding: 10px 20px;
            text-align: center;
            z-index: 1000;
        }
        .blue { color: #4a9eff; }
        .red { color: #ff4a4a; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <button class="back-button" onclick="exitGame()">EXIT (ESC)</button>
    <div id="controls">
        <span class="blue">BLUE: WASD + Q(rope)</span> | <span class="red">RED: ARROWS + /(rope)</span> | R: Restart
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game dimensions (pixel art scale)
        const GAME_WIDTH = 320;
        const GAME_HEIGHT = 240;
        const SCALE = 3;

        canvas.width = GAME_WIDTH * SCALE;
        canvas.height = GAME_HEIGHT * SCALE;
        ctx.imageSmoothingEnabled = false;

        // Physics constants
        const GRAVITY = 0.25;
        const FRICTION = 0.75;
        const JUMP_FORCE = -5.5;
        const MOVE_SPEED = 1.5;
        const MAX_FALL_SPEED = 6;

        // Rope constants
        const ROPE_SPEED = 8;
        const ROPE_MAX_LENGTH = 120;
        const SWING_FORCE = 0.15;

        // Game state
        let gameState = 'menu'; // 'menu', 'playing', 'win', 'dead'
        let currentLevel = 0;
        let selectedLevel = 0;
        let deathTimer = 0;
        let winTimer = 0;

        // Keys
        const keys = {};
        const keysJustPressed = {};

        // Particles array
        let particles = [];

        // Levels definition
        const levels = [
            {
                name: "TEAMWORK",
                hint: "Stack up! Bottom player's jump boosts the top.",
                platforms: [
                    { x: 0, y: 200, w: 320, h: 40 },
                    { x: 200, y: 105, w: 120, h: 15 },
                ],
                hazards: [],
                anchors: [], // Rope anchor points
                exit: { x: 270, y: 75, w: 20, h: 30 },
                player1Start: { x: 50, y: 170 },
                player2Start: { x: 100, y: 170 },
            },
            {
                name: "THE CHASM",
                hint: "Use ropes to swing across! Q for Blue, / for Red.",
                platforms: [
                    { x: 0, y: 180, w: 80, h: 60 },
                    { x: 240, y: 180, w: 80, h: 60 },
                ],
                hazards: [
                    { x: 80, y: 220, w: 160, h: 20, type: 'spike' },
                ],
                anchors: [
                    { x: 120, y: 40 },
                    { x: 200, y: 40 },
                ],
                exit: { x: 270, y: 150, w: 20, h: 30 },
                player1Start: { x: 20, y: 150 },
                player2Start: { x: 50, y: 150 },
            },
            {
                name: "LASER MAZE",
                hint: "Time your moves! One can distract while other advances.",
                platforms: [
                    { x: 0, y: 200, w: 90, h: 40 },
                    { x: 115, y: 200, w: 90, h: 40 },
                    { x: 230, y: 200, w: 90, h: 40 },
                    { x: 230, y: 130, w: 90, h: 15 },
                ],
                hazards: [
                    { x: 90, y: 160, w: 8, h: 40, type: 'laser' },
                    { x: 205, y: 160, w: 8, h: 40, type: 'laser' },
                ],
                anchors: [],
                exit: { x: 280, y: 100, w: 20, h: 30 },
                player1Start: { x: 30, y: 170 },
                player2Start: { x: 60, y: 170 },
            },
            {
                name: "ROPE CLIMB",
                hint: "Swing from anchor to anchor to reach the top!",
                platforms: [
                    { x: 0, y: 200, w: 100, h: 40 },
                    { x: 260, y: 60, w: 60, h: 15 },
                ],
                hazards: [
                    { x: 100, y: 220, w: 160, h: 20, type: 'spike' },
                ],
                anchors: [
                    { x: 80, y: 100 },
                    { x: 160, y: 60 },
                    { x: 240, y: 100 },
                ],
                exit: { x: 280, y: 30, w: 20, h: 30 },
                player1Start: { x: 30, y: 170 },
                player2Start: { x: 60, y: 170 },
            },
            {
                name: "COOPERATION",
                hint: "One stays low to be a platform, other goes high!",
                platforms: [
                    { x: 0, y: 200, w: 120, h: 40 },
                    { x: 200, y: 200, w: 120, h: 40 },
                    { x: 140, y: 140, w: 40, h: 10 },
                    { x: 200, y: 80, w: 120, h: 15 },
                ],
                hazards: [
                    { x: 120, y: 220, w: 80, h: 20, type: 'spike' },
                ],
                anchors: [
                    { x: 160, y: 50 },
                ],
                exit: { x: 280, y: 50, w: 20, h: 30 },
                player1Start: { x: 30, y: 170 },
                player2Start: { x: 60, y: 170 },
            },
        ];

        // Rope class
        class Rope {
            constructor(owner) {
                this.owner = owner;
                this.active = false;
                this.attached = false;
                this.anchorX = 0;
                this.anchorY = 0;
                this.length = 0;
                this.angle = 0;
                this.angleVel = 0;
                this.tipX = 0;
                this.tipY = 0;
                this.shooting = false;
                this.dirX = 0;
                this.dirY = 0;
            }

            shoot(targetX, targetY) {
                if (this.active) {
                    this.release();
                    return;
                }

                const dx = targetX - (this.owner.x + this.owner.w / 2);
                const dy = targetY - (this.owner.y + this.owner.h / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                this.dirX = dx / dist;
                this.dirY = dy / dist;
                this.tipX = this.owner.x + this.owner.w / 2;
                this.tipY = this.owner.y + this.owner.h / 2;
                this.shooting = true;
                this.active = true;
                this.attached = false;
                this.length = 0;
            }

            shootToNearest() {
                const level = levels[currentLevel];
                if (!level.anchors || level.anchors.length === 0) return;

                let nearest = null;
                let nearestDist = Infinity;
                const px = this.owner.x + this.owner.w / 2;
                const py = this.owner.y + this.owner.h / 2;

                for (const anchor of level.anchors) {
                    const dx = anchor.x - px;
                    const dy = anchor.y - py;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist && dist < ROPE_MAX_LENGTH) {
                        nearestDist = dist;
                        nearest = anchor;
                    }
                }

                if (nearest) {
                    this.shoot(nearest.x, nearest.y);
                }
            }

            release() {
                if (this.attached) {
                    // Give player momentum when releasing
                    this.owner.vx = this.angleVel * this.length * 0.15;
                    this.owner.vy = -Math.abs(this.angleVel) * this.length * 0.08 - 2;
                }
                this.active = false;
                this.attached = false;
                this.shooting = false;
            }

            update() {
                if (!this.active) return;

                if (this.shooting) {
                    // Rope tip moving towards anchor
                    this.tipX += this.dirX * ROPE_SPEED;
                    this.tipY += this.dirY * ROPE_SPEED;
                    this.length += ROPE_SPEED;

                    // Check if hit an anchor
                    const level = levels[currentLevel];
                    for (const anchor of level.anchors) {
                        const dx = this.tipX - anchor.x;
                        const dy = this.tipY - anchor.y;
                        if (Math.sqrt(dx * dx + dy * dy) < 15) {
                            // Attached!
                            this.attached = true;
                            this.shooting = false;
                            this.anchorX = anchor.x;
                            this.anchorY = anchor.y;

                            // Calculate initial angle
                            const px = this.owner.x + this.owner.w / 2;
                            const py = this.owner.y + this.owner.h / 2;
                            this.angle = Math.atan2(px - this.anchorX, py - this.anchorY);
                            this.length = Math.sqrt((px - this.anchorX) ** 2 + (py - this.anchorY) ** 2);
                            this.angleVel = this.owner.vx * 0.02;
                            return;
                        }
                    }

                    // Check if hit platform (rope fails)
                    for (const p of level.platforms) {
                        if (this.tipX > p.x && this.tipX < p.x + p.w &&
                            this.tipY > p.y && this.tipY < p.y + p.h) {
                            this.active = false;
                            this.shooting = false;
                            return;
                        }
                    }

                    // Max length reached
                    if (this.length > ROPE_MAX_LENGTH) {
                        this.active = false;
                        this.shooting = false;
                    }
                } else if (this.attached) {
                    // Pendulum physics
                    const gravity = 0.015;
                    this.angleVel += Math.sin(this.angle) * gravity;

                    // Player input affects swing
                    if (keys[this.owner.controls.left]) {
                        this.angleVel -= SWING_FORCE * 0.02;
                    }
                    if (keys[this.owner.controls.right]) {
                        this.angleVel += SWING_FORCE * 0.02;
                    }

                    this.angleVel *= 0.995; // Damping
                    this.angle += this.angleVel;

                    // Update player position
                    this.owner.x = this.anchorX + Math.sin(this.angle) * this.length - this.owner.w / 2;
                    this.owner.y = this.anchorY + Math.cos(this.angle) * this.length - this.owner.h / 2;
                    this.owner.vx = 0;
                    this.owner.vy = 0;
                    this.owner.grounded = false;
                }
            }

            draw() {
                if (!this.active) return;

                const px = this.owner.x + this.owner.w / 2;
                const py = this.owner.y + this.owner.h / 2;

                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(px, py);

                if (this.shooting) {
                    ctx.lineTo(this.tipX, this.tipY);
                } else if (this.attached) {
                    ctx.lineTo(this.anchorX, this.anchorY);
                }
                ctx.stroke();

                // Rope end
                if (this.shooting) {
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(this.tipX, this.tipY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Player class
        class Player {
            constructor(x, y, color, controls) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.w = 14;
                this.h = 20;
                this.vx = 0;
                this.vy = 0;
                this.color = color;
                this.controls = controls;
                this.grounded = false;
                this.alive = true;
                this.facingRight = true;
                this.walkFrame = 0;
                this.walkTimer = 0;
                this.onPlayer = null;
                this.carrying = null;
                this.rope = new Rope(this);
                this.respawnTimer = 0;
            }

            reset(startX, startY) {
                this.startX = startX || this.startX;
                this.startY = startY || this.startY;
                this.x = this.startX;
                this.y = this.startY;
                this.vx = 0;
                this.vy = 0;
                this.grounded = false;
                this.alive = true;
                this.onPlayer = null;
                this.carrying = null;
                this.rope.active = false;
                this.rope.attached = false;
                this.rope.shooting = false;
                this.respawnTimer = 0;
            }

            update(other) {
                // Handle respawn
                if (!this.alive) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0 && other && other.alive) {
                        // Respawn near the other player
                        this.alive = true;
                        this.x = other.x + (Math.random() > 0.5 ? 20 : -20);
                        this.y = other.y - 30;
                        this.vx = 0;
                        this.vy = 0;
                        // Respawn particles
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(
                                this.x + this.w / 2,
                                this.y + this.h / 2,
                                (Math.random() - 0.5) * 3,
                                (Math.random() - 0.5) * 3,
                                '#ffffff',
                                30
                            ));
                        }
                    }
                    return;
                }

                // Rope controls
                if (keysJustPressed[this.controls.rope]) {
                    if (this.rope.active) {
                        this.rope.release();
                    } else {
                        this.rope.shootToNearest();
                    }
                }

                // Update rope
                this.rope.update();

                // If attached to rope, skip normal movement
                if (this.rope.attached) {
                    this.checkHazards();
                    this.checkExit();
                    return;
                }

                // Input
                let moveDir = 0;
                if (keys[this.controls.left]) moveDir = -1;
                if (keys[this.controls.right]) moveDir = 1;

                if (moveDir !== 0) {
                    this.vx += moveDir * 0.3;
                    this.facingRight = moveDir > 0;
                    this.walkTimer++;
                    if (this.walkTimer > 8) {
                        this.walkTimer = 0;
                        this.walkFrame = (this.walkFrame + 1) % 2;
                    }
                } else {
                    this.walkFrame = 0;
                }

                // Apply friction
                this.vx *= FRICTION;

                // Cap horizontal speed
                if (Math.abs(this.vx) > MOVE_SPEED) {
                    this.vx = Math.sign(this.vx) * MOVE_SPEED;
                }
                if (Math.abs(this.vx) < 0.1) this.vx = 0;

                // Jump
                if (keys[this.controls.jump] && this.grounded) {
                    this.vy = JUMP_FORCE;
                    this.grounded = false;

                    // If carrying someone, give them extra upward velocity (big boost!)
                    if (this.carrying && this.carrying.alive) {
                        this.carrying.vy = JUMP_FORCE * 1.2;
                        this.carrying.grounded = false;
                    }

                    // Jump particles
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(
                            this.x + this.w / 2,
                            this.y + this.h,
                            (Math.random() - 0.5) * 2,
                            -Math.random() * 2,
                            '#888',
                            20
                        ));
                    }
                }

                // Gravity
                this.vy += GRAVITY;
                if (this.vy > MAX_FALL_SPEED) this.vy = MAX_FALL_SPEED;

                // Clear standing relationship before collision check
                this.onPlayer = null;
                if (this.carrying) {
                    this.carrying.onPlayer = null;
                    this.carrying = null;
                }

                // Move and collide
                this.x += this.vx;
                this.collideX();

                this.grounded = false;
                this.y += this.vy;
                this.collideY();

                // Player-to-player collision
                if (other && other.alive && !other.rope.attached) {
                    this.collideWithPlayer(other);
                }

                // Check hazards
                this.checkHazards();

                // Check exit
                this.checkExit();
            }

            collideX() {
                const level = levels[currentLevel];
                for (const p of level.platforms) {
                    if (this.x < p.x + p.w && this.x + this.w > p.x &&
                        this.y < p.y + p.h && this.y + this.h > p.y) {
                        if (this.vx > 0) {
                            this.x = p.x - this.w;
                        } else if (this.vx < 0) {
                            this.x = p.x + p.w;
                        }
                        this.vx = 0;
                    }
                }
                // World bounds
                if (this.x < 0) this.x = 0;
                if (this.x + this.w > GAME_WIDTH) this.x = GAME_WIDTH - this.w;
            }

            collideY() {
                const level = levels[currentLevel];
                for (const p of level.platforms) {
                    if (this.x < p.x + p.w && this.x + this.w > p.x &&
                        this.y < p.y + p.h && this.y + this.h > p.y) {
                        if (this.vy > 0) {
                            this.y = p.y - this.h;
                            this.grounded = true;
                        } else if (this.vy < 0) {
                            this.y = p.y + p.h;
                        }
                        this.vy = 0;
                    }
                }
                // Fall off bottom = death
                if (this.y > GAME_HEIGHT + 20) {
                    this.die();
                }
            }

            collideWithPlayer(other) {
                // Check overlap
                if (this.x < other.x + other.w && this.x + this.w > other.x &&
                    this.y < other.y + other.h && this.y + this.h > other.y) {

                    // Determine collision direction
                    const overlapX = Math.min(this.x + this.w, other.x + other.w) - Math.max(this.x, other.x);
                    const overlapY = Math.min(this.y + this.h, other.y + other.h) - Math.max(this.y, other.y);

                    if (overlapY < overlapX) {
                        // Vertical collision
                        if (this.y < other.y) {
                            // This player is on top of other
                            this.y = other.y - this.h;
                            if (this.vy > 0) {
                                this.vy = 0;
                                this.grounded = true;
                                this.onPlayer = other;
                                other.carrying = this;
                            }
                        } else {
                            // This player is below other
                            this.y = other.y + other.h;
                            if (this.vy < 0) {
                                this.vy = 0;
                            }
                        }
                    } else {
                        // Horizontal collision - push apart
                        if (this.x < other.x) {
                            this.x = other.x - this.w;
                            other.x = this.x + this.w;
                        } else {
                            this.x = other.x + other.w;
                            other.x = this.x - other.w;
                        }
                        // Share velocity
                        const avgVx = (this.vx + other.vx) * 0.5;
                        this.vx = avgVx;
                        other.vx = avgVx;
                    }
                }
            }

            checkHazards() {
                const level = levels[currentLevel];
                for (const h of level.hazards) {
                    if (this.x < h.x + h.w && this.x + this.w > h.x &&
                        this.y < h.y + h.h && this.y + this.h > h.y) {
                        this.die();
                    }
                }
            }

            checkExit() {
                const level = levels[currentLevel];
                const e = level.exit;
                const cx = this.x + this.w / 2;
                const cy = this.y + this.h / 2;
                if (cx > e.x && cx < e.x + e.w && cy > e.y && cy < e.y + e.h) {
                    gameState = 'win';
                    // Win particles
                    for (let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        particles.push(new Particle(
                            e.x + e.w / 2,
                            e.y + e.h / 2,
                            Math.cos(angle) * (2 + Math.random() * 3),
                            Math.sin(angle) * (2 + Math.random() * 3),
                            ['#ffff00', '#00ff00', '#00ffff', '#ff00ff'][Math.floor(Math.random() * 4)],
                            60
                        ));
                    }
                }
            }

            die() {
                if (!this.alive) return;
                this.alive = false;
                this.rope.release();
                this.respawnTimer = 90; // Respawn after 1.5 seconds

                // EXPLOSION OF PARTICLES!
                const colors = this.color === '#4a9eff'
                    ? ['#4a9eff', '#2a7edf', '#0a5ebf', '#ffffff', '#88ccff']
                    : ['#ff4a4a', '#df2a2a', '#bf0a0a', '#ffffff', '#ff8888'];

                for (let i = 0; i < 80; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 5;
                    particles.push(new Particle(
                        this.x + this.w / 2,
                        this.y + this.h / 2,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed - 2,
                        colors[Math.floor(Math.random() * colors.length)],
                        40 + Math.random() * 40
                    ));
                }

                // Body chunks (larger particles)
                for (let i = 0; i < 12; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    particles.push(new Particle(
                        this.x + this.w / 2,
                        this.y + this.h / 2,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed - 3,
                        colors[0],
                        60 + Math.random() * 30,
                        true // large
                    ));
                }
            }

            draw() {
                if (!this.alive) return;

                // Draw rope first (behind player)
                this.rope.draw();

                ctx.save();
                const px = Math.floor(this.x);
                const py = Math.floor(this.y);

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(px + 1, py + this.h - 2, this.w - 2, 3);

                // Body
                ctx.fillStyle = this.color;
                ctx.fillRect(px + 2, py + 8, 10, 10);

                // Head
                const darker = this.color === '#4a9eff' ? '#2a6edf' : '#df2a2a';
                ctx.fillStyle = this.color;
                ctx.fillRect(px + 3, py, 8, 9);

                // Eyes
                ctx.fillStyle = '#ffffff';
                if (this.facingRight) {
                    ctx.fillRect(px + 7, py + 3, 3, 3);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(px + 8, py + 4, 2, 2);
                } else {
                    ctx.fillRect(px + 4, py + 3, 3, 3);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(px + 4, py + 4, 2, 2);
                }

                // Legs
                ctx.fillStyle = darker;
                if (this.walkFrame === 0 || !this.grounded) {
                    ctx.fillRect(px + 3, py + 17, 3, 4);
                    ctx.fillRect(px + 8, py + 17, 3, 4);
                } else {
                    ctx.fillRect(px + 2, py + 17, 3, 4);
                    ctx.fillRect(px + 9, py + 17, 3, 4);
                }

                // Arms
                ctx.fillStyle = this.color;
                if (this.walkFrame === 0) {
                    ctx.fillRect(px, py + 9, 2, 5);
                    ctx.fillRect(px + 12, py + 9, 2, 5);
                } else {
                    ctx.fillRect(px, py + 8, 2, 5);
                    ctx.fillRect(px + 12, py + 10, 2, 5);
                }

                // Rope indicator if on rope
                if (this.rope.attached) {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(px + 5, py - 3, 4, 3);
                }

                ctx.restore();
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color, life, large = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.large = large;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.15; // gravity
                this.vx *= 0.98;
                this.life--;

                // Bounce off floor
                if (this.y > GAME_HEIGHT - 5) {
                    this.y = GAME_HEIGHT - 5;
                    this.vy = -this.vy * 0.5;
                    this.vx *= 0.8;
                }

                return this.life > 0;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;

                const size = this.large ? 3 + Math.random() : 1 + Math.random();
                ctx.fillRect(
                    Math.floor(this.x - size / 2),
                    Math.floor(this.y - size / 2),
                    Math.ceil(size),
                    Math.ceil(size)
                );
                ctx.globalAlpha = 1;
            }
        }

        // Create players
        let player1, player2;

        function initLevel(levelIndex) {
            currentLevel = levelIndex;
            const level = levels[currentLevel];
            player1 = new Player(
                level.player1Start.x,
                level.player1Start.y,
                '#4a9eff',
                { left: 'a', right: 'd', jump: 'w', rope: 'q' }
            );
            player2 = new Player(
                level.player2Start.x,
                level.player2Start.y,
                '#ff4a4a',
                { left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp', rope: '/' }
            );
            particles = [];
            gameState = 'playing';
        }

        // Input
        document.addEventListener('keydown', (e) => {
            if (!keys[e.key]) {
                keysJustPressed[e.key] = true;
            }
            keys[e.key] = true;

            if (e.key === 'Escape') {
                if (gameState === 'playing' || gameState === 'win' || gameState === 'dead') {
                    gameState = 'menu';
                } else {
                    exitGame();
                }
            }

            if (gameState === 'menu') {
                if (e.key === 'ArrowUp' || e.key === 'w') {
                    selectedLevel = (selectedLevel - 1 + levels.length) % levels.length;
                }
                if (e.key === 'ArrowDown' || e.key === 's') {
                    selectedLevel = (selectedLevel + 1) % levels.length;
                }
                if (e.key === 'Enter' || e.key === ' ') {
                    initLevel(selectedLevel);
                }
            } else if (gameState === 'playing') {
                if (e.key === 'r' || e.key === 'R') {
                    initLevel(currentLevel);
                }
            } else if (gameState === 'win') {
                if (e.key === ' ' || e.key === 'Enter') {
                    if (currentLevel < levels.length - 1) {
                        initLevel(currentLevel + 1);
                    } else {
                        gameState = 'menu';
                    }
                }
            } else if (gameState === 'dead') {
                if (e.key === ' ' || e.key === 'Enter') {
                    initLevel(currentLevel);
                }
            }

            // Prevent scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function exitGame() {
            if (window.parent && window.parent !== window) {
                window.parent.postMessage('closeMinigame', '*');
            } else {
                window.history.back();
            }
        }

        // Render functions
        function drawPlatform(p) {
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = '#5a5a5a';
            ctx.fillRect(p.x, p.y, p.w, 3);
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(p.x, p.y, 3, p.h);
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(p.x + p.w - 3, p.y, 3, p.h);
            ctx.fillRect(p.x, p.y + p.h - 3, p.w, 3);
            ctx.fillStyle = '#333';
            for (let gx = p.x + 8; gx < p.x + p.w - 4; gx += 8) {
                for (let gy = p.y + 8; gy < p.y + p.h - 4; gy += 8) {
                    ctx.fillRect(gx, gy, 2, 2);
                }
            }
        }

        function drawHazard(h) {
            if (h.type === 'spike') {
                ctx.fillStyle = '#ff3333';
                const spikeWidth = 8;
                for (let sx = h.x; sx < h.x + h.w; sx += spikeWidth) {
                    ctx.beginPath();
                    ctx.moveTo(sx, h.y + h.h);
                    ctx.lineTo(sx + spikeWidth / 2, h.y);
                    ctx.lineTo(sx + spikeWidth, h.y + h.h);
                    ctx.closePath();
                    ctx.fill();
                }
            } else if (h.type === 'laser') {
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.fillRect(h.x, h.y, h.w, h.h);
                ctx.fillStyle = '#ff8888';
                ctx.fillRect(h.x + 2, h.y, h.w - 4, h.h);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(h.x + 3, h.y, h.w - 6, h.h);
                ctx.fillStyle = '#444';
                ctx.fillRect(h.x - 2, h.y - 5, h.w + 4, 8);
                ctx.fillRect(h.x - 2, h.y + h.h - 3, h.w + 4, 8);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(h.x, h.y - 3, h.w, 4);
                ctx.fillRect(h.x, h.y + h.h - 1, h.w, 4);
            }
        }

        function drawAnchor(a) {
            // Glow
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(139, 69, 19, ${pulse * 0.3})`;
            ctx.beginPath();
            ctx.arc(a.x, a.y, 12, 0, Math.PI * 2);
            ctx.fill();

            // Ring
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(a.x, a.y, 8, 0, Math.PI * 2);
            ctx.stroke();

            // Center
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.arc(a.x, a.y, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawExit(e) {
            ctx.fillStyle = '#228822';
            ctx.fillRect(e.x - 3, e.y - 3, e.w + 6, e.h + 6);
            ctx.fillStyle = '#44ff44';
            ctx.fillRect(e.x, e.y, e.w, e.h);
            const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.5;
            ctx.fillStyle = `rgba(100, 255, 100, ${pulse})`;
            ctx.fillRect(e.x - 5, e.y - 5, e.w + 10, e.h + 10);
            ctx.fillStyle = '#ffffff';
            const arrowY = e.y + e.h / 2 - 4 + Math.sin(Date.now() / 300) * 2;
            ctx.beginPath();
            ctx.moveTo(e.x + 4, arrowY);
            ctx.lineTo(e.x + e.w / 2, arrowY - 5);
            ctx.lineTo(e.x + e.w / 2, arrowY - 2);
            ctx.lineTo(e.x + e.w - 4, arrowY - 2);
            ctx.lineTo(e.x + e.w - 4, arrowY + 5);
            ctx.lineTo(e.x + e.w / 2, arrowY + 5);
            ctx.lineTo(e.x + e.w / 2, arrowY + 8);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.font = '4px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('EXIT', e.x + e.w / 2, e.y - 6);
        }

        function drawBackground() {
            const grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            grad.addColorStop(0, '#1a1a2e');
            grad.addColorStop(1, '#0f0f1a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.strokeStyle = '#222233';
            ctx.lineWidth = 1;
            for (let x = 0; x < GAME_WIDTH; x += 16) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, GAME_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y < GAME_HEIGHT; y += 16) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(GAME_WIDTH, y);
                ctx.stroke();
            }
        }

        function drawUI() {
            const level = levels[currentLevel];
            ctx.fillStyle = '#666';
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.fillText(`LVL ${currentLevel + 1}: ${level.name}`, 5, 12);

            // Hint
            ctx.fillStyle = '#444';
            ctx.font = '4px "Press Start 2P"';
            ctx.fillText(level.hint, 5, 22);

            // Player status
            ctx.fillStyle = player1.alive ? '#4a9eff' : '#333';
            ctx.fillRect(GAME_WIDTH - 30, 5, 8, 8);
            ctx.fillStyle = player2.alive ? '#ff4a4a' : '#333';
            ctx.fillRect(GAME_WIDTH - 18, 5, 8, 8);
        }

        function drawMenu() {
            drawBackground();

            // Title
            ctx.fillStyle = '#fff';
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('DUO ESCAPE', GAME_WIDTH / 2, 40);

            ctx.fillStyle = '#888';
            ctx.font = '6px "Press Start 2P"';
            ctx.fillText('Two players, one goal', GAME_WIDTH / 2, 55);

            // Level list
            ctx.font = '8px "Press Start 2P"';
            const startY = 80;
            const lineHeight = 20;

            for (let i = 0; i < levels.length; i++) {
                const y = startY + i * lineHeight;

                if (i === selectedLevel) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(40, y - 10, GAME_WIDTH - 80, 16);
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText('>', 50, y);
                } else {
                    ctx.fillStyle = '#666';
                }

                ctx.textAlign = 'left';
                ctx.fillText(`${i + 1}. ${levels[i].name}`, 65, y);
            }

            // Instructions
            ctx.fillStyle = '#555';
            ctx.font = '5px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('UP/DOWN to select, ENTER to start', GAME_WIDTH / 2, GAME_HEIGHT - 30);
            ctx.fillText('ESC to return to menu', GAME_WIDTH / 2, GAME_HEIGHT - 20);
        }

        function drawDeathScreen() {
            ctx.fillStyle = 'rgba(50, 0, 0, 0.7)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = '#ff4444';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('BOTH DESTROYED!', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
            ctx.fillStyle = '#888';
            ctx.font = '6px "Press Start 2P"';
            ctx.fillText('Press SPACE to retry', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 15);
            ctx.fillText('Press ESC for menu', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 28);
        }

        function drawWinScreen() {
            ctx.fillStyle = 'rgba(0, 50, 0, 0.7)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = '#44ff44';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('ESCAPED!', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
            ctx.fillStyle = '#888';
            ctx.font = '6px "Press Start 2P"';
            if (currentLevel < levels.length - 1) {
                ctx.fillText('Press SPACE for next level', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 15);
            } else {
                ctx.fillStyle = '#ffff00';
                ctx.fillText('ALL LEVELS COMPLETE!', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 15);
            }
            ctx.fillStyle = '#888';
            ctx.fillText('Press ESC for menu', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 28);
        }

        // Game loop
        function update() {
            // Clear just-pressed keys at end of frame

            if (gameState === 'playing') {
                player1.update(player2);
                player2.update(player1);

                // Check if both dead = game over
                if (!player1.alive && !player2.alive) {
                    gameState = 'dead';
                    deathTimer = 60;
                }
            }

            // Update particles
            particles = particles.filter(p => p.update());

            // Clear just pressed
            for (const key in keysJustPressed) {
                keysJustPressed[key] = false;
            }
        }

        function render() {
            ctx.save();
            ctx.scale(SCALE, SCALE);

            if (gameState === 'menu') {
                drawMenu();
            } else {
                const level = levels[currentLevel];
                drawBackground();
                drawExit(level.exit);

                // Draw anchors
                for (const a of level.anchors) {
                    drawAnchor(a);
                }

                for (const p of level.platforms) {
                    drawPlatform(p);
                }
                for (const h of level.hazards) {
                    drawHazard(h);
                }
                player1.draw();
                player2.draw();
                for (const p of particles) {
                    p.draw();
                }
                drawUI();

                if (gameState === 'dead') {
                    drawDeathScreen();
                }
                if (gameState === 'win') {
                    drawWinScreen();
                }
            }

            ctx.restore();
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
