<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Departamento</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'VT323', monospace;
            overflow: hidden;
        }

        #gameWrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        #versionNumber {
            position: absolute;
            bottom: 4px;
            right: 8px;
            font-size: 10px;
            color: #444;
            font-family: 'VT323', monospace;
            pointer-events: none;
        }

        #gameContainer {
            position: relative;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* CRT Overlay */
        #crtOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            background:
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.15) 0px,
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 1px,
                    transparent 2px
                );
        }

        /* Vignette */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 51;
            box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.9),
                        inset 0 0 80px rgba(0, 0, 0, 0.6);
            border-radius: 8px;
        }

        /* Screen flicker effect */
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
            96% { opacity: 0.9; }
            97% { opacity: 1; }
        }

        #gameCanvas.flicker {
            animation: flicker 8s infinite;
        }

        /* Screen transition */
        @keyframes screenFade {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }

        #gameContainer.transitioning #gameCanvas {
            animation: screenFade 0.4s ease-in-out;
        }

        #hud {
            position: absolute;
            top: 12px;
            right: 12px;
            pointer-events: none;
            z-index: 10;
        }

        #bottomHud {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 12px;
            pointer-events: none;
        }

        .equipped-item {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #3a5a4a;
            border-radius: 4px;
            padding: 8px 12px;
            color: #7a9a8a;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5),
                        inset 0 0 10px rgba(58, 90, 74, 0.2);
        }

        .equipped-label {
            color: #4a6a5a;
            font-size: 12px;
        }

        #equippedIcon {
            width: 24px;
            height: 24px;
            background: #2a3a2e;
            border: 1px solid #4a6a5a;
            border-radius: 2px;
        }

        /* Minimap */
        #minimap {
            width: 80px;
            height: 100px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #3a5a4a;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5),
                        inset 0 0 10px rgba(58, 90, 74, 0.2);
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }

        #dialogueBox {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #5a7a6a;
            border-radius: 4px;
            padding: 14px 24px;
            color: #a0c0b0;
            font-size: 18px;
            max-width: 500px;
            text-align: center;
            display: none;
            z-index: 20;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8),
                        0 0 10px rgba(90, 122, 106, 0.3);
            letter-spacing: 1px;
        }

        #telegramPopup {
            position: fixed;
            top: 80px;
            left: calc(50% + 200px);
            background: linear-gradient(180deg, #1a2a3f 0%, #0f1a28 100%);
            border: 2px solid #0088cc;
            border-radius: 8px;
            padding: 12px 14px;
            color: #fff;
            font-size: 14px;
            max-width: 220px;
            display: none;
            z-index: 400;
            box-shadow: 0 4px 30px rgba(0, 136, 204, 0.4),
                        0 0 60px rgba(0, 136, 204, 0.2);
            animation: telegramSlide 0.3s ease-out;
        }

        @keyframes telegramSlide {
            from {
                transform: translateX(100px) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        .telegram-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #0088cc44;
        }

        .telegram-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #0088cc, #00aaff);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .telegram-name {
            color: #0088cc;
            font-weight: bold;
            font-size: 16px;
        }

        .telegram-message {
            color: #ddd;
            line-height: 1.5;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .telegram-response {
            color: #88ccff;
            font-size: 13px;
            text-align: right;
            font-style: italic;
            padding-top: 6px;
            border-top: 1px solid #0088cc22;
        }

        .telegram-silent {
            margin-left: auto;
            font-size: 14px;
            opacity: 0.7;
            display: none;
        }

        .telegram-silent.active {
            display: block;
        }

        /* Phone Animation Overlay */
        #phoneAnimationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 450;
        }

        #phoneAnimationCanvas {
            image-rendering: pixelated;
        }

        #inventoryOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .inventory-title {
            color: #7a9a8a;
            font-size: 24px;
            margin-bottom: 24px;
            letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(122, 154, 138, 0.5);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            gap: 12px;
        }

        .inventory-slot {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, #1a2a24, #0f1a14);
            border: 2px solid #3a5a4a;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            padding: 6px;
            position: relative;
            overflow: hidden;
        }

        .inventory-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, rgba(255,255,255,0.05), transparent);
            pointer-events: none;
        }

        .inventory-slot:hover {
            border-color: #5a8a7a;
            background: linear-gradient(145deg, #2a3a34, #1a2a24);
            transform: scale(1.05);
        }

        .inventory-slot.selected {
            border-color: #ffaa00;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.4),
                        inset 0 0 15px rgba(255, 170, 0, 0.1);
        }

        .inventory-slot canvas {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
        }

        .inventory-slot .item-name {
            font-size: 11px;
            color: #7a9a8a;
            margin-top: 4px;
            text-align: center;
        }

        .inventory-hint {
            color: #4a6a5a;
            font-size: 14px;
            margin-top: 24px;
            letter-spacing: 1px;
        }

        /* Combination Lock */
        #combinationLockOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 110;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #combinationLockOverlay.active {
            display: flex;
        }

        .lock-title {
            color: #888;
            font-size: 20px;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }

        .lock-container {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            padding: 30px 40px;
            border-radius: 8px;
            border: 3px solid #555;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5),
                        inset 0 2px 0 rgba(255, 255, 255, 0.1);
        }

        .lock-digits {
            display: flex;
            gap: 12px;
        }

        .lock-digit {
            width: 50px;
            height: 70px;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .lock-digit.selected {
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.4);
        }

        .lock-digit::before,
        .lock-digit::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            opacity: 0.5;
        }

        .lock-digit::before {
            top: -15px;
            border-bottom: 10px solid #666;
        }

        .lock-digit::after {
            bottom: -15px;
            border-top: 10px solid #666;
        }

        .lock-digit.selected::before {
            border-bottom-color: #ffaa00;
            opacity: 1;
        }

        .lock-digit.selected::after {
            border-top-color: #ffaa00;
            opacity: 1;
        }

        .lock-hint {
            color: #555;
            font-size: 12px;
            margin-top: 30px;
            letter-spacing: 1px;
        }

        .lock-error {
            color: #ff4444;
            font-size: 14px;
            margin-top: 15px;
            height: 20px;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-10px); }
            80% { transform: translateX(10px); }
        }

        #interactHint {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%) scale(0.9);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffaa00;
            border-radius: 4px;
            padding: 8px 16px;
            color: #ffcc44;
            font-size: 14px;
            display: none;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.3);
        }

        #interactHint.visible {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

        .controls-info {
            position: absolute;
            bottom: 10px;
            left: 12px;
            color: #2a3a34;
            font-size: 12px;
            pointer-events: none;
            letter-spacing: 1px;
        }

        /* Location indicator */
        #locationIndicator {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #3a5a4a;
            border-radius: 4px;
            padding: 6px 16px;
            color: #5a7a6a;
            font-size: 14px;
            letter-spacing: 2px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #locationIndicator.visible {
            opacity: 1;
        }

        /* TV Overlay */
        #tvOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .tv-frame {
            background: #1a1a1a;
            border: 8px solid #2a2a2a;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 0 40px rgba(0, 100, 150, 0.3),
                        inset 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        #tvScreen {
            display: block;
            border-radius: 4px;
            image-rendering: pixelated;
        }

        .tv-channel-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            padding: 4px 10px;
            font-size: 16px;
            border-radius: 4px;
            font-family: 'VT323', monospace;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tv-channel-indicator.visible {
            opacity: 1;
        }

        .tv-controls {
            display: flex;
            gap: 30px;
            margin-top: 16px;
            color: #4a6a5a;
            font-size: 14px;
        }

        /* Piano Overlay */
        #pianoOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .piano-title {
            color: #8a7a6a;
            font-size: 18px;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .piano-container {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            padding: 20px 30px 30px;
            border-radius: 8px;
            border: 3px solid #3a3a3a;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .piano-keys {
            display: flex;
            position: relative;
            height: 160px;
        }

        .piano-key {
            width: 36px;
            height: 150px;
            background: linear-gradient(180deg, #f5f5f5 0%, #e8e8e8 90%, #d0d0d0 100%);
            border: 1px solid #888;
            border-radius: 0 0 4px 4px;
            margin-right: 2px;
            cursor: pointer;
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.05s;
        }

        .piano-key:last-child {
            margin-right: 0;
        }

        .piano-key.active {
            background: linear-gradient(180deg, #ddd 0%, #ccc 90%, #bbb 100%);
            transform: translateY(2px);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);
        }

        .piano-key .key-label {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
        }

        .piano-key-black {
            width: 24px;
            height: 95px;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 90%, #0a0a0a 100%);
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            position: absolute;
            z-index: 1;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            transition: all 0.05s;
        }

        .piano-key-black.active {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 90%, #1a1a1a 100%);
            transform: translateY(2px);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.5);
        }

        .piano-key-black .key-label {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 10px;
        }

        .piano-controls {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            color: #5a6a5a;
            font-size: 13px;
        }

        .piano-hint {
            color: #4a5a4a;
            font-size: 11px;
            margin-top: 10px;
        }

        /* ============ HIDING OVERLAY ============ */
        #hidingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            animation: fadeIn 2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .hiding-darkness {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0808 0%, #000 100%);
        }

        .hiding-text {
            color: #4a4040;
            font-size: 18px;
            z-index: 1;
            animation: pulse 3s ease-in-out infinite;
            text-align: center;
            line-height: 1.4;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .hiding-hint {
            color: #3a3030;
            font-size: 12px;
            margin-top: 30px;
            z-index: 1;
        }

        /* ============ ENDING OVERLAY ============ */
        #endingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 400;
            animation: slowFadeIn 3s ease-out;
        }

        @keyframes slowFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .ending-text {
            color: #8a3030;
            font-size: 32px;
            text-transform: uppercase;
            letter-spacing: 6px;
            margin-bottom: 24px;
            text-shadow: 0 0 20px rgba(138, 48, 48, 0.5);
        }

        .ending-subtitle {
            color: #6a5050;
            font-size: 16px;
            max-width: 340px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 50px;
        }

        .ending-restart {
            color: #4a4040;
            font-size: 14px;
            animation: blink 1.5s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        /* ============ LOVE LETTER OVERLAY ============ */
        #letterOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            flex-direction: column;
        }

        #letterCanvas {
            image-rendering: pixelated;
            border: 4px solid #d4c4a8;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        #letterClose {
            margin-top: 15px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #888;
        }

        /* ============ BASEMENT SCENE OVERLAY ============ */
        #basementOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        #basementCanvas {
            image-rendering: pixelated;
        }

        #basementFade {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
        }

        /* ============ KEYS MINI-GAME OVERLAY ============ */
        #keysOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 350;
        }

        .keys-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #keysCanvas {
            border: 3px solid #5a4a3a;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .keys-current {
            color: #8a6a4a;
            font-size: 12px;
            margin-top: 15px;
            letter-spacing: 2px;
        }

        .keys-controls {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            color: #5a5a5a;
            font-size: 10px;
        }

        .keys-message {
            color: #8a5a4a;
            font-size: 11px;
            margin-top: 20px;
            min-height: 20px;
            animation: shake 0.3s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Pong Game Overlay */
        #pongOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 350;
        }

        #pongCanvas {
            border: 3px solid #00aa00;
            background: #000;
            image-rendering: pixelated;
        }

        .pong-header {
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #00ff00;
        }

        .pong-score {
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            margin-top: 10px;
        }

        .pong-controls {
            color: #007700;
            font-size: 11px;
            margin-top: 15px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
    <div id="gameContainer">
        <canvas id="gameCanvas" width="384" height="512"></canvas>
        <div id="crtOverlay"></div>
        <div id="vignette"></div>

        <div id="hud">
        </div>

        <div id="locationIndicator">TU DEPARTAMENTO</div>

        <div id="dialogueBox"></div>

        <div id="telegramPopup">
            <div class="telegram-header">
                <div class="telegram-icon">‚úà</div>
                <span class="telegram-name">Billy</span>
                <div class="telegram-silent" id="telegramSilent">üîá</div>
            </div>
            <div class="telegram-message" id="telegramMessage"></div>
            <div class="telegram-response" id="telegramResponse"></div>
        </div>

        <!-- Phone Animation Overlay -->
        <div id="phoneAnimationOverlay">
            <canvas id="phoneAnimationCanvas" width="120" height="160"></canvas>
        </div>

        <div id="interactHint">[E] Agarrar</div>

        <div id="inventoryOverlay">
            <div class="inventory-title">INVENTARIO</div>
            <div class="inventory-grid" id="inventoryGrid"></div>
            <div class="inventory-hint">Click para equipar ¬∑ [I] o [ESC] para cerrar</div>
        </div>

        <div id="combinationLockOverlay">
            <div class="lock-title">CAJA DE HERRAMIENTAS</div>
            <div class="lock-container">
                <div class="lock-digits">
                    <div class="lock-digit selected" data-index="0">0</div>
                    <div class="lock-digit" data-index="1">0</div>
                    <div class="lock-digit" data-index="2">0</div>
                    <div class="lock-digit" data-index="3">0</div>
                </div>
            </div>
            <div class="lock-hint">‚Üë‚Üì: Cambiar n√∫mero ¬∑ ‚Üê‚Üí: Seleccionar ¬∑ ENTER: Probar ¬∑ ESC: Cerrar</div>
            <div class="lock-error" id="lockError"></div>
        </div>

        <div class="controls-info">WASD: Mover ¬∑ E: Interactuar ¬∑ ESPACIO: Usar/Empujar ¬∑ I: Inventario</div>

        <div id="tvOverlay">
            <div class="tv-frame">
                <canvas id="tvScreen" width="400" height="300"></canvas>
                <div class="tv-channel-indicator" id="tvChannelIndicator">CH 1</div>
            </div>
            <div class="tv-controls">
                <span>[A/D] Cambiar canal</span>
                <span>[Z] o [ESC] Salir</span>
            </div>
        </div>

        <div id="pianoOverlay">
            <div class="piano-title">PIANO</div>
            <div class="piano-container">
                <div class="piano-keys" id="pianoKeys">
                    <!-- White keys -->
                    <div class="piano-key" data-note="C4"><span class="key-label">A</span></div>
                    <div class="piano-key" data-note="D4"><span class="key-label">S</span></div>
                    <div class="piano-key" data-note="E4"><span class="key-label">D</span></div>
                    <div class="piano-key" data-note="F4"><span class="key-label">F</span></div>
                    <div class="piano-key" data-note="G4"><span class="key-label">G</span></div>
                    <div class="piano-key" data-note="A4"><span class="key-label">H</span></div>
                    <div class="piano-key" data-note="B4"><span class="key-label">J</span></div>
                    <div class="piano-key" data-note="C5"><span class="key-label">K</span></div>
                    <!-- Black keys positioned absolutely -->
                    <div class="piano-key-black" data-note="C#4" style="left: 26px;"><span class="key-label">W</span></div>
                    <div class="piano-key-black" data-note="D#4" style="left: 64px;"><span class="key-label">E</span></div>
                    <div class="piano-key-black" data-note="F#4" style="left: 140px;"><span class="key-label">T</span></div>
                    <div class="piano-key-black" data-note="G#4" style="left: 178px;"><span class="key-label">Y</span></div>
                    <div class="piano-key-black" data-note="A#4" style="left: 216px;"><span class="key-label">U</span></div>
                </div>
            </div>
            <div class="piano-controls">
                <span>Teclas blancas: A S D F G H J K</span>
                <span>Teclas negras: W E T Y U</span>
            </div>
            <div class="piano-hint">[Z] o [ESC] para salir</div>
        </div>

        <!-- Hiding Overlay -->
        <div id="hidingOverlay">
            <div class="hiding-darkness"></div>
            <div class="hiding-text" id="hidingText">Escondido debajo de la cama...</div>
            <div class="hiding-hint">[E] o [ESPACIO] para salir</div>
        </div>

        <!-- Ending Overlay -->
        <div id="endingOverlay">
            <div class="ending-text" id="endingText"></div>
            <div class="ending-subtitle" id="endingSubtitle"></div>
            <div class="ending-restart">[ESPACIO] para reiniciar</div>
        </div>

        <!-- Love Letter Overlay -->
        <div id="letterOverlay">
            <canvas id="letterCanvas" width="280" height="360"></canvas>
            <div id="letterClose">[ESC] para cerrar</div>
        </div>

        <!-- Basement Scene Overlay (for bad endings) -->
        <div id="basementOverlay">
            <canvas id="basementCanvas" width="384" height="512"></canvas>
            <div id="basementFade"></div>
        </div>

        <!-- Keys Mini-Game Overlay -->
        <div id="keysOverlay">
            <div class="keys-container">
                <canvas id="keysCanvas" width="200" height="200"></canvas>
                <div class="keys-current" id="keysCurrent">Llave 1</div>
            </div>
            <div class="keys-controls">
                <span>[E] Probar</span>
                <span>[Z] Rotar</span>
            </div>
            <div class="keys-message" id="keysMessage"></div>
        </div>

        <!-- Pong Game Overlay -->
        <div id="pongOverlay">
            <div class="pong-header">PONG</div>
            <canvas id="pongCanvas" width="280" height="200"></canvas>
            <div class="pong-score" id="pongScore">0 - 0</div>
            <div class="pong-controls">[W/S] Mover ¬∑ [ESC] Salir</div>
        </div>
    </div>

    <div id="bottomHud">
        <div class="equipped-item">
            <canvas id="equippedIcon" width="24" height="24"></canvas>
            <div>
                <div class="equipped-label">EQUIPADO</div>
                <div id="equippedName">Nada</div>
            </div>
        </div>
        <div id="minimap">
            <canvas id="minimapCanvas" width="80" height="100"></canvas>
        </div>
    </div>
    <div id="versionNumber">v1.0</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // ============ AUDIO SYSTEM ============
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        let ambientOsc = null;
        let ambientGain = null;
        let clockTickSound = null;

        // Audio file cache
        const audioBuffers = {};
        const SOUND_FILES = {
            'notification': 'sounds/notification.mp3',
            'keys-jingle': 'sounds/keys-jingle.mp3',
            'keys-drop': 'sounds/keys-drop.mp3',
            'phone-vibrate': 'sounds/phone-vibrate.mp3',
            'heartbeat': 'sounds/heartbeat.mp3',
            'jumpscare': 'sounds/jumpscare.mp3',
            'footsteps': 'sounds/footsteps.mp3',
            'fridge-hum': 'sounds/fridge-hum.mp3',
            'whistling': 'sounds/whistling.mp3',
            'knife-scrape': 'sounds/knife-scrape.mp3',
            'knife-stab': 'sounds/knife-stab.mp3',
            'shower': 'sounds/shower.mp3',
            'screw': 'sounds/screw.mp3',
            'tv-static': 'sounds/tv-static.mp3',
            'clock-tick': 'sounds/clock-tick.mp3',
            'lightswitch': 'sounds/lightswitch.mp3',
            'number-press': 'sounds/number-press.mp3',
            'piano-chord': 'sounds/piano-chord.mp3',
            'shower-curtain': 'sounds/shower-curtain.mp3'
        };

        // Preload all audio files
        async function preloadAudio() {
            initAudio();
            for (const [name, path] of Object.entries(SOUND_FILES)) {
                try {
                    const response = await fetch(path);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffers[name] = await audioCtx.decodeAudioData(arrayBuffer);
                } catch (e) {
                    console.warn(`Failed to load sound: ${name}`, e);
                }
            }
            console.log('Audio preloaded:', Object.keys(audioBuffers).length, 'sounds');
            // Start clock-tick if in Fede's apartment
            if (game.currentScreen === 'home' || game.currentScreen === 'upstairs') {
                startClockTick();
            }
        }

        // Play a loaded audio file
        function playAudioFile(name, options = {}) {
            if (!audioCtx || !audioBuffers[name]) {
                console.warn(`Sound not loaded: ${name}`);
                return null;
            }
            const source = audioCtx.createBufferSource();
            const gainNode = audioCtx.createGain();
            source.buffer = audioBuffers[name];
            source.loop = options.loop || false;
            gainNode.gain.value = (options.volume !== undefined ? options.volume : 0.5) * 0.8;
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(0);
            return { source, gainNode };
        }

        // Clock tick ambient for Fede's apartment
        function startClockTick() {
            if (clockTickSound) return; // Already playing
            clockTickSound = playAudioFile('clock-tick', { volume: 0.15, loop: true });
        }

        function stopClockTick() {
            if (clockTickSound) {
                try {
                    clockTickSound.source.stop();
                } catch (e) {}
                clockTickSound = null;
            }
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioCtx();
                startAmbient();
            }
        }

        function startAmbient() {
            if (!audioCtx) return;

            // Low drone
            ambientOsc = audioCtx.createOscillator();
            ambientGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            ambientOsc.type = 'sine';
            ambientOsc.frequency.setValueAtTime(55, audioCtx.currentTime);
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(100, audioCtx.currentTime);

            ambientOsc.connect(filter);
            filter.connect(ambientGain);
            ambientGain.connect(audioCtx.destination);
            ambientGain.gain.setValueAtTime(0.02, audioCtx.currentTime);

            ambientOsc.start();

            // Add subtle modulation
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.frequency.setValueAtTime(0.1, audioCtx.currentTime);
            lfoGain.gain.setValueAtTime(3, audioCtx.currentTime);
            lfo.connect(lfoGain);
            lfoGain.connect(ambientOsc.frequency);
            lfo.start();
        }

        function playSound(type, options = {}) {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch(type) {
                case 'pickup':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.08);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.12, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;

                case 'telegram':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.08);
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.16);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;

                case 'locked':
                    oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(100, audioCtx.currentTime + 0.08);
                    oscillator.frequency.setValueAtTime(80, audioCtx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;

                case 'unlock':
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.12, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;

                case 'keysJingle':
                    // Create multiple metallic clinks for keys jingling
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(2000 + Math.random() * 500, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.05);
                    // Add more jingles
                    for (let i = 1; i < 6; i++) {
                        setTimeout(() => {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.connect(gain);
                            gain.connect(audioCtx.destination);
                            osc.type = 'square';
                            osc.frequency.setValueAtTime(1500 + Math.random() * 1000, audioCtx.currentTime);
                            gain.gain.setValueAtTime(0.06 - i * 0.008, audioCtx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.04);
                            osc.start(audioCtx.currentTime);
                            osc.stop(audioCtx.currentTime + 0.04);
                        }, i * 40 + Math.random() * 20);
                    }
                    break;

                case 'keysDrop':
                    // Keys hitting floor - thud + jingle
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    // Add metallic jingle after thud
                    setTimeout(() => playAudioFile('keys-jingle', { volume: 0.5 }), 100);
                    break;

                case 'step':
                    const floorType = options.floor || 'wood';
                    oscillator.type = 'square';
                    if (floorType === 'tile') {
                        oscillator.frequency.setValueAtTime(200 + Math.random() * 50, audioCtx.currentTime);
                        gainNode.gain.setValueAtTime(0.02, audioCtx.currentTime);
                    } else if (floorType === 'concrete') {
                        oscillator.frequency.setValueAtTime(60 + Math.random() * 20, audioCtx.currentTime);
                        gainNode.gain.setValueAtTime(0.04, audioCtx.currentTime);
                    } else {
                        oscillator.frequency.setValueAtTime(100 + Math.random() * 30, audioCtx.currentTime);
                        gainNode.gain.setValueAtTime(0.03, audioCtx.currentTime);
                    }
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.06);
                    break;

                case 'transition':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.4);
                    // Add noise burst
                    const noise = audioCtx.createOscillator();
                    const noiseGain = audioCtx.createGain();
                    noise.type = 'sawtooth';
                    noise.frequency.setValueAtTime(40, audioCtx.currentTime);
                    noise.connect(noiseGain);
                    noiseGain.connect(audioCtx.destination);
                    noiseGain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    noise.start(audioCtx.currentTime);
                    noise.stop(audioCtx.currentTime + 0.2);
                    break;

                case 'push':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(80, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(60, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;

                case 'tvOn':
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.05);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;

                case 'tvOff':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;

                case 'tvChannel':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime + 0.03);
                    gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.08);
                    break;
            }
        }

        // ============ GAME STATE ============
        const DEBUG_MODE = false; // Set to true to enable debug cheat codes
        const TILE = 32;

        const game = {
            currentScreen: 'home', // 'home' or 'neighbor'
            player: {
                x: 100,
                y: 240,
                width: 20,
                height: 28,
                speed: 2.2,
                direction: 'down',
                frame: 0,
                frameTimer: 0,
                stepTimer: 0,
                isMoving: false,
                bobOffset: 0,
                phoneAnimation: null // { phase: 'taking_out' | 'looking' | 'putting_back', timer: 0, callback: null }
            },
            inventory: [],
            equipped: null,
            showInventory: false,
            dialogueTimer: 0,
            currentDialogue: '',
            telegramTimer: 0,
            gameTime: 0,
            nearbyObject: null,
            pickupAnimation: null,
            revengeAnimation: null,
            escapeAnimation: null,
            doorShake: 0,
            lampFlicker: 1,
            pushTimer: 0,
            isPushing: false,
            tv: {
                on: false,
                channel: 0,
                focused: false,
                static: 0
            },
            flags: {
                screwdriverTaken: false,
                keyTaken: false,
                cabinetOpened: false,
                flashlightTaken: false,
                triedDoor: false,
                noteTaken: false,
                billyMsg1: false,
                billyMsg2: false,
                billyMsg3: false,
                visitedNeighbor: false,
                neighborNoteTaken: false,
                toolboxOpened: false,
                mirrorRevealed: false,
                documentRead: false,
                fridgeOpened: false,
                // Neighbor apartment clues discovered
                sawPolaroids: false,
                sawWallets: false,
                sawDrawer: false,
                sawCloset: false,
                sawBathtub: false,
                sawNewspapers: false,
                sawKeyHook: false,
                sawMetalBox: false,
                sawNightstand: false,
                triedNeighborDoor: false,
                pianoUsed: false,
                letterTaken: false,
                letterViewing: false,
                ndKeysOnTable: false,
                condomsTaken: false
            },
            combinationLock: {
                active: false,
                digits: [0, 0, 0, 0],
                selectedDigit: 0,
                correctCode: [1, 9, 8, 7]  // The secret code
            },
            piano: {
                focused: false,
                activeKeys: new Set()
            },
            pong: {
                active: false,
                playerY: 80,
                aiY: 80,
                ballX: 140,
                ballY: 100,
                ballVX: 3,
                ballVY: 2,
                playerScore: 0,
                aiScore: 0,
                lastUpdate: 0
            },
            hiding: {
                active: false,
                phase: 0,        // 0=waiting, 1=key, 2=door, 3=footsteps, 4=humming, 5=footsteps2, 6=keys_drop, 7=footsteps3, 8=bathroom_door, 9=water, 10=safe
                timer: 0,
                canExit: false,  // Only true after bathroom door sound
                killerInside: false,
                keysDropped: false,
                heartbeatSound: null,
                showerSound: null  // Looping shower sound - stops when keys grabbed
            },
            killer: {
                active: false,
                x: 0,
                y: 0,
                targetX: 0,
                targetY: 0,
                speed: 0.8,
                phase: 'inactive', // 'inactive', 'entering', 'walking', 'bathroom', 'emerging', 'chasing', 'stunned'
                visible: false,
                stunned: false,
                knifeDropped: false
            },
            keysGame: {
                active: false,
                currentKey: 0,
                totalKeys: 5,
                rotating: false,
                rotationAngle: 0,
                keysOwned: false
            },
            ending: null, // 'A', 'B', 'C', 'D'
            phone: {
                silentMode: false,
                animation: null, // { phase: 'taking_out' | 'silencing' | 'putting_back', timer: 0 }
                animationCallback: null
            }
        };

        // ============ COLORS ============
        const COLORS = {
            // Home apartment
            hallway: '#4a4038',
            hallwayAlt: '#3d352c',
            bathroom: '#2a3a3a',
            bathroomTile: '#3a4a4a',
            bedroom: '#3a2a3a',
            bedroomAlt: '#2d1f2d',
            office: '#2a3a2a',
            officeAlt: '#1f2d1f',
            tools: '#3a3535',
            toolsAlt: '#2d2828',

            // Neighbor apartment
            neighborHall: '#38342a',
            neighborLiving: '#2a2a38',
            neighborKitchen: '#383028',

            // Furniture
            furniture: '#5a4a3a',
            furnitureLight: '#7a6a5a',
            furnitureDark: '#3a2a1a',

            // Effects
            wallTop: '#6a5a4a',
            wallShadow: '#1a1a1a',

            // Player
            player: '#e0c0a0',
            playerShirt: '#4a6a8a',
            playerPants: '#3a3a4a',
            playerHair: '#1a1a1a'
        };

        // ============ ROOM DEFINITIONS ============
        const screens = {
            home: {
                rooms: [
                    { id: 'bathroom', x: 0, y: 0, w: 4, h: 4, color: COLORS.bathroom, altColor: COLORS.bathroomTile, floor: 'tile' },
                    { id: 'hallway', x: 0, y: 4, w: 4, h: 6, color: COLORS.hallway, altColor: COLORS.hallwayAlt, floor: 'wood' },
                    { id: 'office', x: 4, y: 0, w: 8, h: 5, color: COLORS.office, altColor: COLORS.officeAlt, floor: 'wood' },
                    { id: 'bedroom', x: 4, y: 5, w: 8, h: 5, color: COLORS.bedroom, altColor: COLORS.bedroomAlt, floor: 'wood' },
                    { id: 'tools', x: 0, y: 10, w: 12, h: 6, color: COLORS.tools, altColor: COLORS.toolsAlt, floor: 'concrete' }
                ],
                walls: [
                    // Bathroom bottom wall (with doorway opening)
                    { x: 0, y: 4, w: 1, h: 0.25 },
                    { x: 2.5, y: 4, w: 1.5, h: 0.25 },
                    // Bathroom right wall (separates from office)
                    { x: 4, y: 0, w: 0.25, h: 4 },
                    // Hallway right wall to office (with doorway)
                    { x: 4, y: 4, w: 0.25, h: 1 },
                    // Office/bedroom horizontal wall
                    { x: 4, y: 5, w: 8, h: 0.25 },
                    // Hallway right wall to bedroom (with doorway)
                    { x: 4, y: 5, w: 0.25, h: 1.5 },
                    { x: 4, y: 8.5, w: 0.25, h: 1.5 }
                    // NO wall between hallway and tools - it's open
                ],
                doorways: [
                    { x: 1, y: 4, w: 1.5, room1: 'bathroom', room2: 'hallway' },
                    { x: 4, y: 4, w: 0.25, h: 1, vertical: true, room1: 'hallway', room2: 'office' },
                    { x: 4, y: 6.5, w: 0.25, h: 2, vertical: true, room1: 'hallway', room2: 'bedroom' }
                    // Tools area is fully open - no doorway needed
                ],
                exitDoor: { x: 11.7, y: 7, w: 0.5, h: 2, target: 'neighbor', spawnX: 50, spawnY: 280 },
                name: 'TU DEPARTAMENTO'
            },
            neighbor: {
                rooms: [
                    // Hallway - left strip with front door
                    { id: 'neighborHall', x: 0, y: 0, w: 3, h: 8, color: '#2a2520', altColor: '#221f1a', floor: 'wood' },
                    // Bathroom - bottom left (killer goes here)
                    { id: 'neighborBathroom', x: 0, y: 8, w: 3, h: 8, color: '#1f2226', altColor: '#181b1e', floor: 'tile' },
                    // Living room - top right
                    { id: 'neighborLiving', x: 3, y: 0, w: 9, h: 6, color: '#1f1f25', altColor: '#18181e', floor: 'wood' },
                    // Bedroom - middle (bed for hiding) - extends full height
                    { id: 'neighborBedroom', x: 3, y: 6, w: 5, h: 10, color: '#221a1a', altColor: '#1a1414', floor: 'wood' },
                    // Kitchen - right side (fridge entry point)
                    { id: 'neighborKitchen', x: 8, y: 6, w: 4, h: 10, color: '#25201a', altColor: '#1e1915', floor: 'tile' }
                ],
                walls: [
                    // Hall/living vertical wall
                    { x: 3, y: 0, w: 0.25, h: 8 },
                    // Bathroom/bedroom vertical wall
                    { x: 3, y: 8, w: 0.25, h: 8 },
                    // Hall/bathroom horizontal wall
                    { x: 0, y: 8, w: 3, h: 0.25 },
                    // Living room bottom wall (separates from bedroom/kitchen)
                    { x: 3, y: 6, w: 9, h: 0.25 },
                    // Bedroom/kitchen vertical wall
                    { x: 8, y: 6, w: 0.25, h: 10 }
                ],
                doorways: [
                    // Hall to living room
                    { x: 3, y: 2, w: 0.25, h: 2, vertical: true },
                    // Hall to bathroom
                    { x: 1, y: 8, w: 1.5, h: 0.25, vertical: false },
                    // Living to bedroom
                    { x: 5, y: 6, w: 2, h: 0.25, vertical: false },
                    // Bedroom to kitchen
                    { x: 8, y: 9, w: 0.25, h: 2, vertical: true }
                ],
                exitDoor: null,
                name: '2DO PISO - VECINO'
            },
            upstairs: {
                rooms: [
                    { id: 'windowArea', x: 0, y: 0, w: 4, h: 10, color: '#3a3a42', altColor: '#2d2d35', floor: 'wood' },
                    { id: 'stairsArea', x: 0, y: 10, w: 4, h: 6, color: COLORS.tools, altColor: COLORS.toolsAlt, floor: 'concrete' },
                    { id: 'livingArea', x: 4, y: 0, w: 8, h: 8, color: '#3a3545', altColor: '#2d2838', floor: 'wood' },
                    { id: 'kitchenArea', x: 4, y: 8, w: 8, h: 8, color: '#38352a', altColor: '#2b2820', floor: 'tile' }
                ],
                walls: [
                    // Vertical wall between left and right sides (only up to y=10)
                    { x: 4, y: 0, w: 0.25, h: 8 },
                    // Horizontal wall between living and kitchen on right side
                    { x: 4, y: 8, w: 8, h: 0.25 }
                ],
                doorways: [
                    // Doorway between windowArea and livingArea
                    { x: 4, y: 4, w: 0.25, h: 2, vertical: true },
                    // Doorway between living and kitchen
                    { x: 6, y: 8, w: 2, h: 0.25, vertical: false }
                ],
                exitDoor: null,
                name: '2DO PISO'
            },
            neighborDown: {
                rooms: [
                    // Main hallway/entrance area
                    { id: 'nDownHall', x: 0, y: 0, w: 12, h: 8, color: '#252220', altColor: '#1e1b18', floor: 'wood' },
                    // Stairs area
                    { id: 'nDownStairs', x: 0, y: 8, w: 4, h: 8, color: '#1a1815', altColor: '#151310', floor: 'concrete' },
                    // Storage/utility area
                    { id: 'nDownStorage', x: 4, y: 8, w: 8, h: 8, color: '#201a18', altColor: '#181412', floor: 'concrete' }
                ],
                walls: [
                    // Wall separating stairs from storage
                    { x: 4, y: 8, w: 0.25, h: 8 }
                ],
                doorways: [
                    // Doorway from hall to stairs
                    { x: 1.5, y: 8, w: 2, h: 0.25, vertical: false },
                    // Doorway from hall to storage
                    { x: 6, y: 8, w: 2, h: 0.25, vertical: false }
                ],
                exitDoor: { x: -0.2, y: 3, w: 0.5, h: 2, target: 'outside', spawnX: 50, spawnY: 280 },
                name: 'PLANTA BAJA - VECINO'
            }
        };

        // ============ OBJECTS PER SCREEN ============
        const objectsByScreen = {
            home: [
                // Bathroom (0-4, 0-4)
                { id: 'toilet', x: 0.4, y: 0.5, w: 1.2, h: 1.5, type: 'furniture', sprite: 'toilet' },
                { id: 'bathtub', x: 0.3, y: 1.2, w: 2.2, h: 1.5, type: 'furniture', sprite: 'bathtub' },
                { id: 'sink', x: 2.8, y: 0.5, w: 1, h: 0.8, type: 'furniture', sprite: 'sink' },
                { id: 'bathroomMirror', x: 2.9, y: 0.1, w: 0.8, h: 0.6, type: 'interactable', sprite: 'mirror', action: 'mirror' },
                { id: 'cabinet', x: 2.7, y: 1.5, w: 1.1, h: 1.1, type: 'interactable', sprite: 'cabinet', action: 'cabinet', needsItem: 'Llave peque√±a' },

                // Office (4-12, 0-5)
                { id: 'desk', x: 8, y: 0.5, w: 2.8, h: 1.5, type: 'interactable', sprite: 'desk', action: 'computer' },
                { id: 'chair', x: 8.8, y: 2.5, w: 1, h: 1, type: 'furniture', sprite: 'chair', pushable: true },
                { id: 'bookshelf', x: 4.5, y: 0.3, w: 1.5, h: 3, type: 'furniture', sprite: 'bookshelf' },
                { id: 'officePlant', x: 10.8, y: 0.4, w: 0.8, h: 1.2, type: 'furniture', sprite: 'tallPlant', pushable: true },
                { id: 'officeRug', x: 7, y: 2.8, w: 2.5, h: 1.5, type: 'decor', sprite: 'rug' },

                // Bedroom (4-12, 5-10) - wardrobe spans whole bottom wall
                { id: 'queenBed', x: 8.8, y: 5.5, w: 2.7, h: 2.5, type: 'furniture', sprite: 'queenBed' },
                { id: 'nightstand', x: 11.2, y: 6.2, w: 0.6, h: 0.6, type: 'interactable', sprite: 'nightstand', action: 'nightstand' },
                { id: 'bedroomLamp', x: 11.25, y: 5.8, w: 0.5, h: 0.4, type: 'decor', sprite: 'lamp' },
                { id: 'wardrobe', x: 4.5, y: 9.2, w: 7, h: 0.8, type: 'interactable', sprite: 'longWardrobe', action: 'wardrobe' },
                { id: 'plant', x: 5, y: 5.8, w: 1, h: 1, type: 'interactable', sprite: 'plant', action: 'plant', item: 'Llave peque√±a', pushable: true },
                { id: 'bedroomRug', x: 6, y: 6, w: 4, h: 2.5, type: 'decor', sprite: 'largeCarpet' },
                { id: 'condoms', x: 10.5, y: 8.5, w: 0.4, h: 0.3, type: 'item', sprite: 'condomBox', item: 'Forros' },

                // Tools area (0-12, 10-16) - fully open to hallway
                { id: 'workbench', x: 5, y: 10.5, w: 3.5, h: 1.3, type: 'furniture', sprite: 'workbench' },
                { id: 'screwdriver', x: 6, y: 12.5, w: 1.2, h: 0.5, type: 'item', sprite: 'screwdriver', item: 'Destornillador' },
                { id: 'toolbox', x: 9, y: 11, w: 1.2, h: 1, type: 'interactable', sprite: 'toolbox', action: 'toolbox', pushable: true },
                { id: 'shelves', x: 10.3, y: 10.5, w: 1.2, h: 2.8, type: 'furniture', sprite: 'metalShelves' },
                { id: 'stairs', x: 0.5, y: 12, w: 2.2, h: 2.8, type: 'interactable', sprite: 'stairs', action: 'stairs' },

                // Hallway/Entrance (0-4, 4-10)
                { id: 'frontDoor', x: -0.3, y: 6, w: 0.6, h: 2, type: 'interactable', sprite: 'door', action: 'frontDoor' },
                { id: 'coatRack', x: 0.5, y: 4.3, w: 0.8, h: 1.3, type: 'furniture', sprite: 'coatRack', pushable: true },
                { id: 'smallTable', x: 2, y: 8, w: 1.2, h: 0.9, type: 'furniture', sprite: 'smallTable', pushable: true },
                { id: 'hallwayNote', x: 2.2, y: 8.1, w: 0.5, h: 0.35, type: 'item', sprite: 'note', item: 'Nota' },
                { id: 'shoeRack', x: 0.5, y: 9, w: 1.3, h: 0.7, type: 'furniture', sprite: 'shoeRack', pushable: true }
            ],
            neighbor: [
                // ============ HALLWAY (left strip, y=0-8) - now has stairs down ============
                { id: 'nStairsDown', x: 0.5, y: 4, w: 2, h: 3, type: 'interactable', sprite: 'stairsDown', action: 'neighborStairsDown' },
                { id: 'nKeyHook', x: 0.4, y: 1, w: 0.6, h: 0.8, type: 'interactable', sprite: 'emptyKeyHook', action: 'keyHook' },
                { id: 'nCoatRack', x: 0.4, y: 0.5, w: 0.8, h: 1.3, type: 'furniture', sprite: 'coatRack' },

                // ============ LIVING ROOM (top right, y=0-6) ============
                { id: 'nSofa', x: 8, y: 0.8, w: 3, h: 1.8, type: 'furniture', sprite: 'sofa' },
                { id: 'nCoffeeTable', x: 7.5, y: 3, w: 2.5, h: 1.2, type: 'furniture', sprite: 'coffeeTable', pushable: true },
                { id: 'nTV', x: 4, y: 0.5, w: 2.2, h: 1.6, type: 'furniture', sprite: 'tv' },
                { id: 'nTVStand', x: 3.8, y: 2, w: 2.6, h: 0.8, type: 'furniture', sprite: 'tvStand' },
                { id: 'nPolaroids', x: 10.5, y: 0.3, w: 1.2, h: 2.5, type: 'interactable', sprite: 'polaroidWall', action: 'polaroids' },
                { id: 'nNewspapers', x: 6.5, y: 0.5, w: 1, h: 0.8, type: 'interactable', sprite: 'newspapers', action: 'newspapers' },
                { id: 'nRug', x: 6, y: 3.5, w: 4, h: 2, type: 'decor', sprite: 'darkRug' },
                { id: 'nShelf', x: 3.5, y: 4, w: 2, h: 1.5, type: 'furniture', sprite: 'creepyShelf' },

                // ============ BEDROOM (middle, y=6-16) ============
                { id: 'nBed', x: 4, y: 8, w: 3.5, h: 3, type: 'interactable', sprite: 'stainedBed', action: 'neighborBed' },
                { id: 'nNightstand', x: 7, y: 8, w: 0.7, h: 0.7, type: 'interactable', sprite: 'nightstand', action: 'neighborNightstand' },
                { id: 'nCloset', x: 3.3, y: 12, w: 2.5, h: 1.3, type: 'interactable', sprite: 'creepyCloset', action: 'neighborCloset' },
                { id: 'nBedroomRug', x: 4.5, y: 10.5, w: 2, h: 1.5, type: 'decor', sprite: 'stainedRug' },

                // ============ KITCHEN (right side, y=6-16) ============
                { id: 'nCounter', x: 8.5, y: 6.5, w: 3, h: 1.2, type: 'furniture', sprite: 'dirtyCounter' },
                { id: 'nWallets', x: 9.5, y: 6.6, w: 1.5, h: 0.5, type: 'interactable', sprite: 'wallets', action: 'wallets' },
                { id: 'nDrawer', x: 8.5, y: 8.5, w: 1.2, h: 0.8, type: 'interactable', sprite: 'drawer', action: 'kitchenDrawer' },
                { id: 'nFridge', x: 10.3, y: 12, w: 1.4, h: 2.5, type: 'furniture', sprite: 'oldFridge' },
                { id: 'nTable', x: 8.8, y: 10, w: 2.2, h: 1.5, type: 'furniture', sprite: 'kitchenTable' },
                { id: 'nChair1', x: 8.3, y: 10.5, w: 0.7, h: 0.7, type: 'furniture', sprite: 'kitchenChair' },
                { id: 'nSink', x: 8.5, y: 14, w: 1.3, h: 1, type: 'furniture', sprite: 'dirtySink' },
                { id: 'nStains', x: 10, y: 9.5, w: 1.5, h: 1, type: 'decor', sprite: 'floorStains' },

                // ============ BATHROOM (bottom left, y=8-16) ============
                { id: 'nToilet', x: 0.4, y: 8.8, w: 1.2, h: 1.5, type: 'furniture', sprite: 'dirtyToilet' },
                { id: 'nBathtub', x: 0.3, y: 11, w: 2.5, h: 2.5, type: 'interactable', sprite: 'stainedBathtub', action: 'neighborBathtub' },
                { id: 'nBathSink', x: 1.8, y: 8.8, w: 1, h: 0.9, type: 'furniture', sprite: 'sink' }
            ],
            upstairs: [
                // Window area (left side)
                { id: 'hugeWindow', x: 0.3, y: 0.5, w: 3.4, h: 5, type: 'decor', sprite: 'hugeWindow' },
                { id: 'balconyDoor', x: 0.8, y: 6, w: 2, h: 3, type: 'interactable', sprite: 'balconyDoor', action: 'balconyDoor' },
                { id: 'windowPlant', x: 0.5, y: 5.5, w: 0.8, h: 0.8, type: 'furniture', sprite: 'plant', pushable: true },

                // Stairs area (bottom left)
                { id: 'upstairsStairs', x: 0.5, y: 11, w: 2.5, h: 3.5, type: 'interactable', sprite: 'stairsDown', action: 'stairsDown' },

                // Living area (right upper)
                { id: 'piano', x: 5, y: 0.5, w: 3, h: 1.8, type: 'interactable', sprite: 'piano', action: 'piano' },
                { id: 'pianoStool', x: 6, y: 2.5, w: 1, h: 0.8, type: 'furniture', sprite: 'stool', pushable: true },
                { id: 'upstairsTV', x: 9.5, y: 0.5, w: 2, h: 1.5, type: 'interactable', sprite: 'tvLarge', action: 'tv' },
                { id: 'tvStand', x: 9.3, y: 2, w: 2.4, h: 0.8, type: 'furniture', sprite: 'tvStand' },
                { id: 'livingRug', x: 6.5, y: 3.5, w: 5, h: 4, type: 'decor', sprite: 'grayRug' },
                { id: 'sofa', x: 7, y: 4, w: 4.5, h: 2.8, type: 'furniture', sprite: 'lShapedSofa' },
                { id: 'coffeeTable2', x: 5, y: 5, w: 1.8, h: 1, type: 'furniture', sprite: 'coffeeTable' },

                // Kitchen area (right lower)
                { id: 'kitchenIsland', x: 6, y: 9, w: 3.5, h: 2, type: 'furniture', sprite: 'kitchenIsland' },
                { id: 'islandStool1', x: 5.5, y: 10, w: 0.7, h: 0.7, type: 'furniture', sprite: 'barStool', pushable: true },
                { id: 'islandStool2', x: 9.2, y: 10, w: 0.7, h: 0.7, type: 'furniture', sprite: 'barStool', pushable: true },
                { id: 'fridge', x: 10, y: 12, w: 1.5, h: 2.5, type: 'interactable', sprite: 'largeFridge', action: 'fridge' },
                { id: 'kitchenCounter', x: 5, y: 12, w: 4.5, h: 1.3, type: 'furniture', sprite: 'counter' },
                { id: 'sink2', x: 5.5, y: 12.2, w: 1.2, h: 1, type: 'furniture', sprite: 'kitchenSink' },
                { id: 'stove', x: 7.5, y: 12.2, w: 1.5, h: 1, type: 'furniture', sprite: 'stove' },
                { id: 'kitchenRug', x: 6.5, y: 14, w: 2.5, h: 1.5, type: 'decor', sprite: 'smallRug' }
            ],
            neighborDown: [
                // ============ HALLWAY - ESCAPE ROUTE ============
                { id: 'ndEscapeDoor', x: -0.3, y: 3, w: 0.6, h: 2, type: 'interactable', sprite: 'lockedDoor', action: 'escapeDoor' },
                { id: 'ndKeyHook', x: 0.4, y: 1, w: 0.6, h: 0.8, type: 'interactable', sprite: 'emptyKeyHook', action: 'keyHook' },
                { id: 'ndBathroomDoor', x: 11, y: 4, w: 1, h: 2.5, type: 'interactable', sprite: 'bathroomDoor', action: 'bathroomDoor' },
                { id: 'ndCoatRack', x: 1.5, y: 0.5, w: 0.8, h: 1.3, type: 'furniture', sprite: 'coatRack' },
                { id: 'ndShoeRack', x: 6, y: 0.5, w: 1.3, h: 0.7, type: 'furniture', sprite: 'shoeRack' },
                { id: 'ndTable', x: 5, y: 3, w: 2, h: 1.5, type: 'interactable', sprite: 'smallTable', action: 'ndTable' },
                { id: 'ndBookshelf', x: 8, y: 2, w: 1.5, h: 2.5, type: 'furniture', sprite: 'bookshelf', pushable: true },
                { id: 'ndRug', x: 3, y: 4, w: 4, h: 2.5, type: 'decor', sprite: 'darkRug' },
                { id: 'ndPainting', x: 9.5, y: 0.5, w: 2, h: 2.5, type: 'decor', sprite: 'creepyPainting' },

                // ============ STAIRS UP ============
                { id: 'ndStairsUp', x: 0.5, y: 10, w: 2.5, h: 3.5, type: 'interactable', sprite: 'stairs', action: 'neighborStairsUp' },

                // ============ STORAGE - DISTURBING DETAILS ============
                { id: 'ndShelves', x: 5, y: 9, w: 2, h: 3, type: 'furniture', sprite: 'metalShelves' },
                { id: 'ndBoxes', x: 7.5, y: 9, w: 2.5, h: 2, type: 'furniture', sprite: 'boxes' },
                { id: 'ndTarp', x: 5, y: 13, w: 3, h: 2, type: 'interactable', sprite: 'suspiciousTarp', action: 'tarp' },
                { id: 'ndTools', x: 9, y: 11, w: 2, h: 2.5, type: 'interactable', sprite: 'scaryStools', action: 'basementTools' }
            ]
        };

        // ============ KEYBOARD ============
        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            // Combination lock controls
            if (game.combinationLock.active) {
                handleCombinationLockInput(e.key);
                e.preventDefault();
                return;
            }

            // Ending screen - restart
            if (game.ending) {
                if (e.key === ' ') {
                    location.reload();
                }
                e.preventDefault();
                return;
            }

            // Hiding mode controls
            if (game.hiding.active) {
                if (e.key.toLowerCase() === 'e' || e.key === ' ') {
                    exitHiding();
                    e.preventDefault();
                }
                return;
            }

            // Keys mini-game controls
            if (game.keysGame.active) {
                if (e.key.toLowerCase() === 'e' || e.key === ' ') {
                    tryCurrentKey();
                    e.preventDefault();
                }
                if (e.key.toLowerCase() === 'z') {
                    rotateKeys();
                    e.preventDefault();
                }
                return;
            }

            // Letter/Note viewing mode
            if (game.flags.letterViewing || game.flags.noteViewing) {
                if (e.key === 'Escape' || e.key.toLowerCase() === 'e' || e.key === ' ') {
                    closeLetter();
                    e.preventDefault();
                }
                return;
            }

            // Piano focus mode controls
            if (game.piano.focused) {
                if (e.key.toLowerCase() === 'z' || e.key === 'Escape') {
                    closePianoFocus();
                    e.preventDefault();
                } else {
                    handlePianoKeyDown(e.key.toLowerCase());
                    e.preventDefault();
                }
                return;
            }

            // Pong game controls
            if (game.pong.active) {
                if (e.key === 'Escape') {
                    closePong();
                    e.preventDefault();
                }
                return;
            }

            // TV focus mode controls
            if (game.tv.focused) {
                if (e.key.toLowerCase() === 'a' || e.key === 'ArrowLeft') {
                    changeChannel(-1);
                    e.preventDefault();
                }
                if (e.key.toLowerCase() === 'd' || e.key === 'ArrowRight') {
                    changeChannel(1);
                    e.preventDefault();
                }
                if (e.key.toLowerCase() === 'z' || e.key === 'Escape') {
                    closeTVFocus();
                    e.preventDefault();
                }
                return;
            }

            if (e.key.toLowerCase() === 'i' || e.key === 'Escape') {
                toggleInventory();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'e') {
                tryInteract();
            }
            if (e.key === ' ') {
                tryUseItem();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'z') {
                tryFocusTV();
                tryFocusPiano();
                tryFocusComputer();
                tryHide();
            }

            // DEBUG: Number keys trigger endings for testing (only in debug mode)
            if (DEBUG_MODE) {
                if (e.key === '7') {
                    console.log('DEBUG: Triggering Ending A (Escape)');
                    triggerEnding('A');
                }
                if (e.key === '8') {
                    console.log('DEBUG: Triggering Ending B (Revenge)');
                    triggerEnding('B');
                }
                if (e.key === '9') {
                    console.log('DEBUG: Triggering Ending C (Caught)');
                    triggerEnding('C');
                }
                if (e.key === '0') {
                    console.log('DEBUG: Triggering Ending D (Discovered)');
                    triggerEnding('D');
                }

                // Debug shortcuts for screen transitions
                if (e.key === '1') {
                    transitionToScreen('home');
                }
                if (e.key === '2') {
                    transitionToScreen('upstairs');
                }
                if (e.key === '3') {
                    transitionToScreen('neighbor');
                }
                if (e.key === '4') {
                    transitionToScreen('neighborDown');
                }

                // DEBUG: 6 = Go to neighborDown
                if (e.key === '6') {
                    console.log('DEBUG: Going to neighborDown');
                    transitionToScreen('neighborDown');
                    game.flags.ndKeysOnTable = true; // Keys on table
                }

                // DEBUG: 5 = Go to neighborDown + killer in shower + keys on table
                if (e.key === '5') {
                    console.log('DEBUG: Going to neighborDown with killer showering');
                    transitionToScreen('neighborDown');
                    game.flags.exitedHidingSafely = true;
                    game.flags.ndKeysOnTable = true;
                    // Start shower sound
                    game.hiding.showerSound = playAudioFile('shower', { volume: 0.4, loop: true });
                }

                // DEBUG: p = trigger phone animation (test)
                if (e.key === 'p' || e.key === 'P') {
                    console.log('DEBUG: Triggering phone animation');
                    startPhoneSilentAnimation(null);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (game.piano.focused) {
                handlePianoKeyUp(e.key.toLowerCase());
            }
        });

        document.addEventListener('click', initAudio, { once: true });

        // ============ SPRITE DRAWING ============
        function drawSprite(sprite, x, y, w, h, options = {}) {
            const px = x * TILE;
            const py = y * TILE;
            const pw = w * TILE;
            const ph = h * TILE;

            switch(sprite) {
                case 'toilet':
                    // Base
                    ctx.fillStyle = '#e8e8e8';
                    ctx.fillRect(px + 6, py + ph - 22, pw - 12, 20);
                    // Bowl
                    ctx.fillStyle = '#f5f5f5';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2 + 5, pw/2 - 8, ph/3 - 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Water
                    ctx.fillStyle = '#a8c8d8';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2 + 5, pw/3 - 4, ph/4 - 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tank
                    ctx.fillStyle = '#ddd';
                    ctx.fillRect(px + 6, py + 4, pw - 12, ph/3);
                    ctx.fillStyle = '#ccc';
                    ctx.fillRect(px + 8, py + 6, pw - 16, ph/3 - 4);
                    // Handle
                    ctx.fillStyle = '#999';
                    ctx.fillRect(px + pw - 14, py + 12, 8, 4);
                    break;

                case 'bathtub':
                    // Outer rim
                    ctx.fillStyle = '#e0e0e0';
                    ctx.fillRect(px, py, pw, ph);
                    // Inner
                    ctx.fillStyle = '#f0f5f5';
                    ctx.fillRect(px + 6, py + 6, pw - 12, ph - 12);
                    // Water shine
                    ctx.fillStyle = 'rgba(180, 200, 220, 0.3)';
                    ctx.fillRect(px + 10, py + 10, pw - 24, ph - 20);
                    // Faucet area
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + pw - 28, py + 10, 20, 12);
                    ctx.fillStyle = '#aaa';
                    ctx.beginPath();
                    ctx.arc(px + pw - 18, py + 16, 4, 0, Math.PI * 2);
                    ctx.arc(px + pw - 10, py + 16, 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'sink':
                    // Counter
                    ctx.fillStyle = '#d0d0d0';
                    ctx.fillRect(px, py, pw, ph);
                    // Basin
                    ctx.fillStyle = '#e8e8e8';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2 + 4, pw/2 - 8, ph/2 - 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Drain
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph/2 + 4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    // Faucet
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + pw/2 - 4, py, 8, 12);
                    ctx.fillStyle = '#999';
                    ctx.fillRect(px + pw/2 - 6, py + 10, 12, 4);
                    break;

                case 'mirror':
                    // Frame
                    ctx.fillStyle = '#334';
                    ctx.fillRect(px, py, pw, ph);
                    // Glass
                    ctx.fillStyle = '#556';
                    ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);
                    // Reflection highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    ctx.fillRect(px + 4, py + 3, pw/3, ph - 6);

                    // UV numbers revealed
                    if (game.flags.mirrorRevealed) {
                        ctx.fillStyle = 'rgba(180, 100, 255, 0.7)';
                        ctx.font = '10px "Press Start 2P"';
                        ctx.textAlign = 'center';
                        ctx.fillText('1987', px + pw/2, py + ph/2 + 4);
                    }
                    break;

                case 'cabinet':
                    const isOpen = game.flags.cabinetOpened;
                    ctx.fillStyle = isOpen ? '#4a3a2a' : '#6a5a4a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);
                    if (!isOpen) {
                        // Door details
                        ctx.fillStyle = '#5a4a3a';
                        ctx.fillRect(px + 6, py + 6, pw/2 - 8, ph - 12);
                        ctx.fillRect(px + pw/2 + 2, py + 6, pw/2 - 8, ph - 12);
                        // Handles
                        ctx.fillStyle = '#b8a878';
                        ctx.fillRect(px + pw/2 - 8, py + ph/2 - 2, 6, 8);
                        ctx.fillRect(px + pw/2 + 2, py + ph/2 - 2, 6, 8);
                        // Lock
                        ctx.fillStyle = '#887';
                        ctx.beginPath();
                        ctx.arc(px + pw/2, py + ph - 12, 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Open - show inside
                        ctx.fillStyle = '#2a1a0a';
                        ctx.fillRect(px + 6, py + 6, pw - 12, ph - 12);
                    }
                    break;

                case 'desk':
                    // Surface
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#6a5a4a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 12);
                    // Computer
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(px + pw/2 - 20, py + 8, 40, 30);
                    ctx.fillStyle = '#0a2a1a';
                    ctx.fillRect(px + pw/2 - 17, py + 11, 34, 24);
                    // Screen glow
                    ctx.fillStyle = `rgba(100, 200, 150, ${0.3 + Math.sin(game.gameTime / 500) * 0.1})`;
                    ctx.fillRect(px + pw/2 - 15, py + 13, 30, 20);
                    // Keyboard
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(px + pw/2 - 16, py + ph - 18, 32, 12);
                    // Keys
                    ctx.fillStyle = '#3a3a3a';
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 8; j++) {
                            ctx.fillRect(px + pw/2 - 14 + j * 4, py + ph - 16 + i * 3, 3, 2);
                        }
                    }
                    break;

                case 'chair':
                    ctx.fillStyle = '#3a3a4a';
                    ctx.fillRect(px + 6, py + 6, pw - 12, ph - 12);
                    ctx.fillStyle = '#4a4a5a';
                    ctx.fillRect(px + 8, py + 8, pw - 16, ph - 20);
                    // Back
                    ctx.fillStyle = '#3a3a4a';
                    ctx.fillRect(px + 8, py, pw - 16, 10);
                    break;

                case 'bookshelf':
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, ph);
                    const bookColors = ['#8a3a3a', '#3a5a3a', '#3a3a6a', '#6a5a2a', '#5a2a4a', '#2a4a5a'];
                    const bookWidths = [8, 6, 9, 7, 8, 6];
                    const bookHeights = [18, 16, 19, 17, 16, 18];
                    for (let shelf = 0; shelf < 5; shelf++) {
                        const shelfY = py + 8 + shelf * (ph - 16) / 5;
                        // Shelf
                        ctx.fillStyle = '#5a4a3a';
                        ctx.fillRect(px + 4, shelfY + 20, pw - 8, 4);
                        // Books
                        let bookX = px + 6;
                        for (let b = 0; b < 5; b++) {
                            const bookW = bookWidths[(shelf + b) % bookWidths.length];
                            const bookH = bookHeights[(shelf + b) % bookHeights.length];
                            ctx.fillStyle = bookColors[(shelf + b) % bookColors.length];
                            ctx.fillRect(bookX, shelfY + 20 - bookH, bookW, bookH);
                            // Spine detail
                            ctx.fillStyle = 'rgba(255,255,255,0.1)';
                            ctx.fillRect(bookX + 1, shelfY + 22 - bookH, 2, bookH - 4);
                            bookX += bookW + 1;
                            if (bookX > px + pw - 10) break;
                        }
                    }
                    break;

                case 'tallPlant':
                    // Pot
                    ctx.fillStyle = '#8a5a4a';
                    ctx.fillRect(px + pw/4, py + ph - 20, pw/2, 18);
                    ctx.fillStyle = '#9a6a5a';
                    ctx.fillRect(px + pw/4 - 2, py + ph - 22, pw/2 + 4, 6);
                    // Stem
                    ctx.fillStyle = '#3a5a3a';
                    ctx.fillRect(px + pw/2 - 2, py + 20, 4, ph - 40);
                    // Leaves
                    ctx.fillStyle = '#4a7a4a';
                    for (let i = 0; i < 5; i++) {
                        const leafY = py + 15 + i * 12;
                        ctx.beginPath();
                        ctx.ellipse(px + pw/2 - 8 - i % 2 * 4, leafY, 10, 5, -0.3, 0, Math.PI * 2);
                        ctx.ellipse(px + pw/2 + 8 + i % 2 * 4, leafY, 10, 5, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#5a9a5a';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + 10, 12, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'rug':
                case 'smallRug':
                    ctx.fillStyle = '#6a2a2a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#8a3a3a';
                    ctx.fillRect(px + 6, py + 6, pw - 12, ph - 12);
                    // Pattern
                    ctx.strokeStyle = '#5a2a2a';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px + 12, py + 10, pw - 24, ph - 20);
                    // Fringe
                    ctx.fillStyle = '#7a3a3a';
                    for (let i = 0; i < pw / 8; i++) {
                        ctx.fillRect(px + 4 + i * 8, py, 4, 4);
                        ctx.fillRect(px + 4 + i * 8, py + ph - 4, 4, 4);
                    }
                    break;

                case 'largeRug':
                    ctx.fillStyle = '#2a2a4a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#3a3a6a';
                    ctx.fillRect(px + 8, py + 8, pw - 16, ph - 16);
                    // Geometric pattern
                    ctx.strokeStyle = '#4a4a7a';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px + 16, py + 14, pw - 32, ph - 28);
                    ctx.strokeRect(px + 24, py + 22, pw - 48, ph - 44);
                    // Center motif
                    ctx.fillStyle = '#5a5a8a';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph/2, 15, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'bed':
                    // Frame
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, ph);
                    // Mattress
                    ctx.fillStyle = '#7a8a9a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 10);
                    // Pillow
                    ctx.fillStyle = '#c0c8d0';
                    ctx.fillRect(px + 8, py + 8, pw - 16, 22);
                    ctx.fillStyle = '#b0b8c0';
                    ctx.fillRect(px + 10, py + 10, pw - 20, 18);
                    // Blanket
                    ctx.fillStyle = '#4a5a7a';
                    ctx.fillRect(px + 4, py + 34, pw - 8, ph - 44);
                    // Blanket fold
                    ctx.fillStyle = '#5a6a8a';
                    ctx.fillRect(px + 4, py + 34, pw - 8, 8);
                    // Blanket pattern
                    ctx.fillStyle = '#3a4a6a';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(px + 10 + i * 30, py + 50, 20, 3);
                    }
                    break;

                case 'queenBed':
                    // Wooden headboard
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(px + 4, py, pw - 8, 16);
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px + 8, py + 2, pw - 16, 12);
                    // Headboard detail/carving
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px + 14, py + 4, 20, 8);
                    ctx.fillRect(px + pw - 34, py + 4, 20, 8);

                    // Frame
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py + 14, pw, ph - 14);
                    // Frame border
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(px, py + 14, 4, ph - 14);
                    ctx.fillRect(px + pw - 4, py + 14, 4, ph - 14);
                    ctx.fillRect(px, py + ph - 4, pw, 4);

                    // Mattress
                    ctx.fillStyle = '#e8e0d8';
                    ctx.fillRect(px + 6, py + 18, pw - 12, ph - 26);

                    // Two pillows (queen bed)
                    ctx.fillStyle = '#f5f0ea';
                    ctx.fillRect(px + 10, py + 22, (pw - 26) / 2, 24);
                    ctx.fillRect(px + pw/2 + 3, py + 22, (pw - 26) / 2, 24);
                    // Pillow shadows
                    ctx.fillStyle = '#e0d8d0';
                    ctx.fillRect(px + 12, py + 24, (pw - 30) / 2, 20);
                    ctx.fillRect(px + pw/2 + 5, py + 24, (pw - 30) / 2, 20);

                    // Blanket (folded down)
                    ctx.fillStyle = '#5a6a8a';
                    ctx.fillRect(px + 6, py + 48, pw - 12, ph - 56);
                    // Blanket fold line
                    ctx.fillStyle = '#6a7a9a';
                    ctx.fillRect(px + 6, py + 48, pw - 12, 10);
                    // Blanket texture
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    for (let i = 0; i < 4; i++) {
                        ctx.fillRect(px + 12 + i * 24, py + 62, 18, 2);
                        ctx.fillRect(px + 18 + i * 24, py + 72, 14, 2);
                    }
                    break;

                case 'wardrobe':
                    // Horizontal wardrobe at foot of bed, door facing up
                    // Main body (wood)
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px, py, pw, ph);
                    // Frame darker
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, 4);
                    ctx.fillRect(px, py + ph - 4, pw, 4);
                    ctx.fillRect(px, py, 4, ph);
                    ctx.fillRect(px + pw - 4, py, 4, ph);

                    // Sliding black door on top (facing up toward bed)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(px + 6, py + 5, pw - 12, ph - 12);
                    // Door frame/track (horizontal)
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(px + 6, py + 5, 3, ph - 12);
                    ctx.fillRect(px + pw - 9, py + 5, 3, ph - 12);
                    // Subtle reflection on black door
                    ctx.fillStyle = 'rgba(255,255,255,0.05)';
                    ctx.fillRect(px + 12, py + 7, pw - 24, 4);
                    // Handle (silver bar - horizontal)
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + pw/2 - 20, py + 8, 40, 3);
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(px + pw/2 - 18, py + 9, 36, 1);
                    break;

                case 'nightstand':
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px + 3, py + 3, pw - 6, ph/2 - 2);
                    // Drawer
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(px + 4, py + ph/2 + 2, pw - 8, ph/2 - 6);
                    // Handle
                    ctx.fillStyle = '#b8a878';
                    ctx.fillRect(px + pw/2 - 6, py + ph/2 + 8, 12, 4);
                    break;

                case 'lamp':
                    const flicker = game.lampFlicker;
                    // Base
                    ctx.fillStyle = '#a89878';
                    ctx.fillRect(px + 4, py + 8, pw - 8, ph - 6);
                    // Shade
                    ctx.fillStyle = `rgba(255, 240, 200, ${0.6 * flicker})`;
                    ctx.beginPath();
                    ctx.moveTo(px + 2, py + 8);
                    ctx.lineTo(px + pw - 2, py + 8);
                    ctx.lineTo(px + pw/2 + 4, py);
                    ctx.lineTo(px + pw/2 - 4, py);
                    ctx.fill();
                    // Glow
                    ctx.fillStyle = `rgba(255, 220, 150, ${0.15 * flicker})`;
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + 4, 20, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'plant':
                    // Pot
                    ctx.fillStyle = '#9a6a5a';
                    ctx.fillRect(px + 8, py + ph - 16, pw - 16, 14);
                    ctx.fillStyle = '#a87a6a';
                    ctx.fillRect(px + 6, py + ph - 18, pw - 12, 5);
                    // Soil
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(px + 10, py + ph - 18, pw - 20, 4);
                    // Leaves
                    ctx.fillStyle = '#4a8a4a';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph/2, pw/2 - 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#5a9a5a';
                    ctx.beginPath();
                    ctx.arc(px + pw/2 - 5, py + ph/2 - 6, pw/3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#6aaa6a';
                    ctx.beginPath();
                    ctx.arc(px + pw/2 + 4, py + ph/2 - 3, pw/4, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'closet':
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, ph);
                    // Doors
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px + 4, py + 4, pw/2 - 6, ph - 8);
                    ctx.fillRect(px + pw/2 + 2, py + 4, pw/2 - 6, ph - 8);
                    // Door panels
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px + 8, py + 10, pw/2 - 14, ph/3 - 10);
                    ctx.fillRect(px + 8, py + ph/3 + 6, pw/2 - 14, ph/3 - 10);
                    ctx.fillRect(px + pw/2 + 6, py + 10, pw/2 - 14, ph/3 - 10);
                    ctx.fillRect(px + pw/2 + 6, py + ph/3 + 6, pw/2 - 14, ph/3 - 10);
                    // Handles
                    ctx.fillStyle = '#b8a878';
                    ctx.fillRect(px + pw/2 - 8, py + ph/2 - 2, 5, 12);
                    ctx.fillRect(px + pw/2 + 3, py + ph/2 - 2, 5, 12);
                    break;

                case 'workbench':
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#6a5a4a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 10);
                    // Tools on surface
                    ctx.fillStyle = '#666';
                    ctx.fillRect(px + 20, py + 10, 30, 8);
                    ctx.fillStyle = '#c44';
                    ctx.fillRect(px + 60, py + 8, 14, 14);
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + 85, py + 12, 20, 6);
                    // Pegboard
                    ctx.fillStyle = '#5a5040';
                    ctx.fillRect(px + 10, py - 30, pw - 20, 28);
                    // Hanging tools
                    ctx.fillStyle = '#777';
                    ctx.fillRect(px + 20, py - 22, 4, 15);
                    ctx.fillRect(px + 35, py - 25, 3, 18);
                    ctx.fillRect(px + 50, py - 20, 8, 12);
                    break;

                case 'screwdriver':
                    if (!game.flags.screwdriverTaken) {
                        // Handle
                        ctx.fillStyle = '#ff8800';
                        ctx.fillRect(px + 2, py + 2, 20, 12);
                        ctx.fillStyle = '#cc6600';
                        ctx.fillRect(px + 4, py + 4, 16, 2);
                        ctx.fillRect(px + 4, py + 10, 16, 2);
                        // Shaft
                        ctx.fillStyle = '#999';
                        ctx.fillRect(px + 22, py + 5, 14, 6);
                        // Tip
                        ctx.fillStyle = '#777';
                        ctx.beginPath();
                        ctx.moveTo(px + 36, py + 5);
                        ctx.lineTo(px + 42, py + 8);
                        ctx.lineTo(px + 36, py + 11);
                        ctx.fill();
                    }
                    break;

                case 'condomBox':
                    // Small box of condoms - recognizable design
                    if (!game.flags.condomsTaken) {
                        // Box base (blue)
                        ctx.fillStyle = '#2255aa';
                        ctx.fillRect(px, py, pw, ph);
                        // Gold/yellow band across middle
                        ctx.fillStyle = '#ddaa33';
                        ctx.fillRect(px, py + ph * 0.35, pw, ph * 0.3);
                        // Darker edge
                        ctx.fillStyle = '#1a4488';
                        ctx.fillRect(px, py, pw, 2);
                        ctx.fillRect(px, py + ph - 2, pw, 2);
                        // Small heart icon
                        ctx.fillStyle = '#ff6688';
                        const hx = px + pw/2, hy = py + ph * 0.5;
                        ctx.beginPath();
                        ctx.arc(hx - 2, hy - 1, 2, 0, Math.PI * 2);
                        ctx.arc(hx + 2, hy - 1, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(hx - 4, hy);
                        ctx.lineTo(hx, hy + 4);
                        ctx.lineTo(hx + 4, hy);
                        ctx.fill();
                    }
                    break;

                case 'toolbox':
                    ctx.fillStyle = '#c44';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#a33';
                    ctx.fillRect(px + 4, py, pw - 8, 10);
                    // Handle
                    ctx.fillStyle = '#555';
                    ctx.fillRect(px + pw/2 - 12, py - 4, 24, 8);
                    ctx.fillStyle = '#444';
                    ctx.fillRect(px + pw/2 - 8, py - 2, 16, 4);
                    // Latch
                    ctx.fillStyle = '#b8a878';
                    ctx.fillRect(px + pw/2 - 5, py + ph - 14, 10, 10);
                    ctx.fillStyle = '#a89868';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph - 9, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'metalShelves':
                    // Posts
                    ctx.fillStyle = '#666';
                    ctx.fillRect(px, py, 5, ph);
                    ctx.fillRect(px + pw - 5, py, 5, ph);
                    // Shelves
                    const shelfItemWidths = [15, 12, 18, 14, 16];
                    for (let i = 0; i < 5; i++) {
                        const shelfY = py + 10 + i * (ph - 20) / 5;
                        ctx.fillStyle = '#777';
                        ctx.fillRect(px, shelfY, pw, 5);
                        // Items
                        const colors = ['#885533', '#558855', '#555588', '#888555', '#885588'];
                        ctx.fillStyle = colors[i % colors.length];
                        const itemW = shelfItemWidths[i];
                        const itemH = (ph - 20) / 5 - 8;
                        ctx.fillRect(px + 7, shelfY - itemH, itemW, itemH);
                    }
                    break;

                case 'door':
                case 'exitDoor':
                    const shake = sprite === 'door' ? game.doorShake : 0;
                    ctx.save();
                    ctx.translate(shake, 0);
                    ctx.fillStyle = '#5a3a1a';
                    ctx.fillRect(px, py, pw, ph);
                    // Panels
                    ctx.fillStyle = '#6a4a2a';
                    ctx.fillRect(px + 4, py + 8, pw - 8, ph/3 - 12);
                    ctx.fillRect(px + 4, py + ph/3 + 4, pw - 8, ph/3 - 8);
                    ctx.fillRect(px + 4, py + 2*ph/3, pw - 8, ph/3 - 8);
                    // Handle
                    ctx.fillStyle = '#c9a050';
                    ctx.beginPath();
                    ctx.arc(px + pw - 8, py + ph/2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#b89040';
                    ctx.beginPath();
                    ctx.arc(px + pw - 8, py + ph/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    break;

                case 'coatRack':
                    // Pole
                    ctx.fillStyle = '#444';
                    ctx.fillRect(px + pw/2 - 3, py + 12, 6, ph - 12);
                    // Base
                    ctx.fillStyle = '#555';
                    ctx.fillRect(px + 2, py + ph - 8, pw - 4, 8);
                    // Top hooks
                    ctx.fillRect(px, py + 14, pw, 5);
                    // Coat
                    ctx.fillStyle = '#4a5a6a';
                    ctx.fillRect(px + 4, py + 20, 14, 28);
                    ctx.fillStyle = '#3a4a5a';
                    ctx.fillRect(px + 6, py + 22, 10, 24);
                    break;

                case 'smallTable':
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px + 3, py + 3, pw - 6, ph - 8);
                    // Legs hint
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(px + 4, py + ph - 4, 4, 4);
                    ctx.fillRect(px + pw - 8, py + ph - 4, 4, 4);
                    // Bloody keys on table (when killer dropped them)
                    if (game.flags.ndKeysOnTable && game.currentScreen === 'neighborDown') {
                        // Blood stain
                        ctx.fillStyle = 'rgba(100, 20, 20, 0.6)';
                        ctx.beginPath();
                        ctx.arc(px + pw/2 + 5, py + 12, 12, 0, Math.PI * 2);
                        ctx.fill();
                        // Key ring
                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(px + pw/2 + 5, py + 10, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        // Keys
                        ctx.fillStyle = '#aa9944';
                        ctx.fillRect(px + pw/2 - 5, py + 8, 12, 4);
                        ctx.fillRect(px + pw/2 + 8, py + 6, 4, 10);
                        ctx.fillStyle = '#999';
                        ctx.fillRect(px + pw/2 - 2, py + 14, 8, 3);
                    }
                    break;

                case 'note':
                    if (!game.flags.noteTaken) {
                        ctx.fillStyle = '#fff8dc';
                        ctx.fillRect(px, py, pw, ph);
                        ctx.strokeStyle = '#d4c8a0';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, pw, ph);
                        // Lines
                        ctx.strokeStyle = '#ccc0a0';
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            ctx.moveTo(px + 3, py + 4 + i * 4);
                            ctx.lineTo(px + pw - 3, py + 4 + i * 4);
                        }
                        ctx.stroke();
                    }
                    break;

                case 'hiddenNote':
                    if (!game.flags.neighborNoteTaken) {
                        // Crumpled/folded note
                        ctx.fillStyle = '#e8e0c8';
                        ctx.fillRect(px, py, pw, ph);
                        ctx.fillStyle = '#d8d0b8';
                        ctx.fillRect(px + 2, py + 2, pw/2 - 2, ph - 4);
                        ctx.strokeStyle = '#b8a888';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, pw, ph);
                        // Crease lines
                        ctx.strokeStyle = '#c8b898';
                        ctx.beginPath();
                        ctx.moveTo(px + pw/2, py);
                        ctx.lineTo(px + pw/2, py + ph);
                        ctx.stroke();
                    }
                    break;

                case 'stairs':
                    // Black spiral staircase going up
                    const centerX = px + pw/2;
                    const centerY = py + ph/2;
                    const radius = Math.min(pw, ph) / 2 - 4;

                    // Central pole
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Spiral steps (viewed from above)
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
                        const nextAngle = ((i + 1) / 8) * Math.PI * 2 - Math.PI / 2;

                        // Step wedge
                        ctx.fillStyle = i % 2 === 0 ? '#2a2a2a' : '#1a1a1a';
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.arc(centerX, centerY, radius, angle, nextAngle);
                        ctx.closePath();
                        ctx.fill();

                        // Step edge highlight
                        ctx.strokeStyle = '#3a3a3a';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
                        ctx.stroke();
                    }

                    // Outer ring (railing)
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius + 2, 0, Math.PI * 2);
                    ctx.stroke();

                    // Arrow indicating up
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.moveTo(centerX, py + 8);
                    ctx.lineTo(centerX - 8, py + 20);
                    ctx.lineTo(centerX + 8, py + 20);
                    ctx.fill();
                    break;

                case 'shoeRack':
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, ph);
                    // Shoes
                    ctx.fillStyle = '#222';
                    ctx.fillRect(px + 4, py + 4, 14, 10);
                    ctx.fillRect(px + 6, py + 6, 10, 6);
                    ctx.fillStyle = '#442222';
                    ctx.fillRect(px + 22, py + 4, 14, 10);
                    break;

                // Neighbor apartment furniture
                case 'sofa':
                    ctx.fillStyle = '#5a4a6a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#6a5a7a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 10);
                    // Cushions
                    ctx.fillStyle = '#5a4a6a';
                    ctx.fillRect(px + 8, py + 8, pw/3 - 8, ph - 20);
                    ctx.fillRect(px + pw/3 + 4, py + 8, pw/3 - 8, ph - 20);
                    ctx.fillRect(px + 2*pw/3, py + 8, pw/3 - 8, ph - 20);
                    // Back
                    ctx.fillStyle = '#4a3a5a';
                    ctx.fillRect(px + 2, py, pw - 4, 8);
                    break;

                case 'coffeeTable':
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);
                    // Magazine
                    ctx.fillStyle = '#8a4a4a';
                    ctx.fillRect(px + 10, py + 8, 20, 14);
                    break;

                case 'tv':
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 16);
                    // Screen - show content if on
                    if (game.tv.on) {
                        // Animated screen glow
                        const channel = TV_CHANNELS[game.tv.channel];
                        if (channel.id === 'static') {
                            // Static noise
                            for (let i = 0; i < 20; i++) {
                                ctx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 0.5)`;
                                ctx.fillRect(px + 6 + Math.random() * (pw - 14), py + 6 + Math.random() * (ph - 22), 4, 4);
                            }
                        } else if (channel.id === 'news') {
                            ctx.fillStyle = '#1a3a6a';
                            ctx.fillRect(px + 6, py + 6, pw - 12, ph - 20);
                            ctx.fillStyle = '#c00';
                            ctx.fillRect(px + 6, py + ph - 22, pw - 12, 6);
                        } else if (channel.id === 'cartoon') {
                            ctx.fillStyle = '#87CEEB';
                            ctx.fillRect(px + 6, py + 6, pw - 12, (ph - 20) * 0.6);
                            ctx.fillStyle = '#4a8a4a';
                            ctx.fillRect(px + 6, py + 6 + (ph - 20) * 0.6, pw - 12, (ph - 20) * 0.4);
                        }
                        // Screen glow
                        ctx.fillStyle = `rgba(100, 150, 200, ${0.1 + Math.sin(game.gameTime / 300) * 0.05})`;
                        ctx.fillRect(px + 6, py + 6, pw - 12, ph - 20);
                    } else {
                        // Off - dark reflection
                        ctx.fillStyle = 'rgba(50, 50, 80, 0.3)';
                        ctx.fillRect(px + 6, py + 6, pw - 12, ph - 20);
                    }
                    // Stand
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(px + pw/2 - 15, py + ph - 10, 30, 10);
                    // Power LED
                    ctx.fillStyle = game.tv.on ? '#0f0' : '#300';
                    ctx.fillRect(px + pw - 12, py + ph - 14, 4, 4);
                    break;

                case 'fridge':
                    ctx.fillStyle = '#d0d0d0';
                    ctx.fillRect(px, py, pw, ph);
                    // Doors
                    ctx.fillStyle = '#e0e0e0';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph/3 - 4);
                    ctx.fillRect(px + 4, py + ph/3 + 4, pw - 8, 2*ph/3 - 8);
                    // Handles
                    ctx.fillStyle = '#999';
                    ctx.fillRect(px + pw - 12, py + 15, 6, 15);
                    ctx.fillRect(px + pw - 12, py + ph/3 + 20, 6, 20);
                    break;

                case 'counter':
                    ctx.fillStyle = '#5a5040';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#c0b8a0';
                    ctx.fillRect(px, py, pw, 10);
                    // Cabinet doors
                    ctx.fillStyle = '#4a4030';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(px + 6 + i * (pw/3), py + 14, pw/3 - 12, ph - 18);
                    }
                    break;

                case 'kitchenTable':
                    ctx.fillStyle = '#6a5a4a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#7a6a5a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);
                    break;

                case 'kitchenChair':
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px + 6, py, pw - 12, 8);
                    break;

                // ===== 2ND FLOOR SPRITES =====

                case 'hugeWindow':
                    // Window frame (outer)
                    ctx.fillStyle = '#3a3a4a';
                    ctx.fillRect(px, py, pw, ph);

                    // Glass pane dimensions
                    const paneW = pw/2 - 10;
                    const paneH = ph/2 - 10;
                    const leftPaneX = px + 6;
                    const rightPaneX = px + pw/2 + 4;
                    const topPaneY = py + 6;
                    const bottomPaneY = py + ph/2 + 4;

                    // Sky gradient
                    const skyGradient = ctx.createLinearGradient(px, py, px, py + ph);
                    skyGradient.addColorStop(0, '#4a6a9a');
                    skyGradient.addColorStop(0.5, '#6a8aba');
                    skyGradient.addColorStop(1, '#8aaaca');

                    // Draw all 4 glass panes with clipped clouds
                    const panes = [
                        { x: leftPaneX, y: topPaneY, w: paneW, h: paneH },
                        { x: rightPaneX, y: topPaneY, w: paneW, h: paneH },
                        { x: leftPaneX, y: bottomPaneY, w: paneW, h: paneH - 4 },
                        { x: rightPaneX, y: bottomPaneY, w: paneW, h: paneH - 4 }
                    ];

                    const cloudX = (game.gameTime / 50) % (pw + 60) - 30;

                    for (const pane of panes) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(pane.x, pane.y, pane.w, pane.h);
                        ctx.clip();

                        // Sky
                        ctx.fillStyle = skyGradient;
                        ctx.fillRect(pane.x, pane.y, pane.w, pane.h);

                        // Clouds (clipped to this pane)
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(px + cloudX, py + 25, 10, 0, Math.PI * 2);
                        ctx.arc(px + cloudX + 12, py + 22, 13, 0, Math.PI * 2);
                        ctx.arc(px + cloudX + 26, py + 25, 10, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                    }

                    // Window dividers (on top of everything)
                    ctx.fillStyle = '#4a4a5a';
                    ctx.fillRect(px + pw/2 - 3, py, 6, ph);
                    ctx.fillRect(px, py + ph/2 - 3, pw, 6);
                    // Frame border
                    ctx.strokeStyle = '#2a2a3a';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px + 1, py + 1, pw - 2, ph - 2);
                    break;

                case 'balconyDoor':
                    // Frame
                    ctx.fillStyle = '#4a4a5a';
                    ctx.fillRect(px, py, pw, ph);
                    // Glass
                    ctx.fillStyle = '#5a7a9a';
                    ctx.fillRect(px + 6, py + 6, pw - 12, ph - 20);
                    // Handle
                    ctx.fillStyle = '#c9a050';
                    ctx.fillRect(px + pw - 14, py + ph/2, 6, 12);
                    // Reflection
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(px + 10, py + 10, pw/3, ph - 30);
                    break;

                case 'stairsDown':
                    // Black spiral staircase going down
                    const centerXD = px + pw/2;
                    const centerYD = py + ph/2;
                    const radiusD = Math.min(pw, ph) / 2 - 4;

                    // Central pole
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(centerXD, centerYD, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#0a0a0a';
                    ctx.beginPath();
                    ctx.arc(centerXD, centerYD, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Spiral steps (viewed from above, darker - going down)
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
                        const nextAngle = ((i + 1) / 8) * Math.PI * 2 - Math.PI / 2;

                        // Step wedge
                        ctx.fillStyle = i % 2 === 0 ? '#1a1a1a' : '#0f0f0f';
                        ctx.beginPath();
                        ctx.moveTo(centerXD, centerYD);
                        ctx.arc(centerXD, centerYD, radiusD, angle, nextAngle);
                        ctx.closePath();
                        ctx.fill();

                        // Step edge
                        ctx.strokeStyle = '#2a2a2a';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(centerXD, centerYD);
                        ctx.lineTo(centerXD + Math.cos(angle) * radiusD, centerYD + Math.sin(angle) * radiusD);
                        ctx.stroke();
                    }

                    // Outer ring (railing)
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(centerXD, centerYD, radiusD + 2, 0, Math.PI * 2);
                    ctx.stroke();

                    // Arrow indicating down
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.moveTo(centerXD, py + ph - 8);
                    ctx.lineTo(centerXD - 8, py + ph - 20);
                    ctx.lineTo(centerXD + 8, py + ph - 20);
                    ctx.fill();
                    break;

                case 'piano':
                    // Body (grand piano top view)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.moveTo(px, py + ph);
                    ctx.lineTo(px, py + 10);
                    ctx.quadraticCurveTo(px + pw/2, py, px + pw, py + 10);
                    ctx.lineTo(px + pw, py + ph);
                    ctx.closePath();
                    ctx.fill();
                    // Lid
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.moveTo(px + 5, py + ph - 5);
                    ctx.lineTo(px + 5, py + 15);
                    ctx.quadraticCurveTo(px + pw/2, py + 5, px + pw - 5, py + 15);
                    ctx.lineTo(px + pw - 5, py + ph - 5);
                    ctx.closePath();
                    ctx.fill();
                    // Keys area
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(px + 8, py + ph - 20, pw - 16, 15);
                    // Black keys
                    ctx.fillStyle = '#1a1a1a';
                    for (let i = 0; i < 10; i++) {
                        if (i % 7 !== 2 && i % 7 !== 6) {
                            ctx.fillRect(px + 12 + i * ((pw - 24) / 10), py + ph - 20, 4, 10);
                        }
                    }
                    // Shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(px + 10, py + 20, pw/3, 20);
                    break;

                case 'stool':
                    // Round stool
                    ctx.fillStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2, pw/2 - 4, ph/2 - 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2 + 3, pw/2 - 6, ph/2 - 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'tvLarge':
                    // Large flatscreen TV
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 12);
                    if (game.tv.on) {
                        const channel = TV_CHANNELS[game.tv.channel];
                        if (channel.id === 'news') {
                            ctx.fillStyle = '#1a3a6a';
                        } else if (channel.id === 'teletubbies') {
                            ctx.fillStyle = '#5cb85c';
                        } else {
                            ctx.fillStyle = '#3a1a1a';
                        }
                        ctx.fillRect(px + 6, py + 6, pw - 12, ph - 16);
                        ctx.fillStyle = `rgba(100, 150, 200, ${0.1 + Math.sin(game.gameTime / 300) * 0.05})`;
                        ctx.fillRect(px + 6, py + 6, pw - 12, ph - 16);
                    } else {
                        ctx.fillStyle = 'rgba(50, 50, 80, 0.3)';
                        ctx.fillRect(px + 6, py + 6, pw - 12, ph - 16);
                    }
                    ctx.fillStyle = game.tv.on ? '#0f0' : '#300';
                    ctx.fillRect(px + pw/2 - 2, py + ph - 6, 4, 3);
                    break;

                case 'tvStand':
                    ctx.fillStyle = '#3a3535';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#4a4545';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph/2 - 4);
                    // Cabinet doors
                    ctx.fillStyle = '#2a2525';
                    ctx.fillRect(px + 6, py + ph/2 + 2, pw/2 - 10, ph/2 - 6);
                    ctx.fillRect(px + pw/2 + 4, py + ph/2 + 2, pw/2 - 10, ph/2 - 6);
                    break;

                case 'largeSofa':
                    // Back
                    ctx.fillStyle = '#5a4a6a';
                    ctx.fillRect(px, py, pw, ph * 0.4);
                    // Seat cushions
                    ctx.fillStyle = '#6a5a7a';
                    ctx.fillRect(px + 4, py + ph * 0.35, pw - 8, ph * 0.5);
                    // Cushion dividers
                    ctx.strokeStyle = '#4a3a5a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(px + pw/3, py + ph * 0.35);
                    ctx.lineTo(px + pw/3, py + ph * 0.85);
                    ctx.moveTo(px + 2*pw/3, py + ph * 0.35);
                    ctx.lineTo(px + 2*pw/3, py + ph * 0.85);
                    ctx.stroke();
                    // Arms
                    ctx.fillStyle = '#5a4a6a';
                    ctx.fillRect(px, py + ph * 0.3, 10, ph * 0.6);
                    ctx.fillRect(px + pw - 10, py + ph * 0.3, 10, ph * 0.6);
                    // Pillows
                    ctx.fillStyle = '#7a6a8a';
                    ctx.beginPath();
                    ctx.ellipse(px + 20, py + ph * 0.5, 12, 10, -0.3, 0, Math.PI * 2);
                    ctx.ellipse(px + pw - 20, py + ph * 0.5, 12, 10, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'lShapedSofa':
                    // Gray L-shaped sofa - long part on left, faces TV
                    // Long left section (horizontal)
                    ctx.fillStyle = '#5a5a5e';
                    ctx.fillRect(px, py + ph * 0.3, pw * 0.7, ph * 0.7);
                    // Back of long section
                    ctx.fillStyle = '#4a4a4e';
                    ctx.fillRect(px, py, pw * 0.7, ph * 0.35);
                    // Short right section (vertical extension)
                    ctx.fillStyle = '#5a5a5e';
                    ctx.fillRect(px + pw * 0.55, py + ph * 0.3, pw * 0.45, ph * 0.5);
                    // Back of short section
                    ctx.fillStyle = '#4a4a4e';
                    ctx.fillRect(px + pw * 0.85, py + ph * 0.3, pw * 0.15, ph * 0.5);
                    // Seat cushions on long section
                    ctx.fillStyle = '#6a6a6e';
                    ctx.fillRect(px + 4, py + ph * 0.35, pw * 0.65 - 8, ph * 0.5);
                    // Seat cushion on short section
                    ctx.fillRect(px + pw * 0.58, py + ph * 0.38, pw * 0.24, ph * 0.38);
                    // Cushion dividers
                    ctx.strokeStyle = '#4a4a4e';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(px + pw * 0.22, py + ph * 0.35);
                    ctx.lineTo(px + pw * 0.22, py + ph * 0.82);
                    ctx.moveTo(px + pw * 0.44, py + ph * 0.35);
                    ctx.lineTo(px + pw * 0.44, py + ph * 0.82);
                    ctx.stroke();
                    // Pillows
                    ctx.fillStyle = '#7a7a7e';
                    ctx.beginPath();
                    ctx.ellipse(px + 18, py + ph * 0.45, 10, 8, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.33, py + ph * 0.45, 10, 8, 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'grayRug':
                    // Gray rug for under sofa
                    ctx.fillStyle = '#4a4a50';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#5a5a5e';
                    ctx.fillRect(px + 6, py + 6, pw - 12, ph - 12);
                    // Subtle pattern - diagonal lines (clipped to rug bounds)
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(px, py, pw, ph);
                    ctx.clip();
                    ctx.strokeStyle = '#48484c';
                    ctx.lineWidth = 1;
                    for (let i = -ph; i < pw + ph; i += 12) {
                        ctx.beginPath();
                        ctx.moveTo(px + i, py + ph);
                        ctx.lineTo(px + i + ph, py);
                        ctx.stroke();
                    }
                    ctx.restore();
                    // Border
                    ctx.strokeStyle = '#3a3a3e';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(px + 3, py + 3, pw - 6, ph - 6);
                    break;

                case 'longWardrobe':
                    // Full-wall wardrobe with single sliding black door
                    // Main body (wood frame)
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px, py, pw, ph);
                    // Frame edges
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px, py, pw, 3);
                    ctx.fillRect(px, py + ph - 3, pw, 3);
                    ctx.fillRect(px, py, 4, ph);
                    ctx.fillRect(px + pw - 4, py, 4, ph);

                    // Single large black sliding door panel
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(px + 6, py + 4, pw - 12, ph - 10);
                    // Subtle reflection at top
                    ctx.fillStyle = 'rgba(255,255,255,0.04)';
                    ctx.fillRect(px + 8, py + 6, pw - 16, 3);
                    // Handle (silver bar in center)
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + pw/2 - 20, py + 7, 40, 3);
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(px + pw/2 - 18, py + 8, 36, 1);
                    break;

                case 'largeCarpet':
                    // Large bedroom carpet - warm brownish tone
                    ctx.fillStyle = '#6a5040';
                    ctx.fillRect(px, py, pw, ph);
                    // Inner area
                    ctx.fillStyle = '#7a6050';
                    ctx.fillRect(px + 8, py + 8, pw - 16, ph - 16);
                    // Decorative border
                    ctx.strokeStyle = '#5a4030';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(px + 4, py + 4, pw - 8, ph - 8);
                    // Inner decorative rectangle
                    ctx.strokeStyle = '#8a7060';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px + 14, py + 14, pw - 28, ph - 28);
                    // Corner decorations
                    ctx.fillStyle = '#5a4030';
                    const cornerSize = 8;
                    ctx.fillRect(px + 14, py + 14, cornerSize, cornerSize);
                    ctx.fillRect(px + pw - 22, py + 14, cornerSize, cornerSize);
                    ctx.fillRect(px + 14, py + ph - 22, cornerSize, cornerSize);
                    ctx.fillRect(px + pw - 22, py + ph - 22, cornerSize, cornerSize);
                    // Fringe on short ends
                    ctx.fillStyle = '#6a5040';
                    for (let i = 0; i < pw / 10; i++) {
                        ctx.fillRect(px + 6 + i * 10, py, 5, 4);
                        ctx.fillRect(px + 6 + i * 10, py + ph - 4, 5, 4);
                    }
                    break;

                case 'floorLamp':
                    // Base
                    ctx.fillStyle = '#4a4a4a';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph - 6, pw/2 - 2, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Pole
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(px + pw/2 - 3, py + 20, 6, ph - 26);
                    // Shade
                    ctx.fillStyle = '#f5e6d3';
                    ctx.beginPath();
                    ctx.moveTo(px + 2, py + 25);
                    ctx.lineTo(px + pw - 2, py + 25);
                    ctx.lineTo(px + pw/2 + 6, py);
                    ctx.lineTo(px + pw/2 - 6, py);
                    ctx.closePath();
                    ctx.fill();
                    // Light glow
                    ctx.fillStyle = `rgba(255, 240, 200, ${0.2 + Math.sin(game.gameTime / 500) * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + 15, 15, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'kitchenIsland':
                    // Counter top
                    ctx.fillStyle = '#8a8070';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#9a9080';
                    ctx.fillRect(px + 4, py + 2, pw - 8, 8);
                    // Base cabinets
                    ctx.fillStyle = '#4a4540';
                    ctx.fillRect(px + 4, py + 12, pw - 8, ph - 16);
                    // Cabinet doors
                    ctx.fillStyle = '#3a3530';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(px + 8 + i * (pw - 16) / 3, py + 16, (pw - 24) / 3, ph - 24);
                    }
                    // Handles
                    ctx.fillStyle = '#888';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(px + 18 + i * (pw - 16) / 3, py + ph/2, 8, 3);
                    }
                    break;

                case 'barStool':
                    // Seat
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + 8, pw/2 - 2, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Legs
                    ctx.strokeStyle = '#4a4a4a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(px + pw/2, py + 12);
                    ctx.lineTo(px + 4, py + ph);
                    ctx.moveTo(px + pw/2, py + 12);
                    ctx.lineTo(px + pw - 4, py + ph);
                    ctx.stroke();
                    // Footrest
                    ctx.strokeStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.moveTo(px + 6, py + ph * 0.7);
                    ctx.lineTo(px + pw - 6, py + ph * 0.7);
                    ctx.stroke();
                    break;

                case 'largeFridge':
                    // Main body
                    ctx.fillStyle = '#c8c8c8';
                    ctx.fillRect(px, py, pw, ph);
                    // Freezer door
                    ctx.fillStyle = '#d8d8d8';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph * 0.3 - 6);
                    // Main door
                    ctx.fillRect(px + 4, py + ph * 0.3 + 2, pw - 8, ph * 0.7 - 6);
                    // Handles
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + pw - 12, py + 15, 5, 18);
                    ctx.fillRect(px + pw - 12, py + ph * 0.3 + 15, 5, 25);
                    // Ice/water dispenser
                    ctx.fillStyle = '#555';
                    ctx.fillRect(px + 10, py + ph * 0.5, 20, 25);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(px + 12, py + ph * 0.5 + 3, 16, 8);
                    break;

                case 'kitchenSink':
                    // Counter
                    ctx.fillStyle = '#9a9080';
                    ctx.fillRect(px, py, pw, ph);
                    // Basin
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + 6, py + 6, pw - 12, ph - 12);
                    ctx.fillStyle = '#666';
                    ctx.fillRect(px + 10, py + 10, pw - 20, ph - 20);
                    // Faucet
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(px + pw/2 - 3, py + 2, 6, 10);
                    ctx.fillRect(px + pw/2 - 8, py + 2, 16, 4);
                    // Drain
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph/2 + 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'stove':
                    // Body
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(px, py, pw, ph);
                    // Burners
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(px + pw * 0.3, py + ph * 0.4, 10, 0, Math.PI * 2);
                    ctx.arc(px + pw * 0.7, py + ph * 0.4, 10, 0, Math.PI * 2);
                    ctx.fill();
                    // Burner rings
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(px + pw * 0.3, py + ph * 0.4, 6, 0, Math.PI * 2);
                    ctx.arc(px + pw * 0.7, py + ph * 0.4, 6, 0, Math.PI * 2);
                    ctx.stroke();
                    // Knobs
                    ctx.fillStyle = '#555';
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.arc(px + 8 + i * (pw - 16) / 3, py + ph - 6, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;

                // ============ NEIGHBOR APARTMENT SPRITES ============

                case 'lockedDoor':
                    // Heavy steel door - front door of neighbor
                    ctx.fillStyle = '#3a3530';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#4a4540';
                    ctx.fillRect(px + 3, py + 3, pw - 6, ph - 6);
                    // Reinforced frame
                    ctx.fillStyle = '#2a2520';
                    ctx.fillRect(px, py, 3, ph);
                    ctx.fillRect(px + pw - 3, py, 3, ph);
                    // Multiple deadbolts
                    ctx.fillStyle = '#666';
                    ctx.fillRect(px + pw - 8, py + 15, 6, 8);
                    ctx.fillRect(px + pw - 8, py + 35, 6, 8);
                    ctx.fillRect(px + pw - 8, py + 55, 6, 8);
                    // Handle
                    ctx.fillStyle = '#777';
                    ctx.fillRect(px + pw - 12, py + ph/2 - 6, 8, 14);
                    // Dark peephole
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + 20, 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'emptyKeyHook':
                    // Wall-mounted hook without keys - implies killer has them
                    ctx.fillStyle = '#3a3a3a';
                    ctx.fillRect(px + pw/2 - 8, py, 16, 6);
                    // Hook
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + 14, 8, 0.5, Math.PI - 0.5);
                    ctx.lineTo(px + pw/2 - 6, py + 6);
                    ctx.lineTo(px + pw/2 + 6, py + 6);
                    ctx.fill();
                    // Empty text would be unsettling
                    ctx.fillStyle = '#1a1a1a';
                    ctx.font = '6px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText('...', px + pw/2, py + ph - 2);
                    break;

                case 'bathroomDoor':
                    // Bathroom door with light underneath (shower indicator)
                    ctx.fillStyle = '#4a4540';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#3a3530';
                    ctx.fillRect(px + 3, py + 3, pw - 6, ph - 6);
                    // Door frame
                    ctx.fillStyle = '#2a2520';
                    ctx.fillRect(px, py, 3, ph);
                    ctx.fillRect(px + pw - 3, py, 3, ph);
                    ctx.fillRect(px, py, pw, 3);
                    // Handle
                    ctx.fillStyle = '#777';
                    ctx.fillRect(px + pw - 12, py + ph/2, 8, 10);
                    // Light under door - animated glow when killer is showering
                    if (game.flags.exitedHidingSafely || game.hiding.active) {
                        const glowIntensity = 0.5 + Math.sin(Date.now() / 300) * 0.2;
                        ctx.fillStyle = `rgba(255, 240, 180, ${glowIntensity})`;
                        ctx.fillRect(px + 5, py + ph - 5, pw - 10, 5);
                        // Steam wisps
                        ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                        const steamX = px + pw/2 + Math.sin(Date.now() / 400) * 5;
                        ctx.beginPath();
                        ctx.arc(steamX - 10, py + 10, 4, 0, Math.PI * 2);
                        ctx.arc(steamX + 5, py + 15, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;

                case 'metalBox':
                    // Small metal box - empty, ominous
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);
                    // Lock mechanism
                    ctx.fillStyle = '#333';
                    ctx.fillRect(px + pw/2 - 5, py + 2, 10, 6);
                    // Handle
                    ctx.fillStyle = '#666';
                    ctx.fillRect(px + pw/2 - 8, py + ph/2 - 2, 16, 4);
                    // Scratches
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(px + 5, py + 12);
                    ctx.lineTo(px + 20, py + 18);
                    ctx.moveTo(px + 10, py + 8);
                    ctx.lineTo(px + 25, py + 15);
                    ctx.stroke();
                    break;

                case 'polaroidWall':
                    // Wall of disturbing polaroids
                    ctx.fillStyle = '#2a2522';
                    ctx.fillRect(px, py, pw, ph);
                    // Individual polaroids (faces obscured)
                    const polaroidColors = ['#e8e4e0', '#e0dcd8', '#d8d4d0'];
                    for (let i = 0; i < 5; i++) {
                        const polX = px + 2 + (i % 2) * 18;
                        const polY = py + 4 + Math.floor(i / 2) * 24;
                        const rot = (i - 2) * 0.1;
                        ctx.save();
                        ctx.translate(polX + 8, polY + 10);
                        ctx.rotate(rot);
                        // Polaroid frame
                        ctx.fillStyle = polaroidColors[i % 3];
                        ctx.fillRect(-8, -10, 16, 20);
                        // Dark/blurred image area
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-6, -8, 12, 12);
                        // Ominous red tint on some
                        if (i % 2 === 0) {
                            ctx.fillStyle = 'rgba(80, 20, 20, 0.4)';
                            ctx.fillRect(-6, -8, 12, 12);
                        }
                        ctx.restore();
                    }
                    break;

                case 'newspapers':
                    // Stack of newspaper clippings
                    ctx.fillStyle = '#d8d0c0';
                    for (let i = 0; i < 4; i++) {
                        ctx.fillRect(px + i * 2, py + i * 3, pw - 8, ph - 10);
                    }
                    // Headlines (red marks/circles)
                    ctx.strokeStyle = '#8a2020';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph/2, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Text lines
                    ctx.fillStyle = '#333';
                    ctx.fillRect(px + 4, py + 6, pw - 14, 2);
                    ctx.fillRect(px + 4, py + 12, pw - 18, 2);
                    ctx.fillRect(px + 4, py + 18, pw - 16, 2);
                    break;

                case 'darkRug':
                    // Dark, stained rug
                    ctx.fillStyle = '#2a2020';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#3a2828';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);
                    // Suspicious darker stains
                    ctx.fillStyle = 'rgba(30, 10, 10, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.3, py + ph * 0.6, 15, 10, 0.3, 0, Math.PI * 2);
                    ctx.ellipse(px + pw * 0.7, py + ph * 0.4, 12, 8, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'creepyShelf':
                    // Shelf with odd items
                    ctx.fillStyle = '#3a3030';
                    ctx.fillRect(px, py, pw, ph);
                    // Shelf
                    ctx.fillStyle = '#4a3838';
                    ctx.fillRect(px + 2, py + ph/2, pw - 4, 4);
                    // Strange objects - jars
                    ctx.fillStyle = '#556';
                    ctx.fillRect(px + 5, py + 8, 12, 18);
                    ctx.fillStyle = 'rgba(100, 60, 60, 0.5)';
                    ctx.fillRect(px + 7, py + 12, 8, 12);
                    // Another jar
                    ctx.fillStyle = '#565';
                    ctx.fillRect(px + 22, py + 10, 10, 15);
                    ctx.fillStyle = 'rgba(60, 80, 60, 0.5)';
                    ctx.fillRect(px + 24, py + 13, 6, 10);
                    break;

                case 'stainedBed':
                    // Unmade bed with stains - hiding spot
                    // Frame
                    ctx.fillStyle = '#3a2a20';
                    ctx.fillRect(px, py, pw, ph);
                    // Headboard
                    ctx.fillStyle = '#4a3a30';
                    ctx.fillRect(px + 4, py, pw - 8, 12);
                    // Mattress
                    ctx.fillStyle = '#6a6058';
                    ctx.fillRect(px + 4, py + 10, pw - 8, ph - 14);
                    // Stained/crumpled sheets
                    ctx.fillStyle = '#8a8078';
                    ctx.fillRect(px + 8, py + 14, pw - 16, ph - 22);
                    // Dark stains
                    ctx.fillStyle = 'rgba(50, 25, 25, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.4, py + ph * 0.5, 18, 12, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(40, 20, 20, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.7, py + ph * 0.7, 12, 8, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Crumpled pillow
                    ctx.fillStyle = '#9a9088';
                    ctx.fillRect(px + 10, py + 16, pw/3, 18);
                    // Gap under bed (visible for hiding hint)
                    ctx.fillStyle = '#0a0808';
                    ctx.fillRect(px + 4, py + ph - 6, pw - 8, 6);
                    break;

                case 'creepyCloset':
                    // Closet with clothes of many sizes
                    ctx.fillStyle = '#3a3028';
                    ctx.fillRect(px, py, pw, ph);
                    // Doors
                    ctx.fillStyle = '#4a4038';
                    ctx.fillRect(px + 3, py + 3, pw/2 - 5, ph - 6);
                    ctx.fillRect(px + pw/2 + 2, py + 3, pw/2 - 5, ph - 6);
                    // Door knobs
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(px + pw/2 - 6, py + ph/2, 3, 0, Math.PI * 2);
                    ctx.arc(px + pw/2 + 6, py + ph/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    // Visible clothes through gap - different sizes
                    ctx.fillStyle = '#3a4a5a';
                    ctx.fillRect(px + pw/2 - 2, py + 8, 4, 20);
                    ctx.fillStyle = '#5a3a3a';
                    ctx.fillRect(px + pw/2 - 1, py + 10, 2, 15);
                    ctx.fillStyle = '#4a5a3a';
                    ctx.fillRect(px + pw/2, py + 12, 3, 18);
                    break;

                case 'stainedRug':
                    // Small rug with obvious stains
                    ctx.fillStyle = '#4a3a30';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#5a4a40';
                    ctx.fillRect(px + 3, py + 3, pw - 6, ph - 6);
                    // Blood-like stains
                    ctx.fillStyle = 'rgba(60, 20, 20, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2, pw/4, ph/4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'dirtyCounter':
                    // Kitchen counter with grime
                    ctx.fillStyle = '#5a5048';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#6a6058';
                    ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);
                    // Stains and grime
                    ctx.fillStyle = 'rgba(40, 30, 20, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(px + 20, py + 15, 12, 8, 0, 0, Math.PI * 2);
                    ctx.ellipse(px + pw - 25, py + 20, 10, 6, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'wallets':
                    // Multiple wallets - implies multiple victims
                    const walletColors = ['#4a3020', '#302820', '#3a3830', '#503828'];
                    for (let i = 0; i < 4; i++) {
                        ctx.fillStyle = walletColors[i];
                        ctx.fillRect(px + i * 10 + (i % 2) * 3, py + (i % 2) * 6, 14, 10);
                        // Wallet fold line
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fillRect(px + i * 10 + (i % 2) * 3 + 6, py + (i % 2) * 6, 2, 10);
                    }
                    break;

                case 'drawer':
                    // Kitchen drawer (duct tape, zip ties inside)
                    ctx.fillStyle = '#4a4038';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#5a5048';
                    ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);
                    // Handle
                    ctx.fillStyle = '#666';
                    ctx.fillRect(px + pw/2 - 8, py + ph/2 - 2, 16, 4);
                    break;

                case 'oldFridge':
                    // Old, yellowed fridge
                    ctx.fillStyle = '#a8a090';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#b8b0a0';
                    ctx.fillRect(px + 3, py + 3, pw - 6, ph * 0.3);
                    ctx.fillRect(px + 3, py + ph * 0.35, pw - 6, ph * 0.6);
                    // Rust spots
                    ctx.fillStyle = 'rgba(100, 60, 40, 0.4)';
                    ctx.beginPath();
                    ctx.arc(px + 10, py + ph - 20, 5, 0, Math.PI * 2);
                    ctx.arc(px + pw - 8, py + 15, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // Handle
                    ctx.fillStyle = '#777';
                    ctx.fillRect(px + pw - 8, py + 20, 4, 15);
                    ctx.fillRect(px + pw - 8, py + ph * 0.5, 4, 20);
                    break;

                case 'dirtySink':
                    // Kitchen sink with grime
                    ctx.fillStyle = '#7a7068';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#6a6058';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);
                    // Water stains
                    ctx.fillStyle = 'rgba(50, 40, 30, 0.5)';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph/2, 8, 0, Math.PI * 2);
                    ctx.fill();
                    // Faucet
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + pw/2 - 3, py, 6, 8);
                    break;

                case 'floorStains':
                    // Dark stains on floor
                    ctx.fillStyle = 'rgba(40, 20, 15, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.3, py + ph * 0.5, pw * 0.25, ph * 0.35, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(30, 15, 10, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.7, py + ph * 0.6, pw * 0.2, ph * 0.25, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'dirtyToilet':
                    // Dirty toilet
                    ctx.fillStyle = '#c8c0b8';
                    ctx.fillRect(px + 6, py + ph - 22, pw - 12, 20);
                    // Bowl
                    ctx.fillStyle = '#d8d0c8';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2 + 5, pw/2 - 8, ph/3 - 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Dirty water
                    ctx.fillStyle = '#8a9888';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2 + 5, pw/3 - 4, ph/4 - 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tank with stains
                    ctx.fillStyle = '#b8b0a8';
                    ctx.fillRect(px + 6, py + 4, pw - 12, ph/3);
                    ctx.fillStyle = 'rgba(80, 60, 40, 0.3)';
                    ctx.fillRect(px + 8, py + 10, 15, 8);
                    break;

                case 'stainedBathtub':
                    // Bathtub with ominous stains
                    ctx.fillStyle = '#c8c0b8';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.fillStyle = '#d8d4d0';
                    ctx.fillRect(px + 5, py + 5, pw - 10, ph - 10);
                    // Dark ring stains
                    ctx.strokeStyle = 'rgba(60, 30, 30, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph/2, pw/3, ph/3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    // Darker stains
                    ctx.fillStyle = 'rgba(50, 20, 20, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.3, py + ph * 0.6, 12, 8, 0, 0, Math.PI * 2);
                    ctx.ellipse(px + pw * 0.7, py + ph * 0.4, 10, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Drain
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph - 15, 6, 0, Math.PI * 2);
                    ctx.fill();
                    // Faucet
                    ctx.fillStyle = '#888';
                    ctx.fillRect(px + pw - 20, py + 8, 14, 10);
                    break;

                case 'suspiciousTarp':
                    // Lumpy tarp covering something human-shaped
                    ctx.fillStyle = '#3a4a3a';
                    ctx.fillRect(px, py, pw, ph);
                    // Tarp texture
                    ctx.fillStyle = '#4a5a4a';
                    for (let i = 0; i < 5; i++) {
                        ctx.fillRect(px + i * 15 + 3, py + 2, 12, ph - 4);
                    }
                    // Lumps suggesting body shape
                    ctx.fillStyle = '#2a3a2a';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.3, py + ph * 0.4, 18, 12, 0.2, 0, Math.PI * 2);
                    ctx.ellipse(px + pw * 0.7, py + ph * 0.6, 22, 14, -0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Dark stain seeping from under
                    ctx.fillStyle = 'rgba(40, 15, 15, 0.7)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.5, py + ph - 5, 25, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Rope/cord tying it
                    ctx.strokeStyle = '#5a4a3a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(px + 10, py + ph * 0.3);
                    ctx.lineTo(px + pw - 10, py + ph * 0.3);
                    ctx.moveTo(px + 15, py + ph * 0.7);
                    ctx.lineTo(px + pw - 15, py + ph * 0.7);
                    ctx.stroke();
                    break;

                case 'scaryStools':
                    // Hooks and scary tools on wall
                    ctx.fillStyle = '#2a2525';
                    ctx.fillRect(px, py, pw, ph);
                    // Pegboard backing
                    ctx.fillStyle = '#3a3230';
                    ctx.fillRect(px + 3, py + 3, pw - 6, ph - 6);
                    // Hooks/pegs
                    ctx.fillStyle = '#555';
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 3; j++) {
                            ctx.beginPath();
                            ctx.arc(px + 12 + i * 15, py + 15 + j * 22, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    // Hanging tools - meat hook
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(px + 12, py + 30, 8, 0.5, Math.PI + 0.5);
                    ctx.stroke();
                    // Saw
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(px + 25, py + 18, 20, 4);
                    ctx.fillStyle = '#555';
                    for (let i = 0; i < 8; i++) {
                        ctx.fillRect(px + 27 + i * 2, py + 22, 1, 3);
                    }
                    // Cleaver
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(px + 15, py + 55, 4, 15);
                    ctx.fillRect(px + 10, py + 50, 18, 8);
                    // Blood stains on tools
                    ctx.fillStyle = 'rgba(80, 25, 25, 0.6)';
                    ctx.fillRect(px + 11, py + 52, 15, 5);
                    break;

                case 'creepyPainting':
                    // Unsettling painting on wall
                    ctx.fillStyle = '#4a4035';
                    ctx.fillRect(px, py, pw, ph);
                    // Inner frame
                    ctx.fillStyle = '#5a5045';
                    ctx.fillRect(px + 4, py + 4, pw - 8, ph - 8);
                    // Dark canvas
                    ctx.fillStyle = '#1a1815';
                    ctx.fillRect(px + 8, py + 8, pw - 16, ph - 16);
                    // Abstract dark shapes - face-like
                    ctx.fillStyle = '#2a2520';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph * 0.4, pw/4, ph/4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Hollow eyes
                    ctx.fillStyle = '#0a0805';
                    ctx.beginPath();
                    ctx.arc(px + pw * 0.35, py + ph * 0.35, 5, 0, Math.PI * 2);
                    ctx.arc(px + pw * 0.65, py + ph * 0.35, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // Red accent - like a wound/mouth
                    ctx.fillStyle = 'rgba(80, 20, 20, 0.7)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw/2, py + ph * 0.55, 10, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'boxes':
                    // Stacked cardboard boxes
                    const boxColors = ['#6a5a4a', '#5a4a3a', '#7a6a5a'];
                    // Bottom box
                    ctx.fillStyle = boxColors[0];
                    ctx.fillRect(px, py + ph * 0.5, pw * 0.7, ph * 0.5);
                    ctx.fillStyle = '#4a3a2a';
                    ctx.fillRect(px + 5, py + ph * 0.55, pw * 0.7 - 10, 3);
                    // Top left box
                    ctx.fillStyle = boxColors[1];
                    ctx.fillRect(px + pw * 0.1, py + ph * 0.1, pw * 0.5, ph * 0.45);
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(px + pw * 0.15, py + ph * 0.15, pw * 0.5 - 10, 2);
                    // Top right box
                    ctx.fillStyle = boxColors[2];
                    ctx.fillRect(px + pw * 0.55, py + ph * 0.2, pw * 0.4, ph * 0.4);
                    // Tape on boxes
                    ctx.fillStyle = '#8a7a5a';
                    ctx.fillRect(px + pw * 0.3, py + ph * 0.1, 4, ph * 0.25);
                    ctx.fillRect(px + pw * 0.72, py + ph * 0.2, 4, ph * 0.2);
                    break;

                case 'chairs':
                    // Two simple chairs
                    // Chair 1
                    ctx.fillStyle = '#4a3a30';
                    // Seat
                    ctx.fillRect(px + 5, py + 20, 25, 20);
                    // Back
                    ctx.fillRect(px + 5, py, 25, 5);
                    ctx.fillRect(px + 8, py + 5, 4, 15);
                    ctx.fillRect(px + 23, py + 5, 4, 15);
                    // Legs
                    ctx.fillRect(px + 7, py + 38, 4, 12);
                    ctx.fillRect(px + 24, py + 38, 4, 12);
                    // Chair 2
                    ctx.fillStyle = '#3a2a20';
                    ctx.fillRect(px + 38, py + 25, 22, 18);
                    ctx.fillRect(px + 38, py + 8, 22, 4);
                    ctx.fillRect(px + 40, py + 12, 3, 13);
                    ctx.fillRect(px + 54, py + 12, 3, 13);
                    ctx.fillRect(px + 40, py + 41, 4, 10);
                    ctx.fillRect(px + 53, py + 41, 4, 10);
                    break;

                case 'bloodyKeys':
                    // Bloody keyring with multiple keys
                    // Ring
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(px + pw/2, py + ph/2, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Keys - different shapes
                    const keyColors = ['#8a7a5a', '#7a6a4a', '#6a5a3a', '#9a8a6a', '#5a4a2a'];
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
                        const kx = px + pw/2 + Math.cos(angle) * 6;
                        const ky = py + ph/2 + Math.sin(angle) * 6;
                        ctx.fillStyle = keyColors[i];
                        ctx.fillRect(kx - 1, ky, 3, 10 + i * 2);
                        // Key teeth
                        ctx.fillRect(kx - 3, ky + 8 + i * 2, 2, 3);
                    }
                    // Blood
                    ctx.fillStyle = 'rgba(120, 30, 30, 0.7)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.6, py + ph * 0.7, 6, 4, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(100, 20, 20, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(px + pw * 0.3, py + ph * 0.4, 4, 3, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }

        // ============ DRAW PLAYER ============
        function drawPlayer() {
            const p = game.player;
            const bob = p.isMoving ? Math.sin(p.bobOffset) * 2 : 0;
            const py = p.y + bob;

            // Phone animation state
            const phoneAnim = p.phoneAnimation;
            let rightArmRaised = false;
            let phoneVisible = false;
            let phoneY = 0;

            if (phoneAnim) {
                const progress = phoneAnim.timer / phoneAnim.duration;
                if (phoneAnim.phase === 'taking_out') {
                    // Arm moves from pocket (low) to in front of face - MORE dramatic
                    rightArmRaised = true;
                    phoneY = py + 8 - progress * 26; // starts lower, moves up more
                    phoneVisible = progress > 0.2; // show phone sooner
                } else if (phoneAnim.phase === 'looking') {
                    // Arm stays raised, looking at phone
                    rightArmRaised = true;
                    phoneY = py - 18; // higher position
                    phoneVisible = true;
                } else if (phoneAnim.phase === 'putting_back') {
                    // Arm moves back down
                    rightArmRaised = true;
                    phoneY = py - 18 + progress * 26; // bigger motion back down
                    phoneVisible = progress < 0.8; // hide phone later
                }
            }

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(p.x, p.y + p.height/2 + 2, p.width/2, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = COLORS.playerPants;
            if (p.isMoving) {
                const legOffset = Math.sin(p.bobOffset * 2) * 3;
                ctx.fillRect(p.x - 5, py + 6, 4, 12 + legOffset);
                ctx.fillRect(p.x + 1, py + 6, 4, 12 - legOffset);
            } else {
                ctx.fillRect(p.x - 5, py + 6, 4, 12);
                ctx.fillRect(p.x + 1, py + 6, 4, 12);
            }

            // Body
            ctx.fillStyle = COLORS.playerShirt;
            ctx.fillRect(p.x - 6, py - 8, 12, 16);

            // Arms
            if (p.isMoving && !rightArmRaised) {
                const armSwing = Math.sin(p.bobOffset * 2) * 2;
                ctx.fillRect(p.x - 9, py - 6 + armSwing, 3, 10);
                ctx.fillRect(p.x + 6, py - 6 - armSwing, 3, 10);
            } else if (rightArmRaised) {
                // Left arm normal
                ctx.fillRect(p.x - 9, py - 6, 3, 10);
                // Right arm raised and bent toward body - MORE dramatic motion
                const armProgress = phoneAnim ? phoneAnim.timer / phoneAnim.duration : 0;
                let armY = py - 6;
                if (phoneAnim.phase === 'taking_out') {
                    armY = py + 4 - armProgress * 18; // starts lower, moves up more
                } else if (phoneAnim.phase === 'looking') {
                    armY = py - 14;
                } else if (phoneAnim.phase === 'putting_back') {
                    armY = py - 14 + armProgress * 18; // moves back down
                }
                ctx.fillRect(p.x + 2, armY, 4, 10); // slightly larger arm
            } else {
                ctx.fillRect(p.x - 9, py - 6, 3, 10);
                ctx.fillRect(p.x + 6, py - 6, 3, 10);
            }

            // Hands
            ctx.fillStyle = COLORS.player;
            ctx.fillRect(p.x - 9, py + 2, 3, 3);
            if (rightArmRaised && phoneAnim) {
                // Right hand near phone - MORE dramatic motion
                let handY = py + 2;
                if (phoneAnim.phase === 'taking_out') {
                    handY = py + 10 - (phoneAnim.timer / phoneAnim.duration) * 18; // starts lower
                } else if (phoneAnim.phase === 'looking') {
                    handY = py - 8;
                } else if (phoneAnim.phase === 'putting_back') {
                    handY = py - 8 + (phoneAnim.timer / phoneAnim.duration) * 18; // moves back down
                }
                ctx.fillRect(p.x + 3, handY, 4, 4); // slightly larger hand
            } else {
                ctx.fillRect(p.x + 6, py + 2, 3, 3);
            }

            // Draw phone if visible - LARGER and more visible
            if (phoneVisible) {
                // Phone body (dark) - bigger phone
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(p.x - 1, phoneY, 8, 12);
                // Phone border
                ctx.fillStyle = '#333';
                ctx.fillRect(p.x - 1, phoneY, 8, 1);
                ctx.fillRect(p.x - 1, phoneY + 11, 8, 1);
                // Phone screen (bright glow)
                ctx.fillStyle = '#55aadd';
                ctx.fillRect(p.x, phoneY + 1, 6, 9);
                // Screen content - notification or silent icon
                if (phoneAnim && phoneAnim.phase === 'looking') {
                    // Vibrating/notification icon turning off
                    ctx.fillStyle = '#ff6666';
                    ctx.fillRect(p.x + 2, phoneY + 3, 2, 2);
                    ctx.fillRect(p.x + 1, phoneY + 5, 4, 1);
                    // Screen glow effect
                    ctx.fillStyle = 'rgba(85, 170, 221, 0.3)';
                    ctx.fillRect(p.x - 4, phoneY - 2, 14, 16);
                }
            }

            // Head
            ctx.fillStyle = COLORS.player;
            ctx.fillRect(p.x - 6, py - 18, 12, 12);

            // Hair
            ctx.fillStyle = COLORS.playerHair;
            ctx.fillRect(p.x - 6, py - 18, 12, 5);

            // Face based on direction (or looking at phone)
            ctx.fillStyle = '#222';
            if (rightArmRaised && phoneAnim && phoneAnim.phase === 'looking') {
                // Looking down at phone
                ctx.fillRect(p.x - 3, py - 10, 2, 2);
                ctx.fillRect(p.x + 1, py - 10, 2, 2);
            } else if (p.direction === 'down') {
                ctx.fillRect(p.x - 4, py - 12, 2, 2);
                ctx.fillRect(p.x + 2, py - 12, 2, 2);
            } else if (p.direction === 'up') {
                ctx.fillStyle = COLORS.playerHair;
                ctx.fillRect(p.x - 6, py - 18, 12, 8);
            } else if (p.direction === 'left') {
                ctx.fillRect(p.x - 5, py - 12, 2, 2);
            } else {
                ctx.fillRect(p.x + 3, py - 12, 2, 2);
            }
        }

        // ============ DRAWING ============
        function drawFloor() {
            const screen = screens[game.currentScreen];

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const room of screen.rooms) {
                const rx = room.x * TILE;
                const ry = room.y * TILE;
                const rw = room.w * TILE;
                const rh = room.h * TILE;

                ctx.fillStyle = room.color;
                ctx.fillRect(rx, ry, rw, rh);

                if (room.floor === 'wood') {
                    // Rectangular wooden planks (horizontal)
                    const plankHeight = 12;
                    const plankColors = ['#5a4a3a', '#523f33', '#4d3a2e', '#584838', '#503d30'];

                    for (let py = 0; py < rh; py += plankHeight) {
                        // Offset every other row for realistic plank pattern
                        const rowOffset = (Math.floor(py / plankHeight) % 2) * (TILE / 2);

                        for (let px = -rowOffset; px < rw; px += TILE) {
                            const plankX = rx + px;
                            const plankY = ry + py;
                            const plankW = TILE;

                            // Vary plank colors based on position
                            const colorIndex = (Math.floor(px / TILE) + Math.floor(py / plankHeight)) % plankColors.length;
                            ctx.fillStyle = plankColors[colorIndex];

                            // Clip to room bounds
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(rx, ry, rw, rh);
                            ctx.clip();

                            ctx.fillRect(plankX, plankY, plankW, plankHeight);

                            // Plank edge (groove between planks)
                            ctx.fillStyle = 'rgba(0,0,0,0.25)';
                            ctx.fillRect(plankX, plankY + plankHeight - 1, plankW, 1);

                            // Vertical groove between planks
                            ctx.fillRect(plankX + plankW - 1, plankY, 1, plankHeight);

                            // Wood grain (subtle lines)
                            ctx.fillStyle = 'rgba(0,0,0,0.08)';
                            const grainSeed = (plankX + plankY) % 7;
                            ctx.fillRect(plankX + 3 + grainSeed, plankY + 2, plankW - 10, 1);
                            ctx.fillRect(plankX + 5 + grainSeed, plankY + 6, plankW - 14, 1);
                            ctx.fillRect(plankX + 2 + grainSeed, plankY + 9, plankW - 8, 1);

                            ctx.restore();
                        }
                    }
                } else if (room.floor === 'tile') {
                    // Checkered tile pattern
                    for (let tx = 0; tx < room.w; tx++) {
                        for (let ty = 0; ty < room.h; ty++) {
                            const tileX = rx + tx * TILE;
                            const tileY = ry + ty * TILE;

                            if ((tx + ty) % 2 === 0) {
                                ctx.fillStyle = room.altColor;
                                ctx.fillRect(tileX, tileY, TILE, TILE);
                            }
                            // Tile grout
                            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                            ctx.strokeRect(tileX, tileY, TILE, TILE);
                        }
                    }
                } else {
                    // Concrete (simple alternating)
                    for (let tx = 0; tx < room.w; tx++) {
                        for (let ty = 0; ty < room.h; ty++) {
                            const tileX = rx + tx * TILE;
                            const tileY = ry + ty * TILE;

                            if ((tx + ty) % 2 === 0) {
                                ctx.fillStyle = room.altColor;
                                ctx.fillRect(tileX, tileY, TILE, TILE);
                            }
                            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                            ctx.strokeRect(tileX, tileY, TILE, TILE);
                        }
                    }
                }
            }
        }

        function drawWalls() {
            const screen = screens[game.currentScreen];

            // Outer walls
            ctx.fillStyle = '#4a4035';
            ctx.fillRect(0, 0, canvas.width, TILE * 0.3);
            ctx.fillRect(0, canvas.height - TILE * 0.3, canvas.width, TILE * 0.3);
            ctx.fillRect(0, 0, TILE * 0.3, canvas.height);
            ctx.fillRect(canvas.width - TILE * 0.3, 0, TILE * 0.3, canvas.height);

            // Wall shadow/depth
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(TILE * 0.3, TILE * 0.3, canvas.width - TILE * 0.6, 4);
            ctx.fillRect(TILE * 0.3, TILE * 0.3, 4, canvas.height - TILE * 0.6);

            // Inner walls
            ctx.fillStyle = '#3a3028';
            for (const wall of screen.walls) {
                ctx.fillRect(wall.x * TILE, wall.y * TILE, wall.w * TILE, wall.h * TILE);
            }

            // Doorway floors (draw room color over wall gaps)
            for (const dw of screen.doorways) {
                ctx.fillStyle = COLORS.hallway;
                if (dw.vertical) {
                    ctx.fillRect(dw.x * TILE - 4, dw.y * TILE, 12, dw.h * TILE);
                } else {
                    ctx.fillRect(dw.x * TILE, dw.y * TILE - 4, dw.w * TILE, 12);
                }
            }
        }

        function drawMinimap() {
            const screen = screens[game.currentScreen];
            minimapCtx.fillStyle = '#0a0a0f';
            minimapCtx.fillRect(0, 0, 80, 100);

            const scale = 80 / (12 * TILE);

            for (const room of screen.rooms) {
                minimapCtx.fillStyle = room.color;
                minimapCtx.fillRect(
                    room.x * TILE * scale + 2,
                    room.y * TILE * scale + 2,
                    room.w * TILE * scale - 1,
                    room.h * TILE * scale - 1
                );
            }

            // Player dot
            minimapCtx.fillStyle = '#ffaa00';
            minimapCtx.beginPath();
            minimapCtx.arc(
                game.player.x * scale + 2,
                game.player.y * scale + 2,
                3,
                0,
                Math.PI * 2
            );
            minimapCtx.fill();
        }

        function drawEquippedIcon() {
            const iconCanvas = document.getElementById('equippedIcon');
            const iconCtx = iconCanvas.getContext('2d');
            iconCtx.clearRect(0, 0, 24, 24);
            iconCtx.fillStyle = '#1a2a1e';
            iconCtx.fillRect(0, 0, 24, 24);

            if (game.equipped === 'Destornillador') {
                iconCtx.fillStyle = '#ff8800';
                iconCtx.fillRect(2, 8, 10, 8);
                iconCtx.fillStyle = '#888';
                iconCtx.fillRect(12, 10, 8, 4);
                iconCtx.fillStyle = '#666';
                iconCtx.fillRect(20, 11, 3, 2);
            } else if (game.equipped === 'Llave peque√±a') {
                iconCtx.fillStyle = '#c9a050';
                iconCtx.fillRect(4, 10, 6, 4);
                iconCtx.beginPath();
                iconCtx.arc(7, 12, 4, 0, Math.PI * 2);
                iconCtx.fill();
                iconCtx.fillRect(10, 11, 10, 2);
                iconCtx.fillRect(18, 11, 2, 4);
                iconCtx.fillRect(15, 11, 2, 3);
            } else if (game.equipped === 'Linterna') {
                iconCtx.fillStyle = '#333';
                iconCtx.fillRect(4, 8, 12, 8);
                iconCtx.fillStyle = '#ffee88';
                iconCtx.fillRect(16, 9, 4, 6);
            } else if (game.equipped === 'Nota') {
                iconCtx.fillStyle = '#fff8dc';
                iconCtx.fillRect(5, 4, 14, 16);
                iconCtx.strokeStyle = '#ccc';
                iconCtx.lineWidth = 0.5;
                for (let i = 0; i < 4; i++) {
                    iconCtx.beginPath();
                    iconCtx.moveTo(7, 7 + i * 3);
                    iconCtx.lineTo(17, 7 + i * 3);
                    iconCtx.stroke();
                }
            } else if (game.equipped === 'Cuchillo') {
                // Handle
                iconCtx.fillStyle = '#333';
                iconCtx.fillRect(2, 10, 8, 5);
                iconCtx.fillStyle = '#222';
                iconCtx.fillRect(3, 11, 6, 3);
                // Guard
                iconCtx.fillStyle = '#555';
                iconCtx.fillRect(10, 8, 2, 9);
                // Blade
                iconCtx.fillStyle = '#aaa';
                iconCtx.beginPath();
                iconCtx.moveTo(12, 9);
                iconCtx.lineTo(12, 16);
                iconCtx.lineTo(22, 12);
                iconCtx.closePath();
                iconCtx.fill();
                // Blood
                iconCtx.fillStyle = 'rgba(100, 20, 20, 0.7)';
                iconCtx.fillRect(14, 10, 6, 4);
            } else if (game.equipped === 'Forros') {
                // Condom box mini icon
                iconCtx.fillStyle = '#2255aa';
                iconCtx.fillRect(4, 5, 16, 14);
                iconCtx.fillStyle = '#ddaa33';
                iconCtx.fillRect(4, 10, 16, 4);
                iconCtx.fillStyle = '#ff6688';
                iconCtx.beginPath();
                iconCtx.arc(10, 12, 2, 0, Math.PI * 2);
                iconCtx.arc(14, 12, 2, 0, Math.PI * 2);
                iconCtx.fill();
            }
        }

        // ============ UI ============
        function showDialogue(text, duration = 2500) {
            game.currentDialogue = text;
            game.dialogueTimer = duration;
            document.getElementById('dialogueBox').textContent = text;
            document.getElementById('dialogueBox').style.display = 'block';
        }

        function showTelegram(message, response) {
            // Play notification sound (or silent)
            if (game.phone.silentMode) {
                // Silent - just a subtle visual
                document.getElementById('telegramSilent').classList.add('active');
            } else {
                document.getElementById('telegramSilent').classList.remove('active');
                playAudioFile('notification', { volume: 0.4 });
            }

            document.getElementById('telegramMessage').textContent = message;
            document.getElementById('telegramResponse').textContent = response ? `‚Üí "${response}"` : '';
            document.getElementById('telegramPopup').style.display = 'block';
            game.telegramTimer = 5000;

            const prevSpeed = game.player.speed;
            game.player.speed = 0;
            setTimeout(() => {
                game.player.speed = prevSpeed;
            }, 600);
        }

        // ============ PHONE SILENT MODE ANIMATION ============
        // Now uses character animation instead of popup overlay
        function startPhoneSilentAnimation(callback) {
            game.phone.animationCallback = callback;
            game.player.speed = 0; // Freeze player during animation

            // Start the character phone animation - SLOW so it's visible
            game.player.phoneAnimation = {
                phase: 'taking_out',
                timer: 0,
                duration: 1200 // ms per phase - slower animation
            };

            // Show dialogue after a delay so player sees the animation first
            setTimeout(() => {
                showDialogue('"Mejor en silencio..."', 2000);
            }, 800);
        }

        function updatePhoneAnimation(deltaTime) {
            const anim = game.player.phoneAnimation;
            if (!anim) return;

            anim.timer += deltaTime;

            if (anim.timer >= anim.duration) {
                // Move to next phase
                if (anim.phase === 'taking_out') {
                    anim.phase = 'looking';
                    anim.timer = 0;
                    anim.duration = 2000; // Look at phone much longer
                } else if (anim.phase === 'looking') {
                    anim.phase = 'putting_back';
                    anim.timer = 0;
                    anim.duration = 1200; // Slower putting back
                } else if (anim.phase === 'putting_back') {
                    // Animation complete
                    game.player.phoneAnimation = null;
                    game.phone.silentMode = true;
                    game.player.speed = 2.2;

                    // Update telegram silent icon
                    document.getElementById('telegramSilent').classList.add('active');

                    if (game.phone.animationCallback) {
                        game.phone.animationCallback();
                        game.phone.animationCallback = null;
                    }
                }
            }
        }

        function showLocation() {
            const loc = document.getElementById('locationIndicator');
            loc.textContent = screens[game.currentScreen].name;
            loc.classList.add('visible');
            setTimeout(() => loc.classList.remove('visible'), 2000);
        }

        function toggleInventory() {
            game.showInventory = !game.showInventory;
            const overlay = document.getElementById('inventoryOverlay');
            overlay.style.display = game.showInventory ? 'flex' : 'none';

            if (game.showInventory) {
                renderInventory();
            }
        }

        // ============ COMBINATION LOCK ============
        function showCombinationLock() {
            game.combinationLock.active = true;
            game.combinationLock.digits = [0, 0, 0, 0];
            game.combinationLock.selectedDigit = 0;
            updateCombinationLockUI();
            document.getElementById('combinationLockOverlay').classList.add('active');
            document.getElementById('lockError').textContent = '';
        }

        function hideCombinationLock() {
            game.combinationLock.active = false;
            document.getElementById('combinationLockOverlay').classList.remove('active');
        }

        function updateCombinationLockUI() {
            const digits = document.querySelectorAll('.lock-digit');
            digits.forEach((el, i) => {
                el.textContent = game.combinationLock.digits[i];
                el.classList.toggle('selected', i === game.combinationLock.selectedDigit);
            });
        }

        function handleCombinationLockInput(key) {
            const lock = game.combinationLock;

            if (key === 'ArrowLeft') {
                lock.selectedDigit = (lock.selectedDigit - 1 + 4) % 4;
                playAudioFile('number-press', { volume: 0.7 });
            } else if (key === 'ArrowRight') {
                lock.selectedDigit = (lock.selectedDigit + 1) % 4;
                playAudioFile('number-press', { volume: 0.7 });
            } else if (key === 'ArrowUp' || key === 'w') {
                lock.digits[lock.selectedDigit] = (lock.digits[lock.selectedDigit] + 1) % 10;
                playAudioFile('number-press', { volume: 0.8 });
            } else if (key === 'ArrowDown' || key === 's') {
                lock.digits[lock.selectedDigit] = (lock.digits[lock.selectedDigit] - 1 + 10) % 10;
                playAudioFile('number-press', { volume: 0.8 });
            } else if (key === 'Enter') {
                checkCombination();
            } else if (key === 'Escape') {
                hideCombinationLock();
                return;
            }

            updateCombinationLockUI();
        }

        function checkCombination() {
            const lock = game.combinationLock;
            const isCorrect = lock.digits.every((d, i) => d === lock.correctCode[i]);

            if (isCorrect) {
                playSound('unlock');
                game.flags.toolboxOpened = true;
                hideCombinationLock();
                showDialogue('"¬°Se abri√≥! Hay... un mapa del edificio?"');
            } else {
                playSound('locked');
                document.getElementById('lockError').textContent = 'Combinaci√≥n incorrecta...';
                // Shake animation
                const container = document.querySelector('.lock-container');
                container.style.animation = 'shake 0.3s';
                setTimeout(() => container.style.animation = '', 300);
            }
        }

        function renderInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';

            const items = ['Destornillador', 'Llave peque√±a', 'Linterna', 'Nota'];

            for (let i = 0; i < 8; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';

                if (game.inventory[i]) {
                    const itemCanvas = document.createElement('canvas');
                    itemCanvas.width = 48;
                    itemCanvas.height = 48;
                    const itemCtx = itemCanvas.getContext('2d');

                    // Draw item icon
                    itemCtx.fillStyle = '#1a2a1e';
                    itemCtx.fillRect(0, 0, 48, 48);

                    const item = game.inventory[i];
                    if (item === 'Destornillador') {
                        itemCtx.fillStyle = '#ff8800';
                        itemCtx.fillRect(4, 18, 20, 12);
                        itemCtx.fillStyle = '#cc6600';
                        itemCtx.fillRect(6, 20, 16, 2);
                        itemCtx.fillRect(6, 26, 16, 2);
                        itemCtx.fillStyle = '#999';
                        itemCtx.fillRect(24, 21, 16, 6);
                        itemCtx.fillStyle = '#777';
                        itemCtx.fillRect(40, 22, 6, 4);
                    } else if (item === 'Llave peque√±a') {
                        itemCtx.fillStyle = '#c9a050';
                        itemCtx.beginPath();
                        itemCtx.arc(14, 24, 8, 0, Math.PI * 2);
                        itemCtx.fill();
                        itemCtx.fillStyle = '#1a2a1e';
                        itemCtx.beginPath();
                        itemCtx.arc(14, 24, 4, 0, Math.PI * 2);
                        itemCtx.fill();
                        itemCtx.fillStyle = '#c9a050';
                        itemCtx.fillRect(20, 22, 20, 4);
                        itemCtx.fillRect(36, 22, 3, 8);
                        itemCtx.fillRect(30, 22, 3, 6);
                    } else if (item === 'Linterna') {
                        itemCtx.fillStyle = '#333';
                        itemCtx.fillRect(8, 16, 24, 16);
                        itemCtx.fillStyle = '#222';
                        itemCtx.fillRect(10, 18, 20, 12);
                        itemCtx.fillStyle = '#ffee88';
                        itemCtx.fillRect(32, 18, 8, 12);
                        itemCtx.fillStyle = '#fff';
                        itemCtx.fillRect(34, 20, 4, 8);
                    } else if (item === 'Nota') {
                        itemCtx.fillStyle = '#fff8dc';
                        itemCtx.fillRect(10, 6, 28, 36);
                        itemCtx.strokeStyle = '#d4c8a0';
                        itemCtx.lineWidth = 1;
                        itemCtx.strokeRect(10, 6, 28, 36);
                        itemCtx.strokeStyle = '#bbb';
                        for (let l = 0; l < 5; l++) {
                            itemCtx.beginPath();
                            itemCtx.moveTo(14, 14 + l * 6);
                            itemCtx.lineTo(34, 14 + l * 6);
                            itemCtx.stroke();
                        }
                    } else if (item === 'Cuchillo') {
                        // Handle
                        itemCtx.fillStyle = '#333';
                        itemCtx.fillRect(4, 20, 16, 10);
                        itemCtx.fillStyle = '#222';
                        itemCtx.fillRect(6, 22, 12, 6);
                        // Guard
                        itemCtx.fillStyle = '#555';
                        itemCtx.fillRect(20, 16, 4, 18);
                        // Blade
                        itemCtx.fillStyle = '#aaa';
                        itemCtx.beginPath();
                        itemCtx.moveTo(24, 18);
                        itemCtx.lineTo(24, 32);
                        itemCtx.lineTo(44, 25);
                        itemCtx.closePath();
                        itemCtx.fill();
                        // Blood
                        itemCtx.fillStyle = 'rgba(100, 20, 20, 0.7)';
                        itemCtx.fillRect(28, 21, 12, 8);
                    } else if (item === 'Carta de Billy') {
                        // Love letter with heart
                        itemCtx.fillStyle = '#f5f0e6';
                        itemCtx.fillRect(8, 6, 32, 38);
                        itemCtx.strokeStyle = '#d4c8a0';
                        itemCtx.lineWidth = 1;
                        itemCtx.strokeRect(8, 6, 32, 38);
                        // Heart doodle
                        itemCtx.fillStyle = '#d45a5a';
                        const hx = 18, hy = 18;
                        itemCtx.fillRect(hx + 2, hy, 4, 2);
                        itemCtx.fillRect(hx + 8, hy, 4, 2);
                        itemCtx.fillRect(hx, hy + 2, 14, 2);
                        itemCtx.fillRect(hx, hy + 4, 14, 2);
                        itemCtx.fillRect(hx + 2, hy + 6, 10, 2);
                        itemCtx.fillRect(hx + 4, hy + 8, 6, 2);
                        // Little lines (writing)
                        itemCtx.strokeStyle = '#aaa';
                        for (let l = 0; l < 3; l++) {
                            itemCtx.beginPath();
                            itemCtx.moveTo(12, 32 + l * 4);
                            itemCtx.lineTo(36, 32 + l * 4);
                            itemCtx.stroke();
                        }
                    } else if (item === 'Forros') {
                        // Condom box - blue with gold band and heart
                        itemCtx.fillStyle = '#2255aa';
                        itemCtx.fillRect(8, 10, 32, 28);
                        // Gold band
                        itemCtx.fillStyle = '#ddaa33';
                        itemCtx.fillRect(8, 20, 32, 8);
                        // Darker edges
                        itemCtx.fillStyle = '#1a4488';
                        itemCtx.fillRect(8, 10, 32, 2);
                        itemCtx.fillRect(8, 36, 32, 2);
                        // Heart icon
                        itemCtx.fillStyle = '#ff6688';
                        const hx2 = 24, hy2 = 24;
                        itemCtx.beginPath();
                        itemCtx.arc(hx2 - 3, hy2 - 1, 4, 0, Math.PI * 2);
                        itemCtx.arc(hx2 + 3, hy2 - 1, 4, 0, Math.PI * 2);
                        itemCtx.fill();
                        itemCtx.beginPath();
                        itemCtx.moveTo(hx2 - 7, hy2);
                        itemCtx.lineTo(hx2, hy2 + 7);
                        itemCtx.lineTo(hx2 + 7, hy2);
                        itemCtx.fill();
                    }

                    slot.appendChild(itemCanvas);

                    const itemName = document.createElement('div');
                    itemName.className = 'item-name';
                    itemName.textContent = item;
                    slot.appendChild(itemName);

                    if (game.equipped === item) {
                        slot.classList.add('selected');
                    }

                    slot.onclick = () => {
                        // Special handling for letter - view it
                        if (item === 'Carta de Billy') {
                            showLetter();
                            return;
                        }
                        // Special handling for note - view it
                        if (item === 'Nota') {
                            showNote();
                            return;
                        }
                        game.equipped = item;
                        document.getElementById('equippedName').textContent = item;
                        drawEquippedIcon();
                        playSound('pickup');
                        renderInventory();
                    };
                }

                grid.appendChild(slot);
            }
        }

        function addToInventory(item) {
            if (!game.inventory.includes(item)) {
                game.inventory.push(item);
                playSound('pickup');

                // Pickup animation
                game.pickupAnimation = { timer: 300, item };
            }
        }

        // ============ INTERACTION ============
        function getObjects() {
            return objectsByScreen[game.currentScreen] || [];
        }

        // Check if an item is hidden under furniture
        function isItemHidden(obj) {
            if (!obj.hiddenUnder) return false;
            if (obj.id === 'nHiddenNote' && game.flags.neighborNoteTaken) return false;

            const objects = getObjects();
            const coveringFurniture = objects.find(o => o.id === obj.hiddenUnder);
            if (!coveringFurniture) return false;

            // Check if furniture still covers the item
            const itemCenterX = obj.x + obj.w / 2;
            const itemCenterY = obj.y + obj.h / 2;

            return itemCenterX >= coveringFurniture.x &&
                   itemCenterX <= coveringFurniture.x + coveringFurniture.w &&
                   itemCenterY >= coveringFurniture.y &&
                   itemCenterY <= coveringFurniture.y + coveringFurniture.h;
        }

        function getNearbyObject() {
            const p = game.player;
            const objects = getObjects();

            for (const obj of objects) {
                if (obj.type === 'item') {
                    if (obj.id === 'screwdriver' && game.flags.screwdriverTaken) continue;
                    if (obj.id === 'hallwayNote' && game.flags.noteTaken) continue;
                    if (obj.id === 'nHiddenNote' && game.flags.neighborNoteTaken) continue;
                    if (obj.id === 'condoms' && game.flags.condomsTaken) continue;
                    if (isItemHidden(obj)) continue;
                }

                const ox = obj.x * TILE + (obj.w * TILE) / 2;
                const oy = obj.y * TILE + (obj.h * TILE) / 2;
                const dist = Math.sqrt((p.x - ox) ** 2 + (p.y - oy) ** 2);

                let range = 40;
                if (obj.type === 'item') range = 50;
                else if (obj.action === 'tv') range = 70; // TV has larger range
                else if (obj.action === 'neighborBed') range = 80; // Bed has larger range for hiding
                else if (obj.type === 'interactable') range = 45;
                else if (obj.pushable) range = 45;

                if (dist < range) return obj;
            }

            return null;
        }

        function tryInteract() {
            // Try to pick up dropped knife first
            if (tryPickUpKnife()) return;

            const obj = getNearbyObject();
            if (!obj) return;

            // Items
            if (obj.type === 'item' && obj.item) {
                if (obj.id === 'screwdriver' && !game.flags.screwdriverTaken) {
                    game.flags.screwdriverTaken = true;
                    addToInventory(obj.item);
                    showDialogue('"Un destornillador... puede servir."');
                    return;
                }
                if (obj.id === 'hallwayNote' && !game.flags.noteTaken) {
                    game.flags.noteTaken = true;
                    addToInventory(obj.item);
                    showDialogue('"1-9-8-7... ¬øqu√© significa?"');
                    return;
                }
                if (obj.id === 'nHiddenNote' && !game.flags.neighborNoteTaken) {
                    game.flags.neighborNoteTaken = true;
                    addToInventory(obj.item);
                    showDialogue('"¬øQu√© hac√≠a esto debajo de la mesa?"');
                    return;
                }
                if (obj.id === 'condoms' && !game.flags.condomsTaken) {
                    game.flags.condomsTaken = true;
                    addToInventory(obj.item);
                    showDialogue('"..."');
                    // Billy's coincidental message
                    setTimeout(() => {
                        showTelegram('¬øCojemos m√°s tarde?', null);
                        setTimeout(() => {
                            document.getElementById('telegramResponse').textContent = '‚Üí "Puede ser"';
                        }, 1500);
                    }, 2000);
                    return;
                }
            }

            // Interactables
            if (obj.action === 'plant' && !game.flags.keyTaken) {
                game.flags.keyTaken = true;
                addToInventory(obj.item);
                showDialogue('"¬øUna llave escondida en la maceta?"');
                return;
            }

            // TV - E toggles on/off
            if (obj.action === 'tv') {
                game.tv.on = !game.tv.on;
                playAudioFile('tv-static', { volume: 0.3 });
                if (game.tv.on) {
                    showDialogue('"Prendi√≥... [Z] para ver"');
                } else {
                    showDialogue('"Apagado."');
                }
                return;
            }

            // Use space for these
            if (obj.type === 'interactable') {
                tryUseItem();
            }
        }

        function tryUseItem() {
            // Try using knife on stunned killer
            if (tryUseKnifeOnKiller()) return;

            const obj = getNearbyObject();
            if (!obj) return;

            if (obj.action === 'frontDoor') {
                game.doorShake = 3;
                setTimeout(() => game.doorShake = 0, 200);
                playSound('locked');
                if (!game.flags.triedDoor) {
                    game.flags.triedDoor = true;
                    showDialogue('"Cerrada con llave... ¬ød√≥nde la dej√©?"');
                } else {
                    showDialogue('"Sigue cerrada."');
                }
                return;
            }

            if (obj.action === 'neighborDoor' || obj.action === 'homeDoor') {
                transitionToScreen(obj.action === 'neighborDoor' ? 'neighbor' : 'home');
                return;
            }

            if (obj.action === 'stairs') {
                transitionToScreen('upstairs');
                return;
            }

            if (obj.action === 'stairsDown') {
                transitionToScreen('home');
                return;
            }

            // Neighbor apartment stairs
            if (obj.action === 'neighborStairsDown') {
                transitionToScreen('neighborDown');
                return;
            }

            if (obj.action === 'neighborStairsUp') {
                transitionToScreen('neighbor');
                return;
            }

            if (obj.action === 'cabinet') {
                if (game.flags.cabinetOpened) {
                    if (!game.flags.letterTaken) {
                        game.flags.letterTaken = true;
                        addToInventory('Carta de Billy');
                        playSound('pickup');
                        showDialogue('"Una carta de Billy... la guard√≥."');
                    } else {
                        showDialogue('"Vac√≠o."');
                    }
                } else if (game.equipped === 'Llave peque√±a') {
                    game.flags.cabinetOpened = true;
                    addToInventory('Linterna');
                    playSound('unlock');
                    showDialogue('"Una linterna... y una carta?"');
                } else {
                    playSound('locked');
                    showDialogue('"Tiene un candado peque√±o."');
                }
                return;
            }

            if (obj.action === 'mirror') {
                if (game.flags.mirrorRevealed) {
                    showDialogue('"1987... escrito con algo invisible."');
                } else if (game.equipped === 'Linterna') {
                    game.flags.mirrorRevealed = true;
                    playSound('pickup');
                    showDialogue('"¬øN√∫meros? 1-9-8-7... ¬øqu√© es esto?"');
                } else {
                    showDialogue('"Mi reflejo... necesito dormir m√°s."');
                }
                return;
            }

            if (obj.action === 'toolbox') {
                if (game.flags.toolboxOpened) {
                    if (!game.flags.documentRead) {
                        game.flags.documentRead = true;
                        showDialogue('"Plano de mantenimiento... acceso de emergencia entre departamentos por panel de heladera. Usar Phillips."');
                    } else {
                        showDialogue('"El plano del edificio..."');
                    }
                } else {
                    showCombinationLock();
                }
                return;
            }

            if (obj.action === 'wardrobe') {
                showDialogue('"Mi ropa... deber√≠a ordenarla alg√∫n d√≠a."');
                return;
            }

            if (obj.action === 'closet') {
                showDialogue('"Mi ropa de siempre."');
                return;
            }

            if (obj.action === 'nightstand') {
                showDialogue('"Nada √∫til."');
                return;
            }

            if (obj.action === 'computer') {
                showDialogue('"Mi compu... [Z] para jugar"');
                return;
            }

            if (obj.action === 'piano') {
                showDialogue('"Mi piano... [Z] para tocar"');
                return;
            }

            if (obj.action === 'fridge') {
                if (game.flags.fridgeOpened) {
                    transitionToScreen('neighbor');
                    // Phone animation will trigger after arriving at neighbor screen
                    return;
                }

                if (!game.flags.documentRead) {
                    showDialogue('"La heladera... nada raro."');
                    return;
                }

                if (game.equipped !== 'Destornillador') {
                    showDialogue('"El panel de atr√°s tiene tornillos Phillips..."');
                    return;
                }

                // Has document read AND screwdriver equipped
                game.flags.fridgeOpened = true;
                playAudioFile('screw', { volume: 0.5 });
                showDialogue('"El panel se abre... hay un pasaje."');
                return;
            }

            if (obj.action === 'balconyDoor') {
                showDialogue('"Hace fr√≠o afuera."');
                return;
            }

            // ============ NEIGHBOR APARTMENT INTERACTIONS ============

            if (obj.action === 'escapeDoor') {
                if (game.keysGame.keysOwned) {
                    // Start keys mini-game
                    startKeysGame();
                    return;
                }

                game.doorShake = 3;
                setTimeout(() => game.doorShake = 0, 200);
                playSound('locked');
                if (!game.flags.triedEscapeDoor) {
                    game.flags.triedEscapeDoor = true;
                    showDialogue('"La salida... cerrada con llave."');
                } else {
                    showDialogue('"Necesito las llaves del vecino."');
                }
                return;
            }

            if (obj.action === 'keyHook') {
                if (!game.flags.sawKeyHook) {
                    game.flags.sawKeyHook = true;
                    showDialogue('"Un gancho vac√≠o... el due√±o tiene las llaves."');
                } else {
                    showDialogue('"Vac√≠o."');
                }
                return;
            }

            if (obj.action === 'metalBox') {
                if (!game.flags.sawMetalBox) {
                    game.flags.sawMetalBox = true;
                    showDialogue('"Una caja de metal... vac√≠a. Rayones adentro."');
                } else {
                    showDialogue('"Vac√≠a."');
                }
                return;
            }

            if (obj.action === 'bathroomDoor') {
                if (game.killer.active) {
                    // Killer has emerged - bathroom is empty now
                    showDialogue('"Vac√≠o... hay sangre en la ba√±era."');
                } else if (game.hiding.active || game.flags.exitedHidingSafely) {
                    showDialogue('"Est√° ocupado... se escucha la ducha."');
                } else {
                    showDialogue('"Un ba√±o."');
                }
                return;
            }

            if (obj.action === 'ndTable') {
                if (game.flags.ndKeysOnTable) {
                    // Keys are on table - pick them up!
                    game.flags.ndKeysOnTable = false;
                    game.keysGame.keysOwned = true;
                    playAudioFile('keys-jingle', { volume: 0.5 });
                    showDialogue('"¬°Llaves! Con sangre... hay que irse ya."');

                    // Stop shower sound
                    if (game.hiding.showerSound) {
                        try {
                            game.hiding.showerSound.source.stop();
                        } catch (e) {}
                        game.hiding.showerSound = null;
                    }

                    // Shower curtain sound - killer is coming out!
                    setTimeout(() => {
                        playAudioFile('shower-curtain', { volume: 0.7 });
                    }, 500);

                    // Trigger killer emergence
                    setTimeout(() => {
                        triggerKillerEmergence();
                    }, 1200);
                } else {
                    showDialogue('"Una mesa normal."');
                }
                return;
            }

            if (obj.action === 'polaroids') {
                if (!game.flags.sawPolaroids) {
                    game.flags.sawPolaroids = true;
                    showDialogue('"Fotos... las caras est√°n borrosas. O tapadas."');
                } else {
                    showDialogue('"No quiero mirar de nuevo."');
                }
                return;
            }

            if (obj.action === 'newspapers') {
                if (!game.flags.sawNewspapers) {
                    game.flags.sawNewspapers = true;
                    showDialogue('"Recortes de diarios... todos sobre personas desaparecidas."');
                } else {
                    showDialogue('"Desaparecidos..."');
                }
                return;
            }

            if (obj.action === 'neighborBed') {
                if (game.hiding.active) return;
                showDialogue('"S√°banas manchadas... [Z] para esconderse"');
                return;
            }

            if (obj.action === 'neighborNightstand') {
                if (!game.flags.sawNightstand) {
                    game.flags.sawNightstand = true;
                    showDialogue('"El caj√≥n est√° vac√≠o... huele raro."');
                } else {
                    showDialogue('"Vac√≠o."');
                }
                return;
            }

            if (obj.action === 'neighborCloset') {
                if (!game.flags.sawCloset) {
                    game.flags.sawCloset = true;
                    showDialogue('"Ropa de diferentes talles... ninguno parece suyo."');
                } else {
                    showDialogue('"Ropa que no le pertenece."');
                }
                return;
            }

            if (obj.action === 'wallets') {
                if (!game.flags.sawWallets) {
                    game.flags.sawWallets = true;
                    showDialogue('"Billeteras... cuatro, cinco... ninguna parece suya."');
                } else {
                    showDialogue('"Muchas billeteras..."');
                }
                return;
            }

            if (obj.action === 'kitchenDrawer') {
                if (!game.flags.sawDrawer) {
                    game.flags.sawDrawer = true;
                    showDialogue('"Cinta de embalar, precintos pl√°sticos... qu√© carajo."');
                } else {
                    showDialogue('"No quiero tocar nada."');
                }
                return;
            }

            if (obj.action === 'neighborBathtub') {
                if (!game.flags.sawBathtub) {
                    game.flags.sawBathtub = true;
                    showDialogue('"Manchas oscuras en la ba√±era... no es √≥xido."');
                } else {
                    showDialogue('"Tengo que salir de ac√°."');
                }
                return;
            }

            if (obj.action === 'tarp') {
                if (!game.flags.sawTarp) {
                    game.flags.sawTarp = true;
                    showDialogue('"Una lona... hay algo abajo. Algo del tama√±o de una persona."');
                } else {
                    showDialogue('"No voy a tocar eso."');
                }
                return;
            }

            if (obj.action === 'basementTools') {
                if (!game.flags.sawBasementTools) {
                    game.flags.sawBasementTools = true;
                    showDialogue('"Ganchos de carnicero... una sierra... esto no es un taller."');
                } else {
                    showDialogue('"Herramientas para matar."');
                }
                return;
            }

            if (obj.action === 'bloodyKeys') {
                game.keysGame.keysOwned = true;
                playAudioFile('keys-jingle', { volume: 0.5 });
                showDialogue('"Llaves... con sangre. Tengo que llegar a la puerta."');
                // Remove from objects
                const idx = objectsByScreen.neighbor.findIndex(o => o.id === 'bloodyKeys');
                if (idx > -1) objectsByScreen.neighbor.splice(idx, 1);

                // Stop shower sound
                if (game.hiding.showerSound) {
                    try {
                        game.hiding.showerSound.source.stop();
                    } catch (e) {}
                    game.hiding.showerSound = null;
                }

                // Shower curtain sound - neighbor is about to come out!
                setTimeout(() => {
                    playAudioFile('shower-curtain', { volume: 0.7 });
                }, 500);

                // Trigger killer emergence after a moment
                setTimeout(() => {
                    triggerKillerEmergence();
                }, 1200);
                return;
            }

            if (obj.action === 'tv') {
                game.tv.on = !game.tv.on;
                playAudioFile('tv-static', { volume: 0.3 });
                if (game.tv.on) {
                    showDialogue('"Prendi√≥... [Z] para ver"');
                } else {
                    showDialogue('"Apagado."');
                }
                return;
            }

            if (obj.type === 'furniture') {
                const responses = ['"..."', '"Nada."', '"Normal."'];
                showDialogue(responses[Math.floor(Math.random() * responses.length)]);
            }
        }

        // ============ TV FUNCTIONS ============
        const TV_CHANNELS = [
            { name: 'NOTICIAS 24', id: 'news' },
            { name: 'TELETUBIS', id: 'teletubbies' },
            { name: 'CRIMEN REAL', id: 'crime' }
        ];

        const NEWS_HEADLINES = [
            '√öLTIMA HORA: Gato local elegido alcalde por tercera vez consecutiva...',
            'BREAKING: Hombre encuentra su propia billetera perdida hace 15 a√±os en el sof√°...',
            'URGENTE: Abuela rompe r√©cord mundial comiendo 47 empanadas en 10 minutos...',
            'NOTICIA: Perro aprende a usar el microondas, familia aterrorizada y orgullosa...',
            'ALERTA: Falta de WiFi causa p√°nico masivo en centro comercial...',
            '√öLTIMA HORA: Cient√≠ficos confirman que los lunes son efectivamente horribles...',
            'BREAKING: Loro testifica en juicio y gana el caso para su due√±o...',
            'URGENTE: Pizza gigante de 3 metros escapa de restaurante, sigue pr√≥fuga...',
            'NOTICIA: Hombre descubre que su planta era de pl√°stico despu√©s de regarla 2 a√±os...',
            'ALERTA M√ÅXIMA: Se√±ora confunde grupo de WhatsApp familiar con grupo del trabajo...'
        ];

        function tryFocusTV() {
            const obj = getNearbyObject();
            if (!obj || obj.action !== 'tv') return;

            if (!game.tv.on) {
                showDialogue('"Est√° apagado. [E] para prender"');
                return;
            }

            game.tv.focused = true;
            document.getElementById('tvOverlay').style.display = 'flex';
            showChannelIndicator();
        }

        function closeTVFocus() {
            game.tv.focused = false;
            document.getElementById('tvOverlay').style.display = 'none';
        }

        function changeChannel(dir) {
            game.tv.channel = (game.tv.channel + dir + TV_CHANNELS.length) % TV_CHANNELS.length;
            game.tv.static = 10; // Brief static when changing
            playSound('tvChannel');
            showChannelIndicator();
        }

        function showChannelIndicator() {
            const indicator = document.getElementById('tvChannelIndicator');
            indicator.textContent = `CH ${game.tv.channel + 1}`;
            indicator.classList.add('visible');
            setTimeout(() => indicator.classList.remove('visible'), 1500);
        }

        // ============ PIANO ============
        const PIANO_NOTES = {
            // White keys
            'a': { note: 'C4', freq: 261.63 },
            's': { note: 'D4', freq: 293.66 },
            'd': { note: 'E4', freq: 329.63 },
            'f': { note: 'F4', freq: 349.23 },
            'g': { note: 'G4', freq: 392.00 },
            'h': { note: 'A4', freq: 440.00 },
            'j': { note: 'B4', freq: 493.88 },
            'k': { note: 'C5', freq: 523.25 },
            // Black keys
            'w': { note: 'C#4', freq: 277.18 },
            'e': { note: 'D#4', freq: 311.13 },
            't': { note: 'F#4', freq: 369.99 },
            'y': { note: 'G#4', freq: 415.30 },
            'u': { note: 'A#4', freq: 466.16 }
        };

        const pianoOscillators = {};

        function tryFocusPiano() {
            const obj = getNearbyObject();
            if (!obj || obj.action !== 'piano') return;

            game.piano.focused = true;
            document.getElementById('pianoOverlay').style.display = 'flex';

            // Play chord on first use
            if (!game.flags.pianoUsed) {
                game.flags.pianoUsed = true;
                playAudioFile('piano-chord', { volume: 0.5 });
                showDialogue('"Ah... hace tiempo que no toco."');
            } else {
                showDialogue('"Veamos si me acuerdo..."');
            }
        }

        function closePianoFocus() {
            game.piano.focused = false;
            document.getElementById('pianoOverlay').style.display = 'none';
            // Stop all playing notes
            Object.keys(pianoOscillators).forEach(key => {
                stopPianoNote(key);
            });
            game.piano.activeKeys.clear();
            updatePianoKeyVisuals();
        }

        function playPianoNote(key) {
            if (!audioCtx || !PIANO_NOTES[key] || pianoOscillators[key]) return;

            const noteData = PIANO_NOTES[key];

            // Create oscillators for a more realistic piano sound
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const osc3 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filterNode = audioCtx.createBiquadFilter();

            // Main tone
            osc1.type = 'triangle';
            osc1.frequency.value = noteData.freq;

            // Harmonics for richness
            osc2.type = 'sine';
            osc2.frequency.value = noteData.freq * 2; // First harmonic

            osc3.type = 'sine';
            osc3.frequency.value = noteData.freq * 3; // Second harmonic

            // Low-pass filter for warmth
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 2000;
            filterNode.Q.value = 1;

            // Connect
            osc1.connect(filterNode);
            osc2.connect(filterNode);
            osc3.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // Piano envelope - quick attack, gradual decay
            const now = audioCtx.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.25, now + 0.01); // Quick attack
            gainNode.gain.exponentialRampToValueAtTime(0.15, now + 0.1); // Initial decay
            gainNode.gain.exponentialRampToValueAtTime(0.08, now + 0.5); // Sustain level

            osc1.start(now);
            osc2.start(now);
            osc3.start(now);

            pianoOscillators[key] = { osc1, osc2, osc3, gainNode };
        }

        function stopPianoNote(key) {
            if (!pianoOscillators[key]) return;

            const { osc1, osc2, osc3, gainNode } = pianoOscillators[key];
            const now = audioCtx.currentTime;

            // Quick release
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

            // Stop oscillators after release
            setTimeout(() => {
                try {
                    osc1.stop();
                    osc2.stop();
                    osc3.stop();
                } catch (e) {}
            }, 350);

            delete pianoOscillators[key];
        }

        function handlePianoKeyDown(key) {
            if (!PIANO_NOTES[key] || game.piano.activeKeys.has(key)) return;

            game.piano.activeKeys.add(key);
            playPianoNote(key);
            updatePianoKeyVisuals();
        }

        function handlePianoKeyUp(key) {
            if (!PIANO_NOTES[key] || !game.piano.activeKeys.has(key)) return;

            game.piano.activeKeys.delete(key);
            stopPianoNote(key);
            updatePianoKeyVisuals();
        }

        function updatePianoKeyVisuals() {
            // Update white keys
            document.querySelectorAll('.piano-key').forEach(el => {
                const note = el.dataset.note;
                const keyChar = Object.keys(PIANO_NOTES).find(k => PIANO_NOTES[k].note === note);
                el.classList.toggle('active', game.piano.activeKeys.has(keyChar));
            });

            // Update black keys
            document.querySelectorAll('.piano-key-black').forEach(el => {
                const note = el.dataset.note;
                const keyChar = Object.keys(PIANO_NOTES).find(k => PIANO_NOTES[k].note === note);
                el.classList.toggle('active', game.piano.activeKeys.has(keyChar));
            });
        }

        // ============ PONG GAME ============

        const pongCanvas = document.getElementById('pongCanvas');
        const pongCtx = pongCanvas.getContext('2d');
        const PONG_WIDTH = 280;
        const PONG_HEIGHT = 200;
        const PADDLE_HEIGHT = 40;
        const PADDLE_WIDTH = 8;
        const BALL_SIZE = 6;

        function tryFocusComputer() {
            const obj = getNearbyObject();
            if (!obj || obj.action !== 'computer') return;
            startPong();
        }

        function startPong() {
            game.pong.active = true;
            game.pong.playerY = PONG_HEIGHT / 2 - PADDLE_HEIGHT / 2;
            game.pong.aiY = PONG_HEIGHT / 2 - PADDLE_HEIGHT / 2;
            game.pong.ballX = PONG_WIDTH / 2;
            game.pong.ballY = PONG_HEIGHT / 2;
            game.pong.ballVX = (Math.random() > 0.5 ? 1 : -1) * 3;
            game.pong.ballVY = (Math.random() - 0.5) * 4;
            game.pong.playerScore = 0;
            game.pong.aiScore = 0;
            game.pong.lastUpdate = Date.now();
            document.getElementById('pongOverlay').style.display = 'flex';
            document.getElementById('pongScore').textContent = '0 - 0';
            requestAnimationFrame(updatePong);
        }

        function closePong() {
            game.pong.active = false;
            document.getElementById('pongOverlay').style.display = 'none';
        }

        function updatePong() {
            if (!game.pong.active) return;

            const now = Date.now();
            const dt = Math.min((now - game.pong.lastUpdate) / 16, 2); // Cap delta
            game.pong.lastUpdate = now;

            // Player movement
            if (keys['w'] || keys['arrowup']) {
                game.pong.playerY -= 5 * dt;
            }
            if (keys['s'] || keys['arrowdown']) {
                game.pong.playerY += 5 * dt;
            }
            game.pong.playerY = Math.max(0, Math.min(PONG_HEIGHT - PADDLE_HEIGHT, game.pong.playerY));

            // AI movement (follows ball with some lag)
            const aiCenter = game.pong.aiY + PADDLE_HEIGHT / 2;
            const targetY = game.pong.ballY;
            if (aiCenter < targetY - 10) {
                game.pong.aiY += 3 * dt;
            } else if (aiCenter > targetY + 10) {
                game.pong.aiY -= 3 * dt;
            }
            game.pong.aiY = Math.max(0, Math.min(PONG_HEIGHT - PADDLE_HEIGHT, game.pong.aiY));

            // Ball movement
            game.pong.ballX += game.pong.ballVX * dt;
            game.pong.ballY += game.pong.ballVY * dt;

            // Top/bottom bounce
            if (game.pong.ballY <= 0 || game.pong.ballY >= PONG_HEIGHT - BALL_SIZE) {
                game.pong.ballVY *= -1;
                game.pong.ballY = Math.max(0, Math.min(PONG_HEIGHT - BALL_SIZE, game.pong.ballY));
            }

            // Paddle collision - player (left)
            if (game.pong.ballX <= 20 + PADDLE_WIDTH &&
                game.pong.ballY + BALL_SIZE >= game.pong.playerY &&
                game.pong.ballY <= game.pong.playerY + PADDLE_HEIGHT &&
                game.pong.ballVX < 0) {
                game.pong.ballVX = Math.abs(game.pong.ballVX) * 1.05; // Speed up slightly
                game.pong.ballVY += (game.pong.ballY - (game.pong.playerY + PADDLE_HEIGHT/2)) * 0.1;
                playTone(440, 0.05, 'square', 0.1);
            }

            // Paddle collision - AI (right)
            if (game.pong.ballX >= PONG_WIDTH - 20 - PADDLE_WIDTH - BALL_SIZE &&
                game.pong.ballY + BALL_SIZE >= game.pong.aiY &&
                game.pong.ballY <= game.pong.aiY + PADDLE_HEIGHT &&
                game.pong.ballVX > 0) {
                game.pong.ballVX = -Math.abs(game.pong.ballVX) * 1.05;
                game.pong.ballVY += (game.pong.ballY - (game.pong.aiY + PADDLE_HEIGHT/2)) * 0.1;
                playTone(440, 0.05, 'square', 0.1);
            }

            // Score
            if (game.pong.ballX < 0) {
                game.pong.aiScore++;
                resetPongBall(-1);
            } else if (game.pong.ballX > PONG_WIDTH) {
                game.pong.playerScore++;
                resetPongBall(1);
            }

            document.getElementById('pongScore').textContent =
                `${game.pong.playerScore} - ${game.pong.aiScore}`;

            // Draw
            drawPong();

            requestAnimationFrame(updatePong);
        }

        function resetPongBall(direction) {
            game.pong.ballX = PONG_WIDTH / 2;
            game.pong.ballY = PONG_HEIGHT / 2;
            game.pong.ballVX = direction * 3;
            game.pong.ballVY = (Math.random() - 0.5) * 4;
            playTone(220, 0.1, 'sine', 0.1);
        }

        function drawPong() {
            // Clear
            pongCtx.fillStyle = '#000';
            pongCtx.fillRect(0, 0, PONG_WIDTH, PONG_HEIGHT);

            // Center line
            pongCtx.strokeStyle = '#003300';
            pongCtx.setLineDash([5, 5]);
            pongCtx.beginPath();
            pongCtx.moveTo(PONG_WIDTH / 2, 0);
            pongCtx.lineTo(PONG_WIDTH / 2, PONG_HEIGHT);
            pongCtx.stroke();
            pongCtx.setLineDash([]);

            // Paddles
            pongCtx.fillStyle = '#00ff00';
            pongCtx.fillRect(12, game.pong.playerY, PADDLE_WIDTH, PADDLE_HEIGHT);
            pongCtx.fillRect(PONG_WIDTH - 12 - PADDLE_WIDTH, game.pong.aiY, PADDLE_WIDTH, PADDLE_HEIGHT);

            // Ball
            pongCtx.fillRect(game.pong.ballX, game.pong.ballY, BALL_SIZE, BALL_SIZE);

            // Scanlines effect
            pongCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            for (let y = 0; y < PONG_HEIGHT; y += 4) {
                pongCtx.fillRect(0, y, PONG_WIDTH, 2);
            }
        }

        // ============ HIDING SYSTEM ============

        // Audio cue timings (in ms from start of sequence)
        const HIDING_AUDIO_SEQUENCE = [
            { phase: 1, time: 0, sound: 'keyInLock', text: null },
            { phase: 2, time: 800, sound: 'doorCreak', text: null },
            { phase: 3, time: 2000, sound: 'footsteps', text: null },
            { phase: 4, time: 4000, sound: 'humming', text: null },
            { phase: 5, time: 7000, sound: 'footsteps', text: null },
            { phase: 6, time: 9000, sound: 'keysDrop', text: null },
            { phase: 7, time: 10500, sound: 'footsteps', text: null },
            { phase: 8, time: 13000, sound: 'bathroomDoor', text: null },  // Safe to exit after this
            { phase: 9, time: 14000, sound: 'waterRunning', text: null },
            { phase: 10, time: 15000, sound: null, text: null }  // Fully safe
        ];

        function tryHide() {
            if (game.currentScreen !== 'neighbor') return;
            if (game.hiding.active) return;

            // Check if near the bed
            const obj = getNearbyObject();
            if (!obj || obj.action !== 'neighborBed') return;

            startHiding();
        }

        function startHiding() {
            game.hiding.active = true;
            game.hiding.phase = 0;
            game.hiding.timer = 0;
            game.hiding.canExit = false;
            game.hiding.killerInside = false;
            game.hiding.keysDropped = false;

            // Show hiding overlay
            const overlay = document.getElementById('hidingOverlay');
            if (overlay) {
                overlay.style.display = 'flex';
            }

            showDialogue('"..."');

            // Start heartbeat loop while hiding
            game.hiding.heartbeatSound = playAudioFile('heartbeat', { volume: 0.4, loop: true });

            // Start the sequence after 5 seconds of darkness
            setTimeout(() => {
                startHidingSequence();
            }, 5000);
        }

        function startHidingSequence() {
            if (!game.hiding.active) return;

            const startTime = Date.now();

            function processSequence() {
                if (!game.hiding.active) return;

                const elapsed = Date.now() - startTime;

                // Find current phase
                for (let i = HIDING_AUDIO_SEQUENCE.length - 1; i >= 0; i--) {
                    const seq = HIDING_AUDIO_SEQUENCE[i];
                    if (elapsed >= seq.time && game.hiding.phase < seq.phase) {
                        game.hiding.phase = seq.phase;

                        // Play the sound
                        if (seq.sound) {
                            playHidingSound(seq.sound);
                        }

                        // Track killer state
                        if (seq.phase >= 2) game.hiding.killerInside = true;
                        if (seq.phase >= 6) {
                            game.hiding.keysDropped = true;
                            game.flags.ndKeysOnTable = true; // Keys now on table downstairs
                        }
                        if (seq.phase >= 8) game.hiding.canExit = true;

                        break;
                    }
                }

                // Continue checking
                if (game.hiding.phase < 10) {
                    requestAnimationFrame(processSequence);
                }
            }

            processSequence();
        }

        function playHidingSound(soundType) {
            if (!audioCtx) return;

            switch (soundType) {
                case 'keyInLock':
                    // Keys jingling as killer unlocks door
                    playAudioFile('keys-jingle', { volume: 0.5 });
                    break;

                case 'doorCreak':
                    // Door opening - use a subtle footstep as door sound
                    playAudioFile('footsteps', { volume: 0.3 });
                    break;

                case 'footsteps':
                    // Use real footsteps sound file
                    playAudioFile('footsteps', { volume: 0.5 });
                    break;

                case 'humming':
                    // Use real whistling sound file (creepy in context)
                    playAudioFile('whistling', { volume: 0.4 });
                    break;

                case 'keysDrop':
                    // Use real keys drop sound file
                    playAudioFile('keys-drop', { volume: 0.6 });
                    break;

                case 'phoneVibrate':
                    // Use real phone vibrate sound file
                    playAudioFile('phone-vibrate', { volume: 0.5 });
                    break;

                case 'bathroomDoor':
                    // Bathroom door closing - subtle sound
                    playAudioFile('footsteps', { volume: 0.25 });
                    break;

                case 'waterRunning':
                    // Start looping shower sound - stops when keys are grabbed
                    game.hiding.showerSound = playAudioFile('shower', { volume: 0.4, loop: true });
                    break;
            }
        }

        function playTone(freq, duration, type, volume) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type || 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(volume || 0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration + 0.1);
        }

        function exitHiding() {
            if (!game.hiding.active) return;

            const wasCanExit = game.hiding.canExit;
            const killerWasInside = game.hiding.killerInside;

            game.hiding.active = false;

            // Stop heartbeat
            if (game.hiding.heartbeatSound) {
                try {
                    game.hiding.heartbeatSound.source.stop();
                } catch (e) {}
                game.hiding.heartbeatSound = null;
            }

            // Hide overlay
            const overlay = document.getElementById('hidingOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }

            // Check outcome
            if (!killerWasInside) {
                // Exited before killer arrived - just hiding for nothing
                showDialogue('"Falsa alarma..."');
            } else if (!wasCanExit) {
                // Exited too early - DISCOVERED (Ending D)
                triggerEnding('D');
            } else {
                // Safe exit - keys are on the table now
                game.keysGame.keysOwned = false;
                game.flags.exitedHidingSafely = true;
                showDialogue('"Se fue al ba√±o... hay llaves en la mesa."');

                // Add bloody keys to the coffee table
                addBloodyKeys();
            }
        }

        function addBloodyKeys() {
            // Add keys object to neighbor screen
            const keysObj = {
                id: 'bloodyKeys',
                x: 8,
                y: 3.3,
                w: 1,
                h: 0.6,
                type: 'interactable',
                sprite: 'bloodyKeys',
                action: 'bloodyKeys'
            };
            objectsByScreen.neighbor.push(keysObj);
        }

        // ============ ENDINGS ============

        // ============ LOVE LETTER FROM BILLY ============
        function showLetter() {
            game.flags.letterViewing = true;
            const overlay = document.getElementById('letterOverlay');
            const letterCanvas = document.getElementById('letterCanvas');
            const ctx = letterCanvas.getContext('2d');

            overlay.style.display = 'flex';

            // Draw the letter
            drawLoveLetter(ctx);
        }

        function closeLetter() {
            game.flags.letterViewing = false;
            game.flags.noteViewing = false;
            document.getElementById('letterOverlay').style.display = 'none';
        }

        function showNote() {
            game.flags.noteViewing = true;
            const overlay = document.getElementById('letterOverlay');
            const letterCanvas = document.getElementById('letterCanvas');
            const ctx = letterCanvas.getContext('2d');

            overlay.style.display = 'flex';

            // Draw the note
            drawNote(ctx);
        }

        function drawNote(ctx) {
            const w = 280, h = 360;

            // Crumpled paper background
            ctx.fillStyle = '#f8f4e8';
            ctx.fillRect(0, 0, w, h);

            // Paper creases/fold lines
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, h/2);
            ctx.lineTo(w, h/2);
            ctx.moveTo(w/2, 0);
            ctx.lineTo(w/2, h);
            ctx.stroke();

            // Torn edge effect at top
            ctx.fillStyle = '#e8e4d8';
            for (let x = 0; x < w; x += 8) {
                const tearHeight = 3 + Math.random() * 5;
                ctx.fillRect(x, 0, 8, tearHeight);
            }

            // The code: 1987
            ctx.fillStyle = '#2a2a4a';
            ctx.font = 'bold 72px VT323';
            ctx.textAlign = 'center';
            ctx.fillText('1987', w/2, h/2 - 20);

            // Underline
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(60, h/2);
            ctx.lineTo(w - 60, h/2);
            ctx.stroke();

            // Small text below
            ctx.font = '18px VT323';
            ctx.fillStyle = '#4a4a6a';
            ctx.fillText('¬øC√≥digo de algo?', w/2, h/2 + 40);

            // Doodle in corner - question mark
            ctx.font = '32px VT323';
            ctx.fillStyle = '#888';
            ctx.fillText('?', w - 40, h - 30);

            // Old stain
            ctx.beginPath();
            ctx.arc(60, 80, 20, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(100, 80, 60, 0.1)';
            ctx.fill();
        }

        function drawLoveLetter(ctx) {
            const w = 280, h = 360;

            // Paper background with slight texture
            ctx.fillStyle = '#f5f0e6';
            ctx.fillRect(0, 0, w, h);

            // Paper texture - faint lines
            ctx.strokeStyle = '#e8e0d4';
            ctx.lineWidth = 1;
            for (let y = 30; y < h - 20; y += 20) {
                ctx.beginPath();
                ctx.moveTo(20, y);
                ctx.lineTo(w - 20, y);
                ctx.stroke();
            }

            // Coffee stain ring
            ctx.beginPath();
            ctx.arc(220, 80, 25, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(139, 90, 43, 0.15)';
            ctx.lineWidth = 8;
            ctx.stroke();

            // Scribbled "writing" lines (just aesthetic marks)
            ctx.strokeStyle = '#4a4a6a';
            ctx.lineWidth = 1.5;
            const scribbleY = [45, 65, 85, 105, 125];
            scribbleY.forEach(y => {
                ctx.beginPath();
                ctx.moveTo(25, y);
                // Wavy scribble line
                for (let x = 25; x < w - 40; x += 3) {
                    ctx.lineTo(x, y + Math.sin(x * 0.3) * 1.5);
                }
                ctx.stroke();
            });

            // Heart doodle in corner
            ctx.fillStyle = '#d45a5a';
            drawPixelHeart(ctx, 30, 280, 12);

            // Draw the rollercoaster doodle!
            drawRollercoasterDoodle(ctx, 60, 160);

            // Small hearts around
            ctx.fillStyle = '#e87878';
            drawPixelHeart(ctx, 200, 300, 6);
            drawPixelHeart(ctx, 230, 285, 5);
            ctx.fillStyle = '#d45a5a';
            drawPixelHeart(ctx, 245, 310, 7);
        }

        function drawPixelHeart(ctx, x, y, size) {
            const s = size / 6;
            ctx.fillRect(x + s, y, s * 2, s);
            ctx.fillRect(x + s * 4, y, s * 2, s);
            ctx.fillRect(x, y + s, s * 6, s);
            ctx.fillRect(x, y + s * 2, s * 6, s);
            ctx.fillRect(x + s, y + s * 3, s * 4, s);
            ctx.fillRect(x + s * 2, y + s * 4, s * 2, s);
        }

        function drawRollercoasterDoodle(ctx, startX, startY) {
            // Sketch-style rollercoaster with two guys holding hands
            ctx.strokeStyle = '#3a3a5a';
            ctx.lineWidth = 2;

            // Track - swooping curve
            ctx.beginPath();
            ctx.moveTo(startX, startY + 60);
            ctx.quadraticCurveTo(startX + 40, startY - 20, startX + 80, startY + 30);
            ctx.quadraticCurveTo(startX + 120, startY + 80, startX + 160, startY + 40);
            ctx.stroke();

            // Track supports
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(startX + 20, startY + 40);
            ctx.lineTo(startX + 20, startY + 80);
            ctx.moveTo(startX + 60, startY + 10);
            ctx.lineTo(startX + 60, startY + 80);
            ctx.moveTo(startX + 100, startY + 45);
            ctx.lineTo(startX + 100, startY + 80);
            ctx.moveTo(startX + 140, startY + 50);
            ctx.lineTo(startX + 140, startY + 80);
            ctx.stroke();

            // Cart on the peak
            const cartX = startX + 70;
            const cartY = startY + 15;

            ctx.fillStyle = '#5a5a7a';
            ctx.fillRect(cartX - 12, cartY - 5, 24, 12);

            // Wheels
            ctx.fillStyle = '#3a3a5a';
            ctx.beginPath();
            ctx.arc(cartX - 6, cartY + 8, 3, 0, Math.PI * 2);
            ctx.arc(cartX + 6, cartY + 8, 3, 0, Math.PI * 2);
            ctx.fill();

            // Two stick figures in cart (holding hands!)
            // Guy 1 (left)
            ctx.fillStyle = '#4a4a6a';
            ctx.beginPath();
            ctx.arc(cartX - 5, cartY - 12, 5, 0, Math.PI * 2);
            ctx.fill();
            // Body
            ctx.strokeStyle = '#4a4a6a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cartX - 5, cartY - 7);
            ctx.lineTo(cartX - 5, cartY);
            ctx.stroke();
            // Arms up (excited!)
            ctx.beginPath();
            ctx.moveTo(cartX - 5, cartY - 5);
            ctx.lineTo(cartX - 12, cartY - 15);
            ctx.stroke();

            // Guy 2 (right)
            ctx.fillStyle = '#6a5a4a';
            ctx.beginPath();
            ctx.arc(cartX + 5, cartY - 12, 5, 0, Math.PI * 2);
            ctx.fill();
            // Body
            ctx.strokeStyle = '#6a5a4a';
            ctx.beginPath();
            ctx.moveTo(cartX + 5, cartY - 7);
            ctx.lineTo(cartX + 5, cartY);
            ctx.stroke();
            // Arms up (excited!)
            ctx.beginPath();
            ctx.moveTo(cartX + 5, cartY - 5);
            ctx.lineTo(cartX + 12, cartY - 15);
            ctx.stroke();

            // HOLDING HANDS in the middle!
            ctx.strokeStyle = '#5a4a5a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cartX - 5, cartY - 4);
            ctx.lineTo(cartX, cartY - 6);
            ctx.lineTo(cartX + 5, cartY - 4);
            ctx.stroke();

            // Little heart above them
            ctx.fillStyle = '#e87878';
            drawPixelHeart(ctx, cartX - 3, cartY - 28, 6);

            // "Wheee" text (sketchy)
            ctx.font = '8px "Press Start 2P"';
            ctx.fillStyle = '#5a5a7a';
            ctx.fillText('~', cartX - 18, cartY - 18);
            ctx.fillText('!', cartX + 14, cartY - 18);
        }

        // ============ BASEMENT SCENE (Bad Endings) ============
        // Top-down pixel art view: Fede tied to table, killer approaching
        let basementAnimationId = null;

        function startBasementScene(endingCode) {
            const overlay = document.getElementById('basementOverlay');
            const bCanvas = document.getElementById('basementCanvas');
            const bCtx = bCanvas.getContext('2d');
            const fade = document.getElementById('basementFade');

            overlay.style.display = 'flex';
            fade.style.opacity = '0';

            // Basement scene state
            const basement = {
                startTime: Date.now(),
                killerY: -60, // Start above screen
                phase: 'dark', // dark, lighton, approach, standing, fade
                lightOn: false
            };

            // Start in darkness, then light turns on
            setTimeout(() => {
                playAudioFile('lightswitch', { volume: 0.6 });
                basement.lightOn = true;
                basement.phase = 'approach';
                basement.startTime = Date.now(); // Reset timer for approach
            }, 800);

            function drawBasementFrame() {
                const elapsed = Date.now() - basement.startTime;

                // Complete darkness before light turns on
                if (!basement.lightOn) {
                    bCtx.fillStyle = '#000';
                    bCtx.fillRect(0, 0, 384, 512);
                    requestAnimationFrame(drawBasementFrame);
                    return;
                }

                // Light flicker intensity - increases as killer approaches
                const approachProgress = Math.min(1, basement.killerY / 80);
                const baseFlicker = 0.8 - approachProgress * 0.4; // Gets dimmer
                const flickerSpeed = 150 - approachProgress * 100; // Flickers faster
                const flicker = baseFlicker + Math.sin(elapsed / flickerSpeed) * 0.15 + Math.random() * 0.1;

                // Dark concrete floor
                bCtx.fillStyle = '#1a1815';
                bCtx.fillRect(0, 0, 384, 512);

                // Floor texture - concrete cracks
                bCtx.strokeStyle = '#151210';
                bCtx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    bCtx.beginPath();
                    bCtx.moveTo(i * 50 + 20, 0);
                    bCtx.lineTo(i * 50 + 30, 512);
                    bCtx.stroke();
                }
                for (let i = 0; i < 12; i++) {
                    bCtx.beginPath();
                    bCtx.moveTo(0, i * 45 + 10);
                    bCtx.lineTo(384, i * 45 + 20);
                    bCtx.stroke();
                }

                // Flickering light from above - gets more red as killer approaches
                const redAmount = 60 + approachProgress * 40;
                const lightGradient = bCtx.createRadialGradient(192, 256, 20, 192, 256, 280);
                lightGradient.addColorStop(0, `rgba(${redAmount}, 25, 20, ${flicker * 0.5})`);
                lightGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                bCtx.fillStyle = lightGradient;
                bCtx.fillRect(0, 0, 384, 512);

                // Tools on walls (top)
                bCtx.fillStyle = '#2a2520';
                // Hooks
                for (let i = 0; i < 4; i++) {
                    bCtx.fillRect(60 + i * 80, 15, 6, 20);
                    bCtx.beginPath();
                    bCtx.arc(63 + i * 80, 35, 8, 0, Math.PI);
                    bCtx.stroke();
                }
                // Saw
                bCtx.fillRect(320, 20, 40, 8);
                bCtx.fillStyle = '#4a4540';
                for (let i = 0; i < 8; i++) {
                    bCtx.fillRect(322 + i * 5, 28, 3, 5);
                }

                // Blood stains on floor
                bCtx.fillStyle = 'rgba(60, 15, 15, 0.5)';
                bCtx.beginPath();
                bCtx.ellipse(100, 400, 30, 20, 0.3, 0, Math.PI * 2);
                bCtx.fill();
                bCtx.beginPath();
                bCtx.ellipse(300, 150, 25, 35, -0.2, 0, Math.PI * 2);
                bCtx.fill();

                // ============ METAL TABLE (center) ============
                const tableX = 120, tableY = 200, tableW = 144, tableH = 200;

                // Table shadow
                bCtx.fillStyle = 'rgba(0,0,0,0.4)';
                bCtx.fillRect(tableX + 8, tableY + 8, tableW, tableH);

                // Table surface
                bCtx.fillStyle = '#5a5855';
                bCtx.fillRect(tableX, tableY, tableW, tableH);
                bCtx.fillStyle = '#4a4845';
                bCtx.fillRect(tableX + 4, tableY + 4, tableW - 8, tableH - 8);

                // Table legs (visible at corners)
                bCtx.fillStyle = '#3a3835';
                bCtx.fillRect(tableX - 4, tableY - 4, 12, 12);
                bCtx.fillRect(tableX + tableW - 8, tableY - 4, 12, 12);
                bCtx.fillRect(tableX - 4, tableY + tableH - 8, 12, 12);
                bCtx.fillRect(tableX + tableW - 8, tableY + tableH - 8, 12, 12);

                // ============ FEDE TIED TO TABLE (top-down) ============
                const fedeX = tableX + tableW/2;
                const fedeY = tableY + tableH/2;
                const breathe = Math.sin(elapsed / 600) * 2;

                // Body (shirt)
                bCtx.fillStyle = COLORS.playerShirt;
                bCtx.fillRect(fedeX - 15, fedeY - 30 + breathe, 30, 50);

                // Head (top-down, we see hair mostly)
                bCtx.fillStyle = COLORS.playerHair;
                bCtx.beginPath();
                bCtx.ellipse(fedeX, fedeY - 45 + breathe, 14, 12, 0, 0, Math.PI * 2);
                bCtx.fill();
                // Face edge
                bCtx.fillStyle = COLORS.player;
                bCtx.beginPath();
                bCtx.ellipse(fedeX, fedeY - 42 + breathe, 10, 8, 0, 0.3, Math.PI - 0.3);
                bCtx.fill();

                // Arms (spread out, tied)
                bCtx.fillStyle = COLORS.playerShirt;
                bCtx.fillRect(fedeX - 50, fedeY - 15 + breathe, 35, 12);
                bCtx.fillRect(fedeX + 15, fedeY - 15 + breathe, 35, 12);
                // Hands
                bCtx.fillStyle = COLORS.player;
                bCtx.fillRect(fedeX - 55, fedeY - 13 + breathe, 8, 8);
                bCtx.fillRect(fedeX + 47, fedeY - 13 + breathe, 8, 8);

                // Legs
                bCtx.fillStyle = COLORS.playerPants;
                bCtx.fillRect(fedeX - 12, fedeY + 20 + breathe, 10, 45);
                bCtx.fillRect(fedeX + 2, fedeY + 20 + breathe, 10, 45);
                // Feet
                bCtx.fillStyle = '#2a2a2a';
                bCtx.fillRect(fedeX - 14, fedeY + 62 + breathe, 12, 8);
                bCtx.fillRect(fedeX + 2, fedeY + 62 + breathe, 12, 8);

                // ============ ROPES ============
                bCtx.strokeStyle = '#8a7a5a';
                bCtx.lineWidth = 4;
                // Chest rope
                bCtx.beginPath();
                bCtx.moveTo(tableX + 10, fedeY - 5 + breathe);
                bCtx.lineTo(tableX + tableW - 10, fedeY - 5 + breathe);
                bCtx.stroke();
                // Wrist ropes
                bCtx.beginPath();
                bCtx.moveTo(fedeX - 55, fedeY - 9 + breathe);
                bCtx.lineTo(fedeX - 55, fedeY - 17 + breathe);
                bCtx.lineTo(tableX, fedeY - 17 + breathe);
                bCtx.stroke();
                bCtx.beginPath();
                bCtx.moveTo(fedeX + 55, fedeY - 9 + breathe);
                bCtx.lineTo(fedeX + 55, fedeY - 17 + breathe);
                bCtx.lineTo(tableX + tableW, fedeY - 17 + breathe);
                bCtx.stroke();
                // Ankle rope
                bCtx.beginPath();
                bCtx.moveTo(tableX + 20, fedeY + 55 + breathe);
                bCtx.lineTo(tableX + tableW - 20, fedeY + 55 + breathe);
                bCtx.stroke();

                // ============ KILLER APPROACHING (top-down) ============
                if (basement.phase === 'approach') {
                    basement.killerY = -60 + (elapsed / 12);
                    if (basement.killerY > 80) {
                        basement.phase = 'standing';
                        basement.standStart = Date.now();
                        playAudioFile('knife-scrape', { volume: 0.5 });
                    }
                }

                const killerY = basement.phase === 'approach' ? basement.killerY : 80;
                const killerX = 192;

                if (killerY > -60) {
                    // Killer shadow
                    bCtx.fillStyle = 'rgba(0,0,0,0.3)';
                    bCtx.beginPath();
                    bCtx.ellipse(killerX + 4, killerY + 50, 20, 8, 0, 0, Math.PI * 2);
                    bCtx.fill();

                    // Body (dark clothes)
                    bCtx.fillStyle = '#1a1a1a';
                    bCtx.fillRect(killerX - 15, killerY, 30, 45);

                    // Head (top-down, blond hair)
                    bCtx.fillStyle = '#d4b896';
                    bCtx.beginPath();
                    bCtx.ellipse(killerX, killerY - 8, 14, 12, 0, 0, Math.PI * 2);
                    bCtx.fill();

                    // Arms
                    bCtx.fillStyle = '#1a1a1a';
                    bCtx.fillRect(killerX - 25, killerY + 5, 12, 30);
                    bCtx.fillRect(killerX + 13, killerY + 5, 12, 30);
                    // Hands
                    bCtx.fillStyle = '#e0c0a0';
                    bCtx.fillRect(killerX - 24, killerY + 32, 10, 10);
                    bCtx.fillRect(killerX + 14, killerY + 32, 10, 10);

                    // Legs
                    bCtx.fillStyle = '#1a1a1a';
                    bCtx.fillRect(killerX - 10, killerY + 42, 8, 20);
                    bCtx.fillRect(killerX + 2, killerY + 42, 8, 20);

                    // KNIFE in right hand - cleaner design
                    const knifeWobble = Math.sin(elapsed / 200) * 2;
                    const kx = killerX + 22 + knifeWobble;
                    const ky = killerY + 35;

                    // Handle (dark wood)
                    bCtx.fillStyle = '#3a2a1a';
                    bCtx.fillRect(kx - 3, ky, 6, 14);
                    // Handle rivets
                    bCtx.fillStyle = '#666';
                    bCtx.fillRect(kx - 1, ky + 3, 2, 2);
                    bCtx.fillRect(kx - 1, ky + 8, 2, 2);

                    // Blade (metallic)
                    bCtx.fillStyle = '#c0c0c0';
                    bCtx.fillRect(kx - 2, ky + 14, 4, 25);
                    // Blade edge highlight
                    bCtx.fillStyle = '#e0e0e0';
                    bCtx.fillRect(kx + 1, ky + 14, 1, 25);
                    // Blade tip
                    bCtx.beginPath();
                    bCtx.moveTo(kx - 2, ky + 39);
                    bCtx.lineTo(kx, ky + 45);
                    bCtx.lineTo(kx + 2, ky + 39);
                    bCtx.closePath();
                    bCtx.fill();

                    // Blood dripping
                    bCtx.fillStyle = '#8a2020';
                    bCtx.fillRect(kx - 1, ky + 28, 2, 12);
                    bCtx.beginPath();
                    bCtx.arc(kx, ky + 42, 2, 0, Math.PI * 2);
                    bCtx.fill();
                }

                // ============ PHASE TRANSITIONS ============
                if (basement.phase === 'standing') {
                    const standElapsed = Date.now() - basement.standStart;

                    // Killer slowly moves closer
                    if (standElapsed > 3000) {
                        basement.phase = 'fade';
                        basement.fadeStart = Date.now();
                    }
                }

                if (basement.phase === 'fade') {
                    const fadeElapsed = Date.now() - basement.fadeStart;
                    fade.style.opacity = Math.min(1, fadeElapsed / 2000);

                    if (fadeElapsed > 3000) {
                        cancelAnimationFrame(basementAnimationId);
                        overlay.style.display = 'none';
                        showFinalEnding(endingCode);
                        return;
                    }
                }

                // Vignette effect
                const vignette = bCtx.createRadialGradient(192, 256, 100, 192, 256, 280);
                vignette.addColorStop(0, 'rgba(0,0,0,0)');
                vignette.addColorStop(1, 'rgba(0,0,0,0.6)');
                bCtx.fillStyle = vignette;
                bCtx.fillRect(0, 0, 384, 512);

                basementAnimationId = requestAnimationFrame(drawBasementFrame);
            }

            drawBasementFrame();
        }

        const ENDINGS = {
            'A': { title: 'ESCAPE', subtitle: 'Lograste escapar. Billy espera tu llamada.' },
            'B': { title: 'VENGANZA', subtitle: 'Terminaste lo que √©l empez√≥. Nadie va a encontrar el cuerpo.' },
            'C': { title: 'ATRAPADO', subtitle: 'Muy lento con las llaves. El s√≥tano te espera.' },
            'D': { title: 'DESCUBIERTO', subtitle: 'Saliste demasiado pronto. Te vio salir de abajo de la cama.' }
        };

        function triggerEnding(endingCode) {
            game.ending = endingCode;
            const ending = ENDINGS[endingCode];

            // Stop killer
            game.killer.active = false;

            // For bad endings (C and D), show basement scene first
            if (endingCode === 'C' || endingCode === 'D') {
                startBasementScene(endingCode);
                return;
            }

            showFinalEnding(endingCode);
        }

        function showFinalEnding(endingCode) {
            const ending = ENDINGS[endingCode];

            // Show ending overlay
            const overlay = document.getElementById('endingOverlay');
            const textEl = document.getElementById('endingText');
            const subtitleEl = document.getElementById('endingSubtitle');

            overlay.style.display = 'flex';

            // For good endings (A/B), just show black screen with messages
            // For bad endings (C/D), show the title text
            if (endingCode === 'A' || endingCode === 'B') {
                textEl.textContent = '';
                subtitleEl.textContent = '';
            } else {
                textEl.textContent = ending.title;
                subtitleEl.textContent = ending.subtitle;
                // Horror sound for bad endings
                playTone(80, 3, 'sawtooth', 0.15);
            }

            // Billy's final messages
            if (endingCode === 'A') {
                // Fede texts Billy after escaping
                setTimeout(() => {
                    showTelegram('¬ø¬ø¬ø???', null);
                    setTimeout(() => {
                        document.getElementById('telegramResponse').textContent = '‚Üí "Ahora te llamo"';
                    }, 1000);
                }, 1500);
            } else if (endingCode === 'B') {
                // Fede texts Billy after killing the killer
                setTimeout(() => {
                    showTelegram('¬øQu√© pas√≥?', null);
                    setTimeout(() => {
                        document.getElementById('telegramResponse').textContent = '‚Üí "Te cuento despu√©s"';
                    }, 1500);
                }, 1500);
            } else {
                // Endings C and D - Billy keeps messaging into the void
                setTimeout(() => showTelegram('Fede contestame', null), 2000);
                setTimeout(() => showTelegram('Fede', null), 5000);
                setTimeout(() => showTelegram('...', null), 8000);
            }
        }

        // ============ KILLER AI ============

        function triggerKillerEmergence() {
            if (game.ending) return;

            game.killer.active = true;
            game.killer.visible = true;
            game.killer.phase = 'emerging';

            // Killer starts at bathroom door position based on current screen
            if (game.currentScreen === 'neighborDown') {
                // Bathroom door is at right wall (x=11, y=4)
                game.killer.x = 11 * TILE;
                game.killer.y = 5 * TILE;
                game.killer.screen = 'neighborDown';
            } else {
                // neighbor screen - bathroom at bottom left (x=1.5, y=8)
                game.killer.x = 1.5 * TILE;
                game.killer.y = 8 * TILE;
                game.killer.screen = 'neighbor';
            }

            // Jump scare sound when killer appears
            playAudioFile('jumpscare', { volume: 0.7 });

            // Knife scrape on wood right after
            setTimeout(() => {
                playAudioFile('knife-scrape', { volume: 0.5 });
            }, 300);

            showDialogue('"..."');

            // After a pause, start chasing
            setTimeout(() => {
                if (!game.killer.active) return;
                game.killer.phase = 'chasing';
            }, 1500);
        }

        function updateKiller(deltaTime) {
            if (!game.killer.active || game.ending) return;

            // Initialize killer screen if not set
            if (!game.killer.screen) {
                game.killer.screen = 'neighbor';
            }

            // Only update if killer is on the same screen as player
            if (game.currentScreen !== game.killer.screen) {
                // If killer is chasing and player changed floors, killer follows after delay
                if (game.killer.phase === 'chasing' && !game.killer.followingDelay) {
                    if ((game.currentScreen === 'neighborDown' && game.killer.screen === 'neighbor') ||
                        (game.currentScreen === 'neighbor' && game.killer.screen === 'neighborDown')) {
                        game.killer.followingDelay = true;
                        setTimeout(() => {
                            if (!game.killer.active || game.ending) return;
                            game.killer.screen = game.currentScreen;
                            // Spawn at stairs
                            if (game.currentScreen === 'neighborDown') {
                                game.killer.x = 1.5 * TILE;
                                game.killer.y = 11 * TILE;
                            } else {
                                game.killer.x = 1.5 * TILE;
                                game.killer.y = 5 * TILE;
                            }
                            game.killer.followingDelay = false;
                        }, 1500);
                    }
                }
                return;
            }

            if (game.killer.phase === 'chasing') {
                // Move toward player with pathfinding around obstacles
                const dx = game.player.x - game.killer.x;
                const dy = game.player.y - game.killer.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 25) {
                    // Caught player!
                    triggerEnding('C');
                    return;
                }

                if (dist > 5) {
                    const speed = 0.5;
                    const moveX = (dx / dist) * speed;
                    const moveY = (dy / dist) * speed;

                    // Try direct movement first
                    const newX = game.killer.x + moveX;
                    const newY = game.killer.y + moveY;

                    // Check collisions separately for X and Y
                    const blockedX = checkKillerCollision(newX, game.killer.y);
                    const blockedY = checkKillerCollision(game.killer.x, newY);

                    if (!blockedX) {
                        game.killer.x = newX;
                    }
                    if (!blockedY) {
                        game.killer.y = newY;
                    }

                    // If both blocked, try sliding along walls
                    if (blockedX && blockedY) {
                        // Try perpendicular movement to get unstuck
                        if (Math.abs(dx) > Math.abs(dy)) {
                            // Want to move X, try sliding Y
                            if (!checkKillerCollision(game.killer.x, game.killer.y - speed)) {
                                game.killer.y -= speed;
                            } else if (!checkKillerCollision(game.killer.x, game.killer.y + speed)) {
                                game.killer.y += speed;
                            }
                        } else {
                            // Want to move Y, try sliding X
                            if (!checkKillerCollision(game.killer.x - speed, game.killer.y)) {
                                game.killer.x -= speed;
                            } else if (!checkKillerCollision(game.killer.x + speed, game.killer.y)) {
                                game.killer.x += speed;
                            }
                        }
                    }
                }
            }
        }

        // Check if killer collides with furniture at given position
        function checkKillerCollision(newX, newY) {
            const killerHalfWidth = 12;
            const killerHalfHeight = 14;
            const killerScreen = game.killer.screen || game.currentScreen;
            const screen = screens[killerScreen];
            if (!screen) return false;

            // Outer walls
            if (newX - killerHalfWidth < TILE * 0.5) return true;
            if (newX + killerHalfWidth > canvas.width - TILE * 0.5) return true;
            if (newY - killerHalfHeight < TILE * 0.5) return true;
            if (newY + killerHalfHeight > canvas.height - TILE * 0.5) return true;

            // Only these specific actions are passable (doors and stairs only)
            const passableActions = ['stairs', 'stairsDown', 'neighborStairsDown', 'neighborStairsUp',
                                     'frontDoor', 'neighborDoor', 'homeDoor', 'escapeDoor', 'bathroomDoor',
                                     'keyHook', 'balconyDoor'];

            const screenObjects = objectsByScreen[killerScreen] || [];
            for (const obj of screenObjects) {
                // Skip items and decor only
                if (obj.type === 'item' || obj.type === 'decor') continue;
                // Skip ONLY doors and stairs
                if (obj.action && passableActions.includes(obj.action)) continue;

                const ox = obj.x * TILE;
                const oy = obj.y * TILE;
                const ow = obj.w * TILE;
                const oh = obj.h * TILE;

                if (newX + killerHalfWidth > ox && newX - killerHalfWidth < ox + ow &&
                    newY + killerHalfHeight > oy && newY - killerHalfHeight < oy + oh) {
                    return true;
                }
            }

            // Inner walls (with doorway consideration)
            for (const wall of screen.walls) {
                const wx = wall.x * TILE;
                const wy = wall.y * TILE;
                const ww = wall.w * TILE;
                const wh = wall.h * TILE;

                // Check if in doorway
                let inDoorway = false;
                for (const dw of screen.doorways) {
                    if (dw.vertical) {
                        if (newY > dw.y * TILE - 10 && newY < (dw.y + dw.h) * TILE + 10) {
                            inDoorway = true;
                            break;
                        }
                    } else {
                        if (newX > dw.x * TILE - 10 && newX < (dw.x + dw.w) * TILE + 10) {
                            inDoorway = true;
                            break;
                        }
                    }
                }

                if (!inDoorway) {
                    if (newX + killerHalfWidth > wx && newX - killerHalfWidth < wx + ww &&
                        newY + killerHalfHeight > wy && newY - killerHalfHeight < wy + wh) {
                        return true;
                    }
                }
            }

            return false;
        }

        function drawKiller() {
            // Draw killer if on same screen as player
            if (!game.killer.visible) return;
            if (!game.killer.screen) game.killer.screen = 'neighbor';
            if (game.currentScreen !== game.killer.screen) return;

            const k = game.killer;

            // Draw stunned killer lying on ground
            if (game.killer.stunned) {
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(k.x, k.y + 5, 20, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body lying horizontal (rotated 90 degrees)
                ctx.save();
                ctx.translate(k.x, k.y);

                // Legs
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-25, -3, 14, 4);
                ctx.fillRect(-25, 2, 14, 4);

                // Body
                ctx.fillStyle = '#e8e8e8';
                ctx.fillRect(-12, -5, 18, 10);

                // Arms
                ctx.fillStyle = '#e8e8e8';
                ctx.fillRect(-8, -10, 10, 3);
                ctx.fillRect(0, 6, 10, 3);

                // Hands
                ctx.fillStyle = '#e0c0a0';
                ctx.fillRect(2, -10, 3, 3);
                ctx.fillRect(10, 6, 3, 3);

                // Head
                ctx.fillStyle = '#e0c0a0';
                ctx.fillRect(6, -4, 12, 8);

                // Hair
                ctx.fillStyle = '#d4b896';
                ctx.fillRect(6, -4, 5, 8);

                // X eyes (unconscious)
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(13, -2);
                ctx.lineTo(15, 0);
                ctx.moveTo(15, -2);
                ctx.lineTo(13, 0);
                ctx.moveTo(13, 2);
                ctx.lineTo(15, 4);
                ctx.moveTo(15, 2);
                ctx.lineTo(13, 4);
                ctx.stroke();

                ctx.restore();
                return;
            }

            const bob = Math.sin(game.gameTime / 300) * 1;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(k.x, k.y + 14, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#2a2a2a';
            if (game.killer.phase === 'chasing') {
                const legOffset = Math.sin(game.gameTime / 200) * 2;
                ctx.fillRect(k.x - 5, k.y + bob - 2, 4, 14 + legOffset);
                ctx.fillRect(k.x + 1, k.y + bob - 2, 4, 14 - legOffset);
            } else {
                ctx.fillRect(k.x - 5, k.y + bob - 2, 4, 14);
                ctx.fillRect(k.x + 1, k.y + bob - 2, 4, 14);
            }

            // Body - white shirt (unsettling)
            ctx.fillStyle = '#e8e8e8';
            ctx.fillRect(k.x - 7, k.y + bob - 18, 14, 18);

            // Arms
            ctx.fillStyle = '#e8e8e8';
            if (game.killer.phase === 'chasing') {
                // One arm holds knife
                ctx.fillRect(k.x - 10, k.y + bob - 16, 3, 12);
                ctx.fillRect(k.x + 7, k.y + bob - 16, 3, 12);
            } else {
                ctx.fillRect(k.x - 10, k.y + bob - 14, 3, 10);
                ctx.fillRect(k.x + 7, k.y + bob - 14, 3, 10);
            }

            // Hands
            ctx.fillStyle = '#e0c0a0';
            ctx.fillRect(k.x - 10, k.y + bob - 5, 3, 3);
            ctx.fillRect(k.x + 7, k.y + bob - 5, 3, 3);

            // Knife in right hand when chasing
            if (game.killer.phase === 'chasing') {
                ctx.fillStyle = '#888';
                ctx.fillRect(k.x + 8, k.y + bob - 3, 2, 12);
                // Blade
                ctx.fillStyle = '#aaa';
                ctx.beginPath();
                ctx.moveTo(k.x + 7, k.y + bob + 9);
                ctx.lineTo(k.x + 11, k.y + bob + 9);
                ctx.lineTo(k.x + 9, k.y + bob + 18);
                ctx.closePath();
                ctx.fill();
                // Blood on knife
                ctx.fillStyle = 'rgba(120, 30, 30, 0.6)';
                ctx.fillRect(k.x + 8, k.y + bob + 10, 2, 5);
            }

            // Head - blond
            ctx.fillStyle = '#e0c0a0';
            ctx.fillRect(k.x - 6, k.y + bob - 28, 12, 12);

            // Blond hair
            ctx.fillStyle = '#d4b896';
            ctx.fillRect(k.x - 6, k.y + bob - 28, 12, 5);
            ctx.fillRect(k.x - 7, k.y + bob - 27, 2, 8);
            ctx.fillRect(k.x + 5, k.y + bob - 27, 2, 8);

            // Face - smiling (the horror)
            ctx.fillStyle = '#222';
            // Eyes
            ctx.fillRect(k.x - 4, k.y + bob - 23, 2, 2);
            ctx.fillRect(k.x + 2, k.y + bob - 23, 2, 2);
            // Smile
            ctx.beginPath();
            ctx.arc(k.x, k.y + bob - 18, 4, 0.2, Math.PI - 0.2);
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#222';
            ctx.stroke();
        }

        // ============ KILLER STUN & REVENGE ============

        function stunKiller(hitByObj) {
            if (game.killer.stunned) return;

            game.killer.stunned = true;
            game.killer.phase = 'stunned';
            game.killer.knifeDropped = true;

            // Play impact and fall sounds
            playTone(80, 0.3, 'sawtooth', 0.2);
            setTimeout(() => playTone(60, 0.5, 'sine', 0.15), 200);

            showDialogue('"...!"');

            // Add knife to scene (near where killer was hit)
            const knifeX = game.killer.x / TILE;
            const knifeY = (game.killer.y + 30) / TILE;

            // Store knife position in game state - including which screen!
            game.flags.knifeOnFloor = true;
            game.flags.knifeX = knifeX;
            game.flags.knifeY = knifeY;
            game.flags.knifeScreen = game.currentScreen;

            setTimeout(() => {
                showDialogue('"El cuchillo..."');
            }, 1500);
        }

        function drawKnifeOnFloor() {
            if (!game.flags.knifeOnFloor) return;
            if (game.currentScreen !== game.flags.knifeScreen) return;
            if (game.inventory.includes('Cuchillo')) return;

            const kx = game.flags.knifeX * TILE;
            const ky = game.flags.knifeY * TILE;

            // Blood pool
            ctx.fillStyle = 'rgba(80, 20, 20, 0.6)';
            ctx.beginPath();
            ctx.ellipse(kx, ky + 5, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Knife handle
            ctx.fillStyle = '#333';
            ctx.fillRect(kx - 10, ky - 2, 10, 5);
            ctx.fillStyle = '#222';
            ctx.fillRect(kx - 8, ky - 1, 6, 3);

            // Guard
            ctx.fillStyle = '#555';
            ctx.fillRect(kx - 1, ky - 4, 3, 9);

            // Blade
            ctx.fillStyle = '#aaa';
            ctx.beginPath();
            ctx.moveTo(kx + 2, ky - 3);
            ctx.lineTo(kx + 2, ky + 4);
            ctx.lineTo(kx + 18, ky + 1);
            ctx.closePath();
            ctx.fill();

            // Blood on blade
            ctx.fillStyle = 'rgba(100, 20, 20, 0.7)';
            ctx.fillRect(kx + 4, ky - 1, 10, 3);

            // Glow if nearby
            const dist = Math.sqrt(
                Math.pow(game.player.x - kx, 2) +
                Math.pow(game.player.y - ky, 2)
            );
            if (dist < 50) {
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 10 + Math.sin(game.gameTime / 200) * 5;
            }
        }

        function tryPickUpKnife() {
            if (!game.flags.knifeOnFloor) return false;
            if (game.currentScreen !== game.flags.knifeScreen) return false;
            if (game.inventory.includes('Cuchillo')) return false;

            const kx = game.flags.knifeX * TILE;
            const ky = game.flags.knifeY * TILE;

            const dist = Math.sqrt(
                Math.pow(game.player.x - kx, 2) +
                Math.pow(game.player.y - ky, 2)
            );

            if (dist < 50) {
                game.inventory.push('Cuchillo');
                game.equipped = 'Cuchillo'; // Auto-equip the knife
                game.flags.knifeOnFloor = false;
                showDialogue('"Lo agarro..." [Ya est√° equipado]');
                playSound('pickup');
                return true;
            }
            return false;
        }

        function tryUseKnifeOnKiller() {
            if (!game.killer.stunned) return false;
            if (game.equipped !== 'Cuchillo') return false;
            if (game.currentScreen !== game.killer.screen) return false;

            const dist = Math.sqrt(
                Math.pow(game.player.x - game.killer.x, 2) +
                Math.pow(game.player.y - game.killer.y, 2)
            );

            if (dist < 60) {
                // Revenge ending - start stabbing animation
                game.inventory = game.inventory.filter(i => i !== 'Cuchillo');
                game.equipped = null;
                game.revengeAnimation = { phase: 'stabbing', timer: 0, stabs: 0 };

                // Freeze player
                game.player.speed = 0;

                // Stab sound
                playAudioFile('knife-stab', { volume: 0.8 });
                game.revengeAnimation.stabs = 1;

                // Fade to black after stabbing
                setTimeout(() => {
                    game.revengeAnimation.phase = 'fadeout';
                    game.revengeAnimation.timer = 0; // Reset timer for fade
                    game.killer.visible = false;
                    game.killer.active = false;
                }, 1800);

                // Complete fade and trigger ending
                setTimeout(() => {
                    game.revengeAnimation = null;
                    triggerEnding('B');
                }, 3000);

                return true;
            }
            return false;
        }

        // ============ KEYS MINI-GAME ============

        const KEY_DESIGNS = [
            { name: 'Llave peque√±a', color: '#a89060', length: 35, teeth: [3, 5, 2] },
            { name: 'Llave larga', color: '#8a8a8a', length: 45, teeth: [2, 4, 6, 3] },
            { name: 'Llave oxidada', color: '#6a5040', length: 38, teeth: [4, 2, 5] },
            { name: 'Llave negra', color: '#3a3a3a', length: 32, teeth: [3, 3, 4, 2] },
            { name: 'Llave dorada', color: '#d4a84a', length: 42, teeth: [5, 3, 4, 5] }  // This one works!
        ];

        const KEY_MESSAGES = [
            '"No..."',
            '"No, no..."',
            '"Dale, dale..."',
            '"Vamos, vamos!"'
        ];

        function startKeysGame() {
            game.keysGame.active = true;
            game.keysGame.currentKey = 0;
            game.keysGame.rotating = false;
            game.keysGame.rotationAngle = 0;

            document.getElementById('keysOverlay').style.display = 'flex';
            updateKeysDisplay();
            renderKeysCanvas();
        }

        function updateKeysDisplay() {
            const keyName = KEY_DESIGNS[game.keysGame.currentKey].name;
            document.getElementById('keysCurrent').textContent = keyName;
            document.getElementById('keysMessage').textContent = '';
        }

        function renderKeysCanvas() {
            const keysCanvas = document.getElementById('keysCanvas');
            const kctx = keysCanvas.getContext('2d');
            const w = keysCanvas.width;
            const h = keysCanvas.height;

            // Clear
            kctx.fillStyle = '#1a1a1a';
            kctx.fillRect(0, 0, w, h);

            const centerX = w / 2;
            const centerY = h / 2;
            const ringRadius = 30;

            // Draw key ring
            kctx.strokeStyle = '#666';
            kctx.lineWidth = 4;
            kctx.beginPath();
            kctx.arc(centerX, centerY - 20, ringRadius, 0, Math.PI * 2);
            kctx.stroke();

            // Draw all 5 keys around the ring, current key on top
            const angleOffset = game.keysGame.rotationAngle;
            for (let i = 0; i < 5; i++) {
                const keyIndex = (game.keysGame.currentKey + i) % 5;
                const angle = (i / 5) * Math.PI * 2 - Math.PI / 2 + angleOffset;
                const keyDesign = KEY_DESIGNS[keyIndex];

                const kx = centerX + Math.cos(angle) * ringRadius;
                const ky = centerY - 20 + Math.sin(angle) * ringRadius;

                // Key shaft
                kctx.save();
                kctx.translate(kx, ky);
                kctx.rotate(angle + Math.PI / 2);

                // Key bow (top round part)
                kctx.fillStyle = keyDesign.color;
                kctx.beginPath();
                kctx.arc(0, -5, 8, 0, Math.PI * 2);
                kctx.fill();
                kctx.fillStyle = 'rgba(0,0,0,0.3)';
                kctx.beginPath();
                kctx.arc(0, -5, 4, 0, Math.PI * 2);
                kctx.fill();

                // Key blade
                kctx.fillStyle = keyDesign.color;
                kctx.fillRect(-2, 0, 4, keyDesign.length);

                // Key teeth
                const teeth = keyDesign.teeth;
                for (let t = 0; t < teeth.length; t++) {
                    const ty = 10 + t * 8;
                    kctx.fillRect(2, ty, teeth[t], 4);
                }

                // Blood stains on keys
                if (Math.random() < 0.3 || keyIndex === game.keysGame.currentKey) {
                    kctx.fillStyle = 'rgba(120, 30, 30, 0.5)';
                    kctx.beginPath();
                    kctx.arc(1, keyDesign.length * 0.6, 3, 0, Math.PI * 2);
                    kctx.fill();
                }

                kctx.restore();
            }

            // Highlight current key
            const currentAngle = -Math.PI / 2 + angleOffset;
            const hx = centerX + Math.cos(currentAngle) * ringRadius;
            const hy = centerY - 20 + Math.sin(currentAngle) * ringRadius;
            kctx.strokeStyle = '#aa8040';
            kctx.lineWidth = 2;
            kctx.beginPath();
            kctx.arc(hx, hy - 5, 12, 0, Math.PI * 2);
            kctx.stroke();
        }

        function rotateKeys() {
            if (game.keysGame.rotating) return;

            game.keysGame.rotating = true;
            const startAngle = game.keysGame.rotationAngle;
            const targetAngle = startAngle + (Math.PI * 2 / 5);
            const duration = 300;
            const startTime = Date.now();

            // Play key jingle sound
            playTone(800, 0.03, 'square', 0.2);
            setTimeout(() => playTone(600, 0.04, 'square', 0.15), 50);
            setTimeout(() => playTone(500, 0.03, 'square', 0.1), 100);

            function animateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3); // ease out

                game.keysGame.rotationAngle = startAngle + (targetAngle - startAngle) * eased;
                renderKeysCanvas();

                if (progress < 1) {
                    requestAnimationFrame(animateRotation);
                } else {
                    game.keysGame.rotationAngle = targetAngle;
                    game.keysGame.currentKey = (game.keysGame.currentKey + 1) % 5;
                    game.keysGame.rotating = false;
                    updateKeysDisplay();
                    renderKeysCanvas();
                }
            }

            animateRotation();
        }

        function tryCurrentKey() {
            if (game.keysGame.rotating) return;

            const keyIndex = game.keysGame.currentKey;

            // Play key in lock sound
            playTone(300, 0.1, 'square', 0.2);

            if (keyIndex === 4) {
                // Key 5 works! Escape!
                document.getElementById('keysMessage').textContent = '"¬°Funciona!"';
                playTone(440, 0.3, 'sine', 0.3);

                setTimeout(() => {
                    document.getElementById('keysOverlay').style.display = 'none';
                    game.keysGame.active = false;
                    // Start fade to black
                    game.escapeAnimation = { timer: 0 };
                }, 1000);

                // Fade completes, trigger ending
                setTimeout(() => {
                    game.escapeAnimation = null;
                    triggerEnding('A');
                }, 2500);
            } else {
                // Wrong key
                const message = KEY_MESSAGES[keyIndex] || '"No..."';
                document.getElementById('keysMessage').textContent = message;

                // Killer gets closer each failed attempt
                if (game.killer.active) {
                    const dx = game.player.x - game.killer.x;
                    const dy = game.player.y - game.killer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Move killer closer
                    game.killer.x += (dx / dist) * 30;
                    game.killer.y += (dy / dist) * 30;

                    // Check if caught
                    const newDist = Math.sqrt(
                        Math.pow(game.player.x - game.killer.x, 2) +
                        Math.pow(game.player.y - game.killer.y, 2)
                    );

                    if (newDist < 40) {
                        document.getElementById('keysOverlay').style.display = 'none';
                        game.keysGame.active = false;
                        triggerEnding('C');
                    }
                }
            }
        }

        function renderTVScreen() {
            if (!game.tv.focused) return;

            const tvCanvas = document.getElementById('tvScreen');
            const tvCtx = tvCanvas.getContext('2d');
            const w = tvCanvas.width;
            const h = tvCanvas.height;

            // Brief static when changing channels
            if (game.tv.static > 0) {
                game.tv.static--;
                renderStatic(tvCtx, w, h);
                return;
            }

            const channel = TV_CHANNELS[game.tv.channel];

            switch (channel.id) {
                case 'news':
                    renderNews(tvCtx, w, h);
                    break;
                case 'teletubbies':
                    renderTeletubbies(tvCtx, w, h);
                    break;
                case 'crime':
                    renderCrime(tvCtx, w, h);
                    break;
            }
        }

        function renderStatic(ctx, w, h) {
            const imageData = ctx.createImageData(w, h);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.random() * 255;
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
                imageData.data[i + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);

            // Occasional horizontal line
            if (Math.random() < 0.1) {
                const lineY = Math.random() * h;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(0, lineY, w, 2);
            }
        }

        function renderNews(ctx, w, h) {
            // Blue background
            ctx.fillStyle = '#1a3a6a';
            ctx.fillRect(0, 0, w, h);

            // News desk
            ctx.fillStyle = '#5a3a2a';
            ctx.fillRect(0, h * 0.6, w, h * 0.4);
            ctx.fillStyle = '#7a5a4a';
            ctx.fillRect(0, h * 0.6, w, 10);

            // Anchor (simple pixel person)
            const anchorX = w / 2;
            const anchorY = h * 0.45;
            // Body
            ctx.fillStyle = '#3a5a8a';
            ctx.fillRect(anchorX - 25, anchorY, 50, 60);
            // Head
            ctx.fillStyle = '#e0c0a0';
            ctx.fillRect(anchorX - 15, anchorY - 35, 30, 35);
            // Hair
            ctx.fillStyle = '#3a2a1a';
            ctx.fillRect(anchorX - 15, anchorY - 35, 30, 12);
            // Eyes
            ctx.fillStyle = '#222';
            ctx.fillRect(anchorX - 8, anchorY - 18, 4, 4);
            ctx.fillRect(anchorX + 4, anchorY - 18, 4, 4);
            // Mouth moving
            if (Math.floor(game.gameTime / 200) % 2 === 0) {
                ctx.fillRect(anchorX - 5, anchorY - 5, 10, 3);
            }

            // News ticker at bottom - cycles through headlines
            ctx.fillStyle = '#c00';
            ctx.fillRect(0, h - 40, w, 40);
            ctx.fillStyle = '#fff';
            ctx.font = '18px VT323';

            // Create continuous ticker from all headlines
            const fullTicker = NEWS_HEADLINES.join('   ‚òÖ   ');
            const tickerWidth = fullTicker.length * 10;
            const tickerOffset = (game.gameTime / 15) % (tickerWidth + w);
            ctx.fillText(fullTicker, w - tickerOffset, h - 15);

            // "LIVE" indicator blinking
            if (Math.floor(game.gameTime / 500) % 2 === 0) {
                ctx.fillStyle = '#f00';
                ctx.fillRect(15, 15, 50, 22);
                ctx.fillStyle = '#fff';
                ctx.font = '16px VT323';
                ctx.fillText('EN VIVO', 18, 32);
            }

            // Channel logo
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '16px VT323';
            ctx.fillText('NOTICIAS 24', w - 90, 25);

            // Subtle scanlines
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            for (let y = 0; y < h; y += 3) {
                ctx.fillRect(0, y, w, 1);
            }
        }

        function renderTeletubbies(ctx, w, h) {
            // Bright sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, w, h * 0.6);

            // Happy sun with baby face
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(w - 70, 60, 45, 0, Math.PI * 2);
            ctx.fill();
            // Sun rays
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + game.gameTime / 2000;
                ctx.beginPath();
                ctx.moveTo(w - 70 + Math.cos(angle) * 50, 60 + Math.sin(angle) * 50);
                ctx.lineTo(w - 70 + Math.cos(angle) * 65, 60 + Math.sin(angle) * 65);
                ctx.stroke();
            }
            // Baby face in sun
            ctx.fillStyle = '#ffb366';
            ctx.beginPath();
            ctx.arc(w - 70, 60, 30, 0, Math.PI * 2);
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(w - 80, 55, 4, 0, Math.PI * 2);
            ctx.arc(w - 60, 55, 4, 0, Math.PI * 2);
            ctx.fill();
            // Giggling mouth
            const mouthOpen = Math.abs(Math.sin(game.gameTime / 300)) * 8;
            ctx.fillStyle = '#c44';
            ctx.beginPath();
            ctx.ellipse(w - 70, 70, 10, mouthOpen, 0, 0, Math.PI * 2);
            ctx.fill();

            // Green hills
            ctx.fillStyle = '#5cb85c';
            ctx.beginPath();
            ctx.ellipse(w/4, h, w/2, h * 0.5, 0, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#4cae4c';
            ctx.beginPath();
            ctx.ellipse(w * 0.75, h, w/2, h * 0.4, 0, Math.PI, 0);
            ctx.fill();

            // Flowers
            const flowerColors = ['#ff69b4', '#ff6b6b', '#ffd700', '#ff8c00'];
            for (let i = 0; i < 8; i++) {
                const fx = 30 + i * 50;
                const fy = h * 0.75 + Math.sin(i) * 20;
                ctx.fillStyle = flowerColors[i % 4];
                ctx.beginPath();
                ctx.arc(fx, fy, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(fx, fy, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Four Teletubbies bouncing
            const tubbies = [
                { color: '#9b59b6', name: 'Tinky', x: 80, antenna: 'triangle' },
                { color: '#27ae60', name: 'Dipsy', x: 160, antenna: 'stick' },
                { color: '#f1c40f', name: 'Lala', x: 240, antenna: 'curl' },
                { color: '#e74c3c', name: 'Po', x: 320, antenna: 'circle' }
            ];

            tubbies.forEach((tubby, i) => {
                const bounceY = Math.abs(Math.sin(game.gameTime / 200 + i * 0.5)) * 15;
                const baseY = h * 0.65 - bounceY;

                // Body
                ctx.fillStyle = tubby.color;
                ctx.beginPath();
                ctx.ellipse(tubby.x, baseY, 25, 35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Belly screen
                ctx.fillStyle = '#ddd';
                ctx.beginPath();
                ctx.ellipse(tubby.x, baseY + 5, 12, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(tubby.x, baseY + 5, 10, 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = tubby.color;
                ctx.beginPath();
                ctx.arc(tubby.x, baseY - 40, 18, 0, Math.PI * 2);
                ctx.fill();

                // Face
                ctx.fillStyle = '#ffcc99';
                ctx.beginPath();
                ctx.ellipse(tubby.x, baseY - 38, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(tubby.x - 5, baseY - 40, 2, 0, Math.PI * 2);
                ctx.arc(tubby.x + 5, baseY - 40, 2, 0, Math.PI * 2);
                ctx.fill();

                // Smile
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(tubby.x, baseY - 35, 5, 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();

                // Antenna
                ctx.fillStyle = tubby.color;
                if (tubby.antenna === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(tubby.x - 8, baseY - 55);
                    ctx.lineTo(tubby.x, baseY - 75);
                    ctx.lineTo(tubby.x + 8, baseY - 55);
                    ctx.fill();
                } else if (tubby.antenna === 'stick') {
                    ctx.fillRect(tubby.x - 2, baseY - 70, 4, 15);
                } else if (tubby.antenna === 'curl') {
                    ctx.beginPath();
                    ctx.arc(tubby.x, baseY - 65, 8, 0, Math.PI * 1.5);
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = tubby.color;
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(tubby.x, baseY - 65, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(tubby.x - 2, baseY - 60, 4, 5);
                }
            });

            // "Uh-oh!" or "Again!" text
            const phrases = ['¬°UH-OH!', '¬°OTRA VEZ!', '¬°HOLA!', '¬°ABRAZOS!'];
            const phraseIndex = Math.floor(game.gameTime / 2000) % phrases.length;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px VT323';
            ctx.fillText(phrases[phraseIndex], 20, 40);

            // Channel logo
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '14px VT323';
            ctx.fillText('TELETUBIS', w - 80, 20);
        }

        function renderCrime(ctx, w, h) {
            // Dark ominous background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);

            // Dramatic red overlay
            ctx.fillStyle = 'rgba(80, 0, 0, 0.3)';
            ctx.fillRect(0, 0, w, h);

            // Creepy forest silhouette
            ctx.fillStyle = '#0a0a0a';
            for (let i = 0; i < 10; i++) {
                const treeX = i * 45 + 20;
                const treeH = 100 + Math.sin(i * 2) * 30;
                ctx.beginPath();
                ctx.moveTo(treeX - 15, h * 0.7);
                ctx.lineTo(treeX, h * 0.7 - treeH);
                ctx.lineTo(treeX + 15, h * 0.7);
                ctx.fill();
            }

            // Blood red moon
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.arc(w - 80, 80, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#660000';
            ctx.beginPath();
            ctx.arc(w - 70, 75, 35, 0, Math.PI * 2);
            ctx.fill();

            // Shadowy figure silhouette
            const figureX = 100 + Math.sin(game.gameTime / 1000) * 20;
            ctx.fillStyle = '#000';
            // Body
            ctx.beginPath();
            ctx.ellipse(figureX, h * 0.55, 25, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            // Head
            ctx.beginPath();
            ctx.arc(figureX, h * 0.35, 20, 0, Math.PI * 2);
            ctx.fill();
            // Glowing eyes
            if (Math.floor(game.gameTime / 500) % 3 !== 0) {
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(figureX - 7, h * 0.34, 3, 0, Math.PI * 2);
                ctx.arc(figureX + 7, h * 0.34, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Title card
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, h * 0.75, w, h * 0.25);
            ctx.fillStyle = '#c00';
            ctx.fillRect(0, h * 0.75, w, 3);

            // Show title
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px VT323';
            ctx.fillText('CRIMEN REAL: ASESINOS EN SERIE', 20, h * 0.83);

            // Episode info - rotating
            const episodes = [
                'Cap. 47: "El Carnicero del Edificio"',
                'Cap. 48: "Vecinos Silenciosos"',
                'Cap. 49: "El que Toca la Puerta"',
                'Cap. 50: "No Abras a Extra√±os"',
                'Cap. 51: "El S√≥tano del Horror"'
            ];
            const epIndex = Math.floor(game.gameTime / 4000) % episodes.length;
            ctx.fillStyle = '#aaa';
            ctx.font = '16px VT323';
            ctx.fillText(episodes[epIndex], 20, h * 0.92);

            // Warning label
            ctx.fillStyle = '#ff0';
            ctx.font = '12px VT323';
            ctx.fillText('‚ö† IM√ÅGENES FUERTES', w - 140, h * 0.92);

            // Heartbeat line effect
            ctx.strokeStyle = '#c00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const beatOffset = game.gameTime / 10;
            for (let x = 0; x < w; x += 5) {
                const beatY = h * 0.72;
                let y = beatY;
                const pos = (x + beatOffset) % 100;
                if (pos > 40 && pos < 50) y = beatY - 15;
                else if (pos > 50 && pos < 55) y = beatY + 10;
                else if (pos > 55 && pos < 60) y = beatY - 8;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Channel logo
            ctx.fillStyle = 'rgba(200, 0, 0, 0.7)';
            ctx.font = '14px VT323';
            ctx.fillText('CRIMEN REAL', w - 100, 25);

            // Scanlines
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            for (let y = 0; y < h; y += 2) {
                ctx.fillRect(0, y, w, 1);
            }
        }

        function transitionToScreen(targetScreen) {
            const container = document.getElementById('gameContainer');
            container.classList.add('transitioning');

            setTimeout(() => {
                const fromScreen = game.currentScreen;
                game.currentScreen = targetScreen;

                // Set spawn position based on transition
                if (targetScreen === 'upstairs') {
                    // Coming up stairs - spawn next to stairs (not on top)
                    game.player.x = 110;
                    game.player.y = 380;
                } else if (targetScreen === 'home' && fromScreen === 'upstairs') {
                    // Coming down stairs - spawn next to stairs in tools area
                    game.player.x = 120;
                    game.player.y = 360;
                } else if (targetScreen === 'neighbor') {
                    if (fromScreen === 'neighborDown') {
                        // Coming up from ground floor - spawn near stairs
                        game.player.x = 80;
                        game.player.y = 200;
                    } else {
                        // Spawn in kitchen near fridge (entry point)
                        game.player.x = 300;
                        game.player.y = 380;
                    }
                } else if (targetScreen === 'neighborDown') {
                    if (fromScreen === 'neighbor') {
                        // Coming down stairs - spawn in hallway near stairs doorway
                        game.player.x = 80;
                        game.player.y = 220;
                    } else {
                        // Default spawn
                        game.player.x = 200;
                        game.player.y = 200;
                    }
                } else {
                    game.player.x = 350;
                    game.player.y = 280;
                }

                if (targetScreen === 'neighbor' && !game.flags.visitedNeighbor) {
                    game.flags.visitedNeighbor = true;
                    game.flags.enteredNeighbor = true;

                    // First time entering killer's apartment - trigger phone animation after a beat
                    if (!game.phone.silentMode) {
                        setTimeout(() => {
                            startPhoneSilentAnimation(null);
                        }, 800); // Small delay to let player see the room first
                    }
                }

                // Manage clock-tick ambient - only in Fede's apartment
                if (targetScreen === 'home' || targetScreen === 'upstairs') {
                    startClockTick();
                } else {
                    stopClockTick();
                }

                showLocation();
                container.classList.remove('transitioning');
            }, 200);
        }

        // ============ PUSHING ============
        function getTouchingPushable(dx, dy) {
            const p = game.player;
            const objects = getObjects();

            // Check slightly ahead in movement direction
            const checkX = p.x + dx * 20;
            const checkY = p.y + dy * 20;

            for (const obj of objects) {
                if (!obj.pushable) continue;

                const ox = obj.x * TILE;
                const oy = obj.y * TILE;
                const ow = obj.w * TILE;
                const oh = obj.h * TILE;

                // Check if player is touching this object
                const hw = p.width / 2;
                const hh = p.height / 2;

                if (checkX + hw > ox && checkX - hw < ox + ow &&
                    checkY + hh > oy && checkY - hh < oy + oh) {
                    return obj;
                }
            }
            return null;
        }

        function canPushFurniture(obj, dx, dy) {
            const pushDist = 0.1; // Push amount in tiles
            const newX = obj.x + dx * pushDist;
            const newY = obj.y + dy * pushDist;

            // Check outer walls
            if (newX * TILE < TILE * 0.5) return false;
            if ((newX + obj.w) * TILE > canvas.width - TILE * 0.5) return false;
            if (newY * TILE < TILE * 0.5) return false;
            if ((newY + obj.h) * TILE > canvas.height - TILE * 0.5) return false;

            // Check collision with other furniture
            const objects = getObjects();
            for (const other of objects) {
                if (other === obj || other.type === 'item' || other.type === 'decor') continue;

                const margin = 0.05;
                if (newX + obj.w > other.x + margin && newX < other.x + other.w - margin &&
                    newY + obj.h > other.y + margin && newY < other.y + other.h - margin) {
                    return false;
                }
            }

            // Check inner walls
            const screen = screens[game.currentScreen];
            for (const wall of screen.walls) {
                if (newX + obj.w > wall.x && newX < wall.x + wall.w &&
                    newY + obj.h > wall.y && newY < wall.y + wall.h) {
                    return false;
                }
            }

            return true;
        }

        function tryPushFurniture(dx, dy) {
            if (game.pushTimer > 0) return false;

            const obj = getTouchingPushable(dx, dy);
            if (!obj) return false;

            if (canPushFurniture(obj, dx, dy)) {
                const pushDist = 0.1;
                obj.x += dx * pushDist;
                obj.y += dy * pushDist;
                game.pushTimer = 100; // Cooldown
                game.isPushing = true;
                playSound('push');

                // Check if furniture hit the killer
                if (game.killer.active && game.killer.phase === 'chasing' && !game.killer.stunned) {
                    const ox = obj.x * TILE;
                    const oy = obj.y * TILE;
                    const ow = obj.w * TILE;
                    const oh = obj.h * TILE;
                    const kx = game.killer.x;
                    const ky = game.killer.y;

                    // Check collision with killer
                    if (kx > ox - 20 && kx < ox + ow + 20 &&
                        ky > oy - 20 && ky < oy + oh + 20) {
                        stunKiller(obj);
                    }
                }

                return true;
            }
            return false;
        }

        // ============ COLLISION ============
        function checkCollision(newX, newY) {
            const p = game.player;
            const hw = p.width / 2 - 4;
            const hh = p.height / 2 - 4;
            const screen = screens[game.currentScreen];

            // Outer walls
            if (newX - hw < TILE * 0.4) return true;
            if (newX + hw > canvas.width - TILE * 0.4) return true;
            if (newY - hh < TILE * 0.4) return true;
            if (newY + hh > canvas.height - TILE * 0.4) return true;

            // Furniture
            for (const obj of getObjects()) {
                if (obj.type === 'item' || obj.type === 'decor') continue;

                const ox = obj.x * TILE;
                const oy = obj.y * TILE;
                const ow = obj.w * TILE;
                const oh = obj.h * TILE;

                const margin = 4;
                if (newX + hw > ox + margin && newX - hw < ox + ow - margin &&
                    newY + hh > oy + margin && newY - hh < oy + oh - margin) {
                    return true;
                }
            }

            // Inner walls
            for (const wall of screen.walls) {
                const wx = wall.x * TILE;
                const wy = wall.y * TILE;
                const ww = wall.w * TILE;
                const wh = wall.h * TILE;

                // Check if in doorway
                let inDoorway = false;
                for (const dw of screen.doorways) {
                    if (dw.vertical) {
                        if (newY > dw.y * TILE && newY < (dw.y + dw.h) * TILE) {
                            inDoorway = true;
                            break;
                        }
                    } else {
                        if (newX > dw.x * TILE && newX < (dw.x + dw.w) * TILE) {
                            inDoorway = true;
                            break;
                        }
                    }
                }

                if (!inDoorway) {
                    if (newX + hw > wx && newX - hw < wx + ww &&
                        newY + hh > wy && newY - hh < wy + wh) {
                        return true;
                    }
                }
            }

            return false;
        }

        function getFloorType() {
            const p = game.player;
            const screen = screens[game.currentScreen];

            for (const room of screen.rooms) {
                if (p.x > room.x * TILE && p.x < (room.x + room.w) * TILE &&
                    p.y > room.y * TILE && p.y < (room.y + room.h) * TILE) {
                    return room.floor || 'wood';
                }
            }
            return 'wood';
        }

        // ============ UPDATE ============
        function update(deltaTime) {
            const p = game.player;

            // Update phone animation (character-based)
            updatePhoneAnimation(deltaTime);

            // Lamp flicker
            if (Math.random() < 0.01) {
                game.lampFlicker = 0.7 + Math.random() * 0.3;
            } else {
                game.lampFlicker = Math.min(1, game.lampFlicker + deltaTime * 0.01);
            }

            // Door shake decay
            if (game.doorShake > 0) {
                game.doorShake = Math.sin(game.gameTime / 30) * 3;
            }

            // Push timer decay
            if (game.pushTimer > 0) {
                game.pushTimer -= deltaTime;
            } else {
                game.isPushing = false;
            }

            if (!game.showInventory) {
                let dx = 0, dy = 0;

                if (keys['w'] || keys['arrowup']) { dy = -1; p.direction = 'up'; }
                if (keys['s'] || keys['arrowdown']) { dy = 1; p.direction = 'down'; }
                if (keys['a'] || keys['arrowleft']) { dx = -1; p.direction = 'left'; }
                if (keys['d'] || keys['arrowright']) { dx = 1; p.direction = 'right'; }

                p.isMoving = (dx !== 0 || dy !== 0);

                if (p.isMoving && p.speed > 0) {
                    // Normalize direction
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const normDx = dx / len;
                    const normDy = dy / len;

                    // Try pushing if space is held
                    if (keys[' ']) {
                        tryPushFurniture(normDx, normDy);
                    }

                    dx = normDx * p.speed;
                    dy = normDy * p.speed;

                    const newX = p.x + dx;
                    const newY = p.y + dy;

                    if (!checkCollision(newX, p.y)) p.x = newX;
                    if (!checkCollision(p.x, newY)) p.y = newY;

                    // Walk animation
                    p.bobOffset += deltaTime * 0.015;

                    // Footsteps
                    p.stepTimer += deltaTime;
                    if (p.stepTimer > 250) {
                        p.stepTimer = 0;
                        playSound('step', { floor: getFloorType() });
                    }
                }
            }

            // Timers
            if (game.dialogueTimer > 0) {
                game.dialogueTimer -= deltaTime;
                if (game.dialogueTimer <= 0) {
                    document.getElementById('dialogueBox').style.display = 'none';
                }
            }

            if (game.telegramTimer > 0) {
                game.telegramTimer -= deltaTime;
                if (game.telegramTimer <= 0) {
                    document.getElementById('telegramPopup').style.display = 'none';
                }
            }

            if (game.pickupAnimation) {
                game.pickupAnimation.timer -= deltaTime;
                if (game.pickupAnimation.timer <= 0) {
                    game.pickupAnimation = null;
                }
            }

            game.gameTime += deltaTime;

            // Billy messages - Phase 1 (Home)
            if (game.currentScreen === 'home' || game.currentScreen === 'upstairs') {
                // 30 sec in
                if (!game.flags.billyMsg1 && game.gameTime > 30000) {
                    game.flags.billyMsg1 = true;
                    showTelegram('¬øC√≥mo va la limpieza?', 'Bien, reci√©n arranco');
                }
                // Get flashlight
                if (!game.flags.billyMsg2 && game.flags.flashlightTaken && !game.flags.billyMsg1Sent) {
                    game.flags.billyMsg2 = true;
                    setTimeout(() => showTelegram('¬øEncontraste algo interesante?', 'Jaja no, polvo nom√°s'), 3000);
                }
                // Open toolbox
                if (!game.flags.billyMsg3 && game.flags.toolboxOpened) {
                    game.flags.billyMsg3 = true;
                    setTimeout(() => showTelegram('¬øNo est√°s con el vecino no? Jaja', 'Jaja no, ¬øpor?'), 5000);
                }
                // Find document
                if (!game.flags.billyMsg4 && game.flags.documentRead) {
                    game.flags.billyMsg4 = true;
                    setTimeout(() => showTelegram('¬øYa casi?', 'S√≠, un toque m√°s'), 4000);
                }
            }

            // Billy messages - Phase 2 (Neighbor's apartment)
            if (game.currentScreen === 'neighbor' && !game.hiding.active && !game.killer.active) {
                // Enter through fridge
                if (!game.flags.billyNeighbor1 && game.flags.enteredNeighbor) {
                    game.flags.billyNeighbor1 = true;
                    game.flags.neighborEnterTime = game.gameTime;
                    setTimeout(() => showTelegram('¬øTodo bien?', null), 3000);
                }
                // 20 sec inside
                if (!game.flags.billyNeighbor2 && game.flags.neighborEnterTime &&
                    game.gameTime - game.flags.neighborEnterTime > 20000) {
                    game.flags.billyNeighbor2 = true;
                    showTelegram('¬øFede?', null);
                }
                // Find first clue (polaroids or wallets)
                if (!game.flags.billyNeighbor3 && (game.flags.sawPolaroids || game.flags.sawWallets)) {
                    game.flags.billyNeighbor3 = true;
                    setTimeout(() => showTelegram('¬øPor qu√© no contest√°s?', null), 5000);
                }
            }

            // Billy messages - Phase 3 (Hiding)
            if (game.hiding.active) {
                // Before killer arrives
                if (!game.flags.billyHiding1 && game.hiding.phase > 0 && game.hiding.phase < 3) {
                    game.flags.billyHiding1 = true;
                    setTimeout(() => showTelegram('Me estoy preocupando', null), 2000);
                }
                // Killer in apartment (footsteps)
                if (!game.flags.billyHiding2 && game.hiding.phase >= 3 && game.hiding.phase < 6) {
                    game.flags.billyHiding2 = true;
                    setTimeout(() => showTelegram('Contestame por favor', null), 3000);
                }
                // Killer walking around - phone call (max tension!)
                if (!game.flags.billyHiding3 && game.hiding.phase >= 5 && game.hiding.phase < 8) {
                    game.flags.billyHiding3 = true;
                    setTimeout(() => {
                        showTelegram('[LLAMADA ENTRANTE]', null);
                        // Play phone vibration sound
                        playHidingSound('phoneVibrate');
                        // Fede rejects call silently
                        setTimeout(() => {
                            document.getElementById('telegramPopup').style.display = 'none';
                        }, 2500);
                    }, 2000);
                }
            }

            // Billy messages - After exiting hiding safely
            if (!game.flags.billyAfterHiding && game.flags.exitedHidingSafely && !game.hiding.active) {
                game.flags.billyAfterHiding = true;
                setTimeout(() => showTelegram('¬øFede??', null), 3000);
            }

            // Interact hint
            const nearby = getNearbyObject();
            const hint = document.getElementById('interactHint');
            if (nearby && nearby.type !== 'furniture') {
                hint.style.display = 'block';
                hint.classList.add('visible');
                let action = nearby.type === 'item' ? 'Agarrar' : 'Usar';
                if (nearby.action === 'tv') {
                    action = game.tv.on ? 'Apagar' : 'Encender';
                    hint.textContent = `[E] ${action} ¬∑ [Z] Ver`;
                } else {
                    hint.textContent = `[E] ${action}`;
                }
            } else if (nearby && nearby.pushable) {
                hint.style.display = 'block';
                hint.classList.add('visible');
                hint.textContent = '[ESPACIO + MOVER] Empujar';
            } else {
                hint.classList.remove('visible');
                setTimeout(() => {
                    if (!hint.classList.contains('visible')) {
                        hint.style.display = 'none';
                    }
                }, 200);
            }

            // Track nearby for glow effect
            game.nearbyObject = nearby;

            // Update killer
            updateKiller(deltaTime);
        }

        // ============ RENDER ============
        function render() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawFloor();
            drawWalls();

            const objects = getObjects();

            // Decor first
            for (const obj of objects) {
                if (obj.type === 'decor') {
                    drawSprite(obj.sprite, obj.x, obj.y, obj.w, obj.h);
                }
            }

            // Sort by Y
            const sortedObjects = objects
                .filter(o => o.type !== 'decor')
                .sort((a, b) => (a.y + a.h) - (b.y + b.h));

            // Draw objects with player interspersed
            const playerDrawn = { done: false };
            const playerY = game.player.y / TILE;

            for (const obj of sortedObjects) {
                if (!playerDrawn.done && (obj.y + obj.h) > playerY) {
                    drawPlayer();
                    playerDrawn.done = true;
                }

                // Skip taken items and hidden items
                if (obj.id === 'screwdriver' && game.flags.screwdriverTaken) continue;
                if (obj.id === 'hallwayNote' && game.flags.noteTaken) continue;
                if (obj.id === 'nHiddenNote' && game.flags.neighborNoteTaken) continue;
                if (obj.id === 'condoms' && game.flags.condomsTaken) continue;
                if (isItemHidden(obj)) continue;

                // Glow effect for nearby interactables and pushables
                if (game.nearbyObject === obj && (obj.type === 'interactable' || obj.type === 'item' || obj.pushable)) {
                    ctx.save();
                    ctx.shadowColor = obj.pushable && obj.type === 'furniture' ? '#88aaff' : '#ffaa00';
                    ctx.shadowBlur = 15 + Math.sin(game.gameTime / 200) * 5;
                    drawSprite(obj.sprite, obj.x, obj.y, obj.w, obj.h);
                    ctx.restore();
                } else {
                    drawSprite(obj.sprite, obj.x, obj.y, obj.w, obj.h);
                }
            }

            if (!playerDrawn.done) {
                drawPlayer();
            }

            // Draw killer (always on top when visible)
            drawKiller();

            // Draw knife on floor if dropped
            drawKnifeOnFloor();

            // Flashlight effect when equipped
            if (game.equipped === 'Linterna') {
                const p = game.player;
                ctx.save();

                // Create light cone based on player direction
                let angle = 0;
                if (p.direction === 'up') angle = -Math.PI / 2;
                else if (p.direction === 'down') angle = Math.PI / 2;
                else if (p.direction === 'left') angle = Math.PI;
                else if (p.direction === 'right') angle = 0;

                // Light cone gradient
                const coneLength = 120;
                const coneWidth = 60;
                const lightX = p.x + Math.cos(angle) * 20;
                const lightY = p.y + Math.sin(angle) * 20;
                const endX = p.x + Math.cos(angle) * coneLength;
                const endY = p.y + Math.sin(angle) * coneLength;

                // Create cone shape with gradient
                const gradient = ctx.createRadialGradient(lightX, lightY, 5, endX, endY, coneWidth);
                gradient.addColorStop(0, 'rgba(255, 250, 220, 0.4)');
                gradient.addColorStop(0.5, 'rgba(255, 245, 200, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 240, 180, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(lightX, lightY);
                ctx.lineTo(endX + Math.cos(angle + 0.5) * coneWidth, endY + Math.sin(angle + 0.5) * coneWidth);
                ctx.lineTo(endX + Math.cos(angle - 0.5) * coneWidth, endY + Math.sin(angle - 0.5) * coneWidth);
                ctx.closePath();
                ctx.fill();

                // Bright spot at source
                const spotGradient = ctx.createRadialGradient(lightX, lightY, 0, lightX, lightY, 15);
                spotGradient.addColorStop(0, 'rgba(255, 255, 240, 0.6)');
                spotGradient.addColorStop(1, 'rgba(255, 255, 220, 0)');
                ctx.fillStyle = spotGradient;
                ctx.beginPath();
                ctx.arc(lightX, lightY, 15, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            // Pickup animation
            if (game.pickupAnimation) {
                const alpha = game.pickupAnimation.timer / 300;
                const yOffset = (1 - alpha) * -30;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ffcc00';
                ctx.font = '14px VT323';
                ctx.textAlign = 'center';
                ctx.fillText(`+${game.pickupAnimation.item}`, game.player.x, game.player.y - 30 + yOffset);
                ctx.restore();
            }

            // Revenge stabbing animation
            if (game.revengeAnimation) {
                if (game.revengeAnimation.phase === 'stabbing') {
                    // Red flash on each stab
                    const flashIntensity = Math.max(0, 1 - (game.revengeAnimation.timer % 600) / 200);
                    if (flashIntensity > 0) {
                        ctx.save();
                        ctx.fillStyle = `rgba(120, 0, 0, ${flashIntensity * 0.4})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    }
                    game.revengeAnimation.timer += 16;
                } else if (game.revengeAnimation.phase === 'fadeout') {
                    // Fade to black
                    game.revengeAnimation.timer += 16;
                    const fadeProgress = Math.min(1, game.revengeAnimation.timer / 1200);
                    ctx.save();
                    ctx.fillStyle = `rgba(0, 0, 0, ${fadeProgress})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }
            }

            // Escape fade to black animation
            if (game.escapeAnimation) {
                game.escapeAnimation.timer += 16;
                const fadeProgress = Math.min(1, game.escapeAnimation.timer / 1500);
                ctx.save();
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeProgress})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            drawMinimap();
            drawEquippedIcon();
            renderTVScreen();
        }

        // ============ GAME LOOP ============
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = Math.min(timestamp - lastTime, 50);
            lastTime = timestamp;

            update(deltaTime);
            render();

            requestAnimationFrame(gameLoop);
        }

        // Start
        canvas.classList.add('flicker');
        showLocation();

        // Preload audio on first interaction
        document.addEventListener('click', () => {
            if (!audioCtx) {
                preloadAudio();
            }
        }, { once: false });
        document.addEventListener('keydown', () => {
            if (!audioCtx) {
                preloadAudio();
            }
        }, { once: false });

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
