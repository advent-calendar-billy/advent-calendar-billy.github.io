<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Slot Machine - 5x7</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a2e; /* Dark blueish background */
            color: #e0e0e0;
            margin: 0;
            padding: 5px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        #root {
            width: 100%;
            max-width: 320px; /* Adjusted for 5 reels, smaller symbols */
        }

        /* Basic utilities */
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .gap-1 { gap: 0.25rem; } /* 4px */
        .p-1 { padding: 0.25rem; }
        .p-2 { padding: 0.5rem; }
        .mb-1 { margin-bottom: 0.25rem;}
        .mb-2 { margin-bottom: 0.5rem; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .w-full { width: 100%; }
        .text-xxs { font-size: 0.65rem; line-height: 0.85rem;} /* Extra small for tight UI */
        .text-xs { font-size: 0.75rem; line-height: 1rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .font-bold { font-weight: bold; }
        .uppercase { text-transform: uppercase; }
        .rounded { border-radius: 0.25rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-full { border-radius: 9999px; }
        .border { border-width: 1px; }
        .border-2 { border-width: 2px; }
        .border-4 { border-width: 4px; }
        .border-amber-500 { border-color: #f59e0b; }
        .border-gray-600 { border-color: #4b5563; }
        .border-gray-700 { border-color: #374151; }
        .border-green-500 { border-color: #22c55e; }
        .bg-gray-950 { background-color: #0c0d1f; } /* Machine body */
        .bg-black { background-color: #000; }
        .bg-gray-800 { background-color: #1f2937; } /* Reel column background */
        .bg-gray-700 { background-color: #374151; }
        .hover\:bg-gray-600:hover { background-color: #4b5563; }
        .bg-red-600 { background-color: #dc2626; }
        .hover\:bg-red-700:hover { background-color: #b91c1c; }
        .bg-green-600 { background-color: #16a34a; }
        .bg-yellow-500 { background-color: #eab308; }
        .bg-pink-600 { background-color: #db2777; }
        .text-white { color: #fff; }
        .text-black { color: #000; }
        .text-amber-400 { color: #fbbf24; }
        .text-green-500 { color: #22c55e; }
        .text-blue-400 { color: #60a5fa; }
        .opacity-50 { opacity: 0.5; }
        .absolute { position: absolute; }
        .relative { position: relative; }
        .top-0 { top: 0; }
        .left-0 { left: 0; }
        .right-0 { right: 0; }
        .text-center { text-align: center; }
        .z-10 { z-index: 10; }
        .z-20 { z-index: 20; } /* Reels */
        .z-30 { z-index: 30; } /* Lines */
        .z-40 { z-index: 40; } /* Messages */
        .mx-auto { margin-left: auto; margin-right: auto; }
        .overflow-hidden { overflow: hidden; }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .6; } }
        .animate-pulse { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }

        @keyframes bounce { 0%, 100% { transform: translateY(-15%); animation-timing-function: cubic-bezier(0.8,0,1,1); } 50% { transform: translateY(0); animation-timing-function: cubic-bezier(0,0,0.2,1); } }
        .animate-bounce { animation: bounce 1s infinite; }

        .pixel-grid { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%; height: 100%; }
        .pixel { width: 100%; height: 100%; }
        
        button { cursor: pointer; transition: background-color 0.2s ease, opacity 0.2s ease; user-select: none; border-style: solid;}
        button:disabled { cursor: not-allowed; opacity: 0.6; }
        
        .slot-symbol-container {
            width: 24px; /* Smaller symbols for 5x7 grid */
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #2a2a3e; /* Symbol background */
            border: 1px solid #444; /* Default border */
        }
        .reels-area { /* Container for reels and SVG lines */
            position: relative;
            background-color: black; 
            padding: 2px; /* Minimal padding around the set of reels */
            border-radius: 4px;
            border: 2px solid #374151; 
            margin-bottom: 0.5rem; /* my-2 */
            margin-top: 0.5rem; /* my-2 */
        }
        .winning-lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 30; 
        }
        .payline-button {
            padding: 3px 6px;
            font-size: 0.6rem; /* text-xxs might be too small */
            border-width: 1px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
const NUM_REELS = 5;
const NUM_ROWS = 7;
const BASE_BET_PER_LINE = 1;

// CSS dependent values for SVG line calculation (MUST MATCH CSS)
const SYMBOL_SIZE_PX = 24;
const SYMBOL_MARGIN_Y_PX = 2; // Each symbol has my-0.5 (0.125rem), so 2px top + 2px bottom = 4px total vertical space taken by margins.
const REEL_COLUMN_PADDING_PX = 1; // Each reel column (bg-gray-800) has p-0.5, so 1px on each side.
const GAP_BETWEEN_REELS_PX = 2; // Using gap-0.5 (0.125rem = 2px) between reel columns

const SlotMachine = () => {
  const initialSymbols = React.useMemo(() => [
    { id: 'cherry', value: 10, color: '#FF0000', pattern: [[0,0,0,0,0,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,1,1,0,0,0,0],[0,1,1,1,1,0,0,0],[1,1,1,1,1,1,0,0],[0,1,1,1,1,0,0,0]] },
    { id: 'lemon', value: 20, color: '#FFFF00', pattern: [[0,0,1,1,1,0,0,0],[0,1,1,1,1,1,0,0],[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[0,1,1,1,1,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]] },
    { id: 'seven', value: 50, color: '#0000FF', pattern: [[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[0,0,0,0,0,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0]] },
    { id: 'diamond', value: 100, color: '#00FFFF', pattern: [[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0]] },
    { id: 'star', value: 200, color: '#FF00FF', pattern: [[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[1,1,0,0,0,0,1,1]] },
    { id: 'bonus', value: 0, color: '#00FF00', pattern: [[0,0,1,1,1,1,0,0],[0,0,1,0,0,1,0,0],[1,1,1,1,1,1,1,1],[1,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,1],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0]] },
    { id: 'wild', value: 0, color: '#FFACFC', pattern: [[1,1,0,0,0,0,1,1],[1,1,0,0,0,0,1,1],[1,1,0,1,1,0,1,1],[1,1,1,1,1,1,1,1],[1,1,1,0,0,1,1,1],[1,1,0,1,1,0,1,1],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0]] },
    { id: 'jackpot', value: 500, color: '#FFAA00', pattern: [[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0]] }
  ], []);

  const paylines = React.useMemo(() => {
    const lines = [];
    // Horizontal (7 lines)
    for (let i = 0; i < NUM_ROWS; i++) {
      lines.push({ id: lines.length + 1, name: `H${i}`, coords: Array(NUM_REELS).fill(null).map((_, reelIdx) => [reelIdx, i]) });
    }
    // Zigzags and other patterns (18 lines for 25 total)
    // V shape (top, mid, bottom)
    if (NUM_ROWS >= 2) lines.push({ id: lines.length + 1, name: 'ZV1', coords: [[0,0],[1,1],[2,0],[3,1],[4,0]] });
    if (NUM_ROWS >= 4) lines.push({ id: lines.length + 1, name: 'ZV2', coords: [[0,2],[1,3],[2,2],[3,3],[4,2]] });
    if (NUM_ROWS >= 6) lines.push({ id: lines.length + 1, name: 'ZV3', coords: [[0,4],[1,5],[2,4],[3,5],[4,4]] });
    // A shape (inverted V)
    if (NUM_ROWS >= 2) lines.push({ id: lines.length + 1, name: 'ZA1', coords: [[0,1],[1,0],[2,1],[3,0],[4,1]] });
    if (NUM_ROWS >= 4) lines.push({ id: lines.length + 1, name: 'ZA2', coords: [[0,3],[1,2],[2,3],[3,2],[4,3]] });
    if (NUM_ROWS >= 6) lines.push({ id: lines.length + 1, name: 'ZA3', coords: [[0,5],[1,4],[2,5],[3,4],[4,5]] });
    // /\/\/\/ (top half)
    if (NUM_ROWS >= 3) lines.push({ id: lines.length + 1, name: 'ZG1', coords: [[0,0],[1,1],[2,2],[3,1],[4,0]] });
    // \/\/\/ (bottom half)
    if (NUM_ROWS >= 3) lines.push({ id: lines.length + 1, name: 'ZG2', coords: [[0,NUM_ROWS-1],[1,NUM_ROWS-2],[2,NUM_ROWS-3],[3,NUM_ROWS-2],[4,NUM_ROWS-1]] });
    // Diagonals (simplified to main ones if space is an issue)
    if (NUM_ROWS >= NUM_REELS) { // Only if grid is tall enough for full diagonal
        lines.push({ id: lines.length + 1, name: 'D1', coords: Array(NUM_REELS).fill(null).map((_, i) => [i, i]) });
        lines.push({ id: lines.length + 1, name: 'D2', coords: Array(NUM_REELS).fill(null).map((_, i) => [i, NUM_REELS - 1 - i]) }); // This is for square, adapt for 5x7
    } else { // Shorter diagonals / steps
        lines.push({ id: lines.length + 1, name: 'DS1', coords: [[0,0],[1,1],[2,2],[3,3],[4,4]] }); // Main TL-BR
        lines.push({ id: lines.length + 1, name: 'DS2', coords: [[0,NUM_ROWS-1],[1,NUM_ROWS-2],[2,NUM_ROWS-3],[3,NUM_ROWS-4],[4,NUM_ROWS-5]] }); // Main BL-TR (approx)
    }
    // More varied zigzags
    if (NUM_ROWS >= 3) lines.push({ id: lines.length + 1, name: 'ZG3', coords: [[0,1],[1,0],[2,1],[3,2],[4,1]] });
    if (NUM_ROWS >= 4) lines.push({ id: lines.length + 1, name: 'ZG4', coords: [[0,NUM_ROWS-2],[1,NUM_ROWS-1],[2,NUM_ROWS-2],[3,NUM_ROWS-3],[4,NUM_ROWS-2]] });
    if (NUM_ROWS >= 5) {
      lines.push({ id: lines.length + 1, name: 'ZG5', coords: [[0,0],[1,2],[2,1],[3,3],[4,2]] });
      lines.push({ id: lines.length + 1, name: 'ZG6', coords: [[0,NUM_ROWS-1],[1,NUM_ROWS-3],[2,NUM_ROWS-2],[3,NUM_ROWS-4],[4,NUM_ROWS-3]] });
    }
     // Central 'W' and 'M'
    if (NUM_ROWS >= 5) {
        lines.push({ id: lines.length + 1, name: 'CW', coords: [[0,2],[1,1],[2,2],[3,1],[4,2]] }); // W-like
        lines.push({ id: lines.length + 1, name: 'CM', coords: [[0,NUM_ROWS-3],[1,NUM_ROWS-2],[2,NUM_ROWS-3],[3,NUM_ROWS-2],[4,NUM_ROWS-3]] }); // M-like
    }
    // Ensure we don't exceed a target, e.g. 25 lines
    return lines.slice(0, 25);
  }, []);
  const MAX_PAYLINES = paylines.length;

  const [money, setMoney] = React.useState(500);
  const [activePaylineCount, setActivePaylineCount] = React.useState(MAX_PAYLINES); // Default to all lines
  const [currentBet, setCurrentBet] = React.useState(BASE_BET_PER_LINE * activePaylineCount);

  const initialReelSetup = () => Array(NUM_REELS).fill(null).map(() =>
    Array(NUM_ROWS).fill(null).map((_, i) => initialSymbols[i % initialSymbols.length])
  );
  const [reels, setReels] = React.useState(initialReelSetup());

  const [spinning, setSpinning] = React.useState(false);
  const [win, setWin] = React.useState(0);
  const [winMessage, setWinMessage] = React.useState('');
  const [bonusMode, setBonusMode] = React.useState(false);
  const [bonusMultiplier, setBonusMultiplier] = React.useState(1);
  const [freeSpins, setFreeSpins] = React.useState(0);
  const [soundEnabled, setSoundEnabled] = React.useState(true);
  const [winningLinePaths, setWinningLinePaths] = React.useState([]);
  
  const reelStrips = React.useMemo(() => {
    return Array(NUM_REELS).fill(null).map(() => {
        let strip = [];
        for (let i = 0; i < 40; i++) { // Longer strips for more rows
            strip = strip.concat([...initialSymbols].sort(() => 0.5 - Math.random()));
        }
        return strip;
    });
  }, [initialSymbols]);
  const reelOffsets = React.useRef(Array(NUM_REELS).fill(0));

  const spinAudioRef = React.useRef(null); // Placeholder for audio elements
  const winAudioRef = React.useRef(null);
  const bonusAudioRef = React.useRef(null);
  const jackpotAudioRef = React.useRef(null);
  const reelStopAudioRef = React.useRef(null);
  const spinningTimerRef = React.useRef(null);
  const reelsLandedRef = React.useRef(Array(NUM_REELS).fill(false));

  React.useEffect(() => { // Initialize dummy audio to prevent errors if not loaded
    const createDummyAudio = () => new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
    spinAudioRef.current = createDummyAudio(); winAudioRef.current = createDummyAudio(); bonusAudioRef.current = createDummyAudio();
    jackpotAudioRef.current = createDummyAudio(); reelStopAudioRef.current = createDummyAudio();
    return () => { if (spinningTimerRef.current) clearInterval(spinningTimerRef.current); };
  }, []);

  React.useEffect(() => {
    setCurrentBet(BASE_BET_PER_LINE * activePaylineCount);
  }, [activePaylineCount]);

  const playSound = (sound) => {
    if (soundEnabled && sound && sound.current && sound.current.HAVE_ENOUGH_DATA) {
      sound.current.currentTime = 0;
      sound.current.play().catch(e => console.warn("Audio play failed:", e));
    }
  };

  const generateResultsInternal = () => { // Purely random results
    const newReels = Array(NUM_REELS).fill(null).map((_, rIndex) => {
        const strip = reelStrips[rIndex];
        const randomStartOffset = Math.floor(Math.random() * strip.length);
        return Array(NUM_ROWS).fill(null).map((__, cIndex) => strip[(randomStartOffset + cIndex) % strip.length]);
    });

    // Sprinkle special symbols randomly - could overwrite existing, that's fine for pure RNG
    for (let i=0; i < 2; i++) { // Chance for a couple of wilds/bonus
        if (Math.random() < 0.10) { // 10% chance for a wild
          newReels[Math.floor(Math.random() * NUM_REELS)][Math.floor(Math.random() * NUM_ROWS)] = initialSymbols.find(s => s.id === 'wild');
        }
        if (Math.random() < 0.08) { // 8% chance for a bonus
          newReels[Math.floor(Math.random() * NUM_REELS)][Math.floor(Math.random() * NUM_ROWS)] = initialSymbols.find(s => s.id === 'bonus');
        }
    }
    if (Math.random() < 0.03) { // 3% chance for a jackpot symbol
         newReels[Math.floor(Math.random() * NUM_REELS)][Math.floor(Math.random() * NUM_ROWS)] = initialSymbols.find(s => s.id === 'jackpot');
    }
    return newReels;
  };
  
  const evaluateWin = (currentReels) => {
    let totalWin = 0;
    let newWinningPaylineDetails = [];
    let messages = [];
    let jackpotHitThisSpin = false;

    const activeLines = paylines.slice(0, activePaylineCount);

    activeLines.forEach(payline => {
      const symbolsOnLine = payline.coords.map(coord => currentReels[coord[0]][coord[1]]);
      if (symbolsOnLine.some(s => !s)) return; 

      let matchCount = 0;
      let firstEffectiveSymbol = symbolsOnLine[0]; // The symbol that defines the line type
      let wildSubstitutionSymbol = null; // If wild is first, what does it become?

      // Determine the effective first symbol if wilds are involved at the start
      if (firstEffectiveSymbol.id === 'wild') {
        let k = 1;
        while (k < symbolsOnLine.length && symbolsOnLine[k].id === 'wild') k++;
        if (k < symbolsOnLine.length) { // Found a non-wild symbol after initial wilds
          firstEffectiveSymbol = symbolsOnLine[k];
          wildSubstitutionSymbol = firstEffectiveSymbol;
        } else { // Line is all wilds, or starts with wilds and ends before a non-wild
          firstEffectiveSymbol = initialSymbols.find(s => s.id === 'wild'); // Treat as a "wild" line
        }
      }
      
      for (let i = 0; i < symbolsOnLine.length; i++) {
        if (symbolsOnLine[i].id === firstEffectiveSymbol.id || symbolsOnLine[i].id === 'wild') {
          matchCount++;
        } else {
          break; 
        }
      }

      // Wins typically require at least 2 or 3 matches depending on the symbol
      const minMatch = (firstEffectiveSymbol.id === 'cherry' || firstEffectiveSymbol.id === 'lemon' || firstEffectiveSymbol.id === 'wild') ? 2 : 3;

      if (matchCount >= minMatch) {
        const symbolValue = (firstEffectiveSymbol.id === 'wild' && wildSubstitutionSymbol) 
                            ? wildSubstitutionSymbol.value // Value of symbol wild substitutes
                            : (firstEffectiveSymbol.id === 'wild' ? 20 : firstEffectiveSymbol.value); // Wild line or actual symbol value

        // Adjust multiplier: 3-match=x1, 4-match=x3, 5-match=x10 (example)
        let winMultiplier = 0;
        if (matchCount === 2 && minMatch === 2) winMultiplier = 0.5; // Small win for 2 specific symbols
        else if (matchCount === 3) winMultiplier = 1;
        else if (matchCount === 4) winMultiplier = 3;
        else if (matchCount === 5) winMultiplier = 10;

        if (firstEffectiveSymbol.id === 'jackpot') { // Jackpot specific multipliers
            if (matchCount === 3) winMultiplier = 5;
            else if (matchCount === 4) winMultiplier = 25;
            else if (matchCount === 5) winMultiplier = 100;
        }
        
        const lineWin = Math.floor(symbolValue * winMultiplier * BASE_BET_PER_LINE * bonusMultiplier);
        
        if (lineWin > 0) {
            totalWin += lineWin;
            const displaySymbol = wildSubstitutionSymbol || firstEffectiveSymbol;
            newWinningPaylineDetails.push({ 
                lineId: payline.id, 
                coords: payline.coords.slice(0, matchCount), // Only highlight matched symbols
                amount: lineWin,
                matchedSymbolId: displaySymbol.id,
                matchCount: matchCount,
                color: displaySymbol.color || '#FFD700'
            });
            if (displaySymbol.id === 'jackpot' && matchCount >= 3) jackpotHitThisSpin = true;
            if (messages.length < 5) messages.push(`L${payline.id}: ${matchCount}x ${displaySymbol.id.toUpperCase()}! (+$${lineWin})`);
        }
      }
    });

    let bonusSymbolCount = 0;
    for (let r=0; r<NUM_REELS; r++) for (let c=0; c<NUM_ROWS; c++) if(currentReels[r][c]?.id === 'bonus') bonusSymbolCount++;
    
    if (bonusSymbolCount >= 3 && !bonusMode) {
      activateBonus();
      messages.unshift("BONUS ROUND! 3+ Scatters!"); // Add to start of messages
    }
    
    setWinningLinePaths(generateWinningLinePaths(newWinningPaylineDetails));
    
    if (totalWin > 0) {
      setWin(totalWin);
      setMoney(prev => prev + totalWin);
      setWinMessage(messages.length > 1 ? `Multiple Wins! Total: $${totalWin}` : messages[0] || `You Won $${totalWin}!`);
      if (jackpotHitThisSpin) playSound(jackpotAudioRef); else playSound(winAudioRef);
    } else {
       setWinMessage(''); 
    }
    
    if (money < currentBet && freeSpins === 0 && !bonusMode && totalWin < currentBet) {
      const refill = Math.max(currentBet * 3, 50); // Less aggressive refill
      setMoney(prev => prev + refill);
      setWinMessage(prev => (prev ? prev + " " : "") + `Low Funds! +$${refill}`);
    }
  };

  const spin = () => {
    if (spinning) return;
    if (activePaylineCount === 0 && freeSpins === 0) {
        setWinMessage("Select paylines to bet!");
        return;
    }

    if (freeSpins > 0) {
      setFreeSpins(prev => prev - 1);
    } else {
      if (money < currentBet) {
        setWinMessage("Not enough cash!");
        return;
      }
      setMoney(prev => prev - currentBet);
    }
    
    setSpinning(true);
    setWin(0);
    setWinMessage('');
    setWinningLinePaths([]);
    playSound(spinAudioRef);
    reelsLandedRef.current = Array(NUM_REELS).fill(false);

    const finalCalculatedReels = generateResultsInternal();
    const spinFrameTime = 50; 
    const baseSpinDurationFrames = 25; 
    const staggerDurationFrames = 12;
    let framesPassed = 0;

    spinningTimerRef.current = setInterval(() => {
      framesPassed++;
      let allReelsLanded = true;

      const nextVisualReels = reels.map((_, rIndex) => {
        const stopFrameForThisReel = baseSpinDurationFrames + rIndex * staggerDurationFrames;
        if (framesPassed < stopFrameForThisReel) {
          allReelsLanded = false;
          reelOffsets.current[rIndex] = (reelOffsets.current[rIndex] + 1 + rIndex % 3) % reelStrips[rIndex].length;
          const currentStrip = reelStrips[rIndex];
          const currentOffset = reelOffsets.current[rIndex];
          return Array(NUM_ROWS).fill(null).map((_, rowIndex) => 
            currentStrip[(currentOffset + rowIndex) % currentStrip.length]
          );
        } else {
          if (!reelsLandedRef.current[rIndex]) {
             playSound(reelStopAudioRef);
             reelsLandedRef.current[rIndex] = true;
          }
          return finalCalculatedReels[rIndex];
        }
      });
      setReels(nextVisualReels);

      if (allReelsLanded) {
        clearInterval(spinningTimerRef.current);
        evaluateWin(finalCalculatedReels);
        setSpinning(false);
         if (bonusMode && freeSpins === 0) {
            setBonusMode(false);
            setBonusMultiplier(1);
            setWinMessage(prev => (prev ? prev + " " : "") + "Bonus Mode Over.");
         }
      }
    }, spinFrameTime);
  };
  
  const activateBonus = () => {
    setBonusMode(true);
    setBonusMultiplier(2 + Math.floor(Math.random()*2)); // 2x or 3x
    setFreeSpins(prev => prev + 5 + Math.floor(Math.random()*6)); // 5-10 free spins
    playSound(bonusAudioRef);
  };
  
  const handlePaylineChange = (amount) => {
    if (spinning) return;
    setActivePaylineCount(prev => Math.max(0, Math.min(MAX_PAYLINES, prev + amount)));
  };

  const generateWinningLinePaths = (winningDetails) => {
    // Calculate total width and height of the visible reel area
    const reelColumnDisplayWidth = SYMBOL_SIZE_PX + (REEL_COLUMN_PADDING_PX * 2);
    const totalReelsWidth = (NUM_REELS * reelColumnDisplayWidth) + ((NUM_REELS - 1) * GAP_BETWEEN_REELS_PX);
    //const totalReelsHeight = (NUM_ROWS * (SYMBOL_SIZE_PX + SYMBOL_MARGIN_Y_PX * 2)) - (SYMBOL_MARGIN_Y_PX*2); // Approx
    const reelsAreaPadding = 2; // From .reels-area CSS p-1 (0.25rem = 4px if 16px base, but p-0.5 is 2px)

    return winningDetails.map(detail => {
        const pathPoints = detail.coords.map(([reelIdx, rowIdx]) => {
            // X: center of the symbol within its column
            const x = reelsAreaPadding +                                           // Padding of outer .reels-area
                      reelIdx * (reelColumnDisplayWidth + GAP_BETWEEN_REELS_PX) +  // Offset for previous reels and gaps
                      REEL_COLUMN_PADDING_PX +                                     // Padding within the reel column
                      (SYMBOL_SIZE_PX / 2);                                        // Center of the symbol

            // Y: center of the symbol within its row
            const y = reelsAreaPadding +
                      rowIdx * (SYMBOL_SIZE_PX + SYMBOL_MARGIN_Y_PX * 2) + // my-0.5 is 2px top, 2px bottom
                      SYMBOL_MARGIN_Y_PX + // Account for top margin of symbol
                      (SYMBOL_SIZE_PX / 2);
            return `${x.toFixed(1)},${y.toFixed(1)}`;
        }).join(' L ');
        return { d: `M ${pathPoints}`, color: detail.color, id: detail.lineId };
    });
  };
  
  const renderSymbol = (symbol, key, reelIdx, rowIdx) => {
    if (!symbol || !symbol.pattern) {
      return <div key={key} className="slot-symbol-container bg-gray-500"></div>;
    }
    const isWinningSymbol = winningLinePaths.some(pathData => {
        const paylineDef = paylines.find(pl => pl.id === pathData.id);
        return paylineDef?.coords.some(c => c[0] === reelIdx && c[1] === rowIdx);
    });

    return (
      <div 
        key={key} 
        className={`slot-symbol-container ${isWinningSymbol ? 'animate-pulse' : ''}`}
         style={{ 
          borderColor: isWinningSymbol ? symbol.color : '#444',
          boxShadow: isWinningSymbol ? `0 0 4px ${symbol.color}` : 'none',
          transform: isWinningSymbol ? 'scale(1.05)' : 'scale(1)',
        }}
      >
        <div className="pixel-grid">
          {symbol.pattern.flat().map((pixelState, i) => (
            <div 
              key={i} 
              className="pixel"
              style={{ backgroundColor: pixelState === 1 ? symbol.color : 'transparent' }}
            />
          ))}
        </div>
      </div>
    );
  };
    
  return (
    <div className="relative flex flex-col items-center justify-center bg-gray-950 p-1 rounded-lg border-2 border-amber-500 max-w-sm mx-auto overflow-hidden">
      
      {winMessage && (
        <div className="absolute top-0 left-0 right-0 text-center text-xxs font-bold text-white bg-green-600 py-0.5 px-1 z-40" style={{minHeight: '16px', maxHeight: '36px', overflowY: 'auto'}}>
          {winMessage.split('!').map(msg => <div key={msg}>{msg}{msg && '!'}</div>)}
        </div>
      )}
      
      {bonusMode && ( // Show below win message if both active
        <div className={`absolute ${winMessage ? 'top-4 md:top-5' : 'top-0'} left-0 right-0 text-center text-xxs font-bold text-white bg-pink-600 py-0.5 animate-pulse z-40`}>
          BONUS! x{bonusMultiplier} ({freeSpins} FS)
        </div>
      )}
      
      <div className="reels-area mt-1"> {/* mt-1 for spacing from messages */}
        <div className="flex" style={{gap: `${GAP_BETWEEN_REELS_PX}px`}}> {/* Use precise gap */}
          {reels.map((reelSymbols, reelIndex) => (
            <div key={reelIndex} className="relative bg-gray-800 rounded" style={{padding: `${REEL_COLUMN_PADDING_PX}px`}}>
              {reelSymbols.map((symbol, symbolIndex) => (
                <div key={`${reelIndex}-${symbol ? symbol.id : 'e'}-${symbolIndex}`} style={{marginTop: `${SYMBOL_MARGIN_Y_PX}px`, marginBottom: `${SYMBOL_MARGIN_Y_PX}px`}}>
                  {renderSymbol( symbol, `${reelIndex}-${symbol ? symbol.id : 's'}-${symbolIndex}`, reelIndex, symbolIndex )}
                </div>
              ))}
            </div>
          ))}
        </div>
        <svg className="winning-lines-svg">
            {winningLinePaths.map(path => (
                <path key={path.id} d={path.d} stroke={path.color} strokeWidth="2.5" fill="none" strokeLinecap="round" strokeOpacity="0.8" style={{filter: `drop-shadow(0 0 1.5px ${path.color})`}} />
            ))}
        </svg>
      </div>
      
      {win > 0 && !winMessage.toLowerCase().includes("win") && (
        <div className="bg-yellow-500 text-black text-xs font-bold px-2 py-0.5 rounded-lg mb-1 animate-pulse">
          WIN: ${win}!
        </div>
      )}
      
      <div className="flex items-center justify-between w-full mt-1 text-xxs px-1">
        <span>Paylines:</span>
        <div className="flex items-center" style={{gap: '2px'}}>
            <button onClick={() => handlePaylineChange(-1)} disabled={spinning || activePaylineCount <= 0} className="payline-button rounded bg-gray-700 text-white border-gray-600">-</button>
            <span className="font-bold text-amber-400 w-4 text-center">{activePaylineCount}</span>
            <button onClick={() => handlePaylineChange(1)} disabled={spinning || activePaylineCount >= MAX_PAYLINES} className="payline-button rounded bg-gray-700 text-white border-gray-600">+</button>
        </div>
         <span>Bet: <span className="font-bold text-white">${currentBet}</span></span>
      </div>

      <div className="flex items-center justify-between w-full mt-1 px-1">
        <div className="bg-black px-1.5 py-0.5 rounded-lg border border-green-500 text-xs">
          <span className="text-green-500 font-bold">CASH:</span>
          <span className="text-white ml-0.5">${money}</span>
        </div>
        
        <button 
          onClick={spin}
          disabled={spinning || (activePaylineCount === 0 && freeSpins === 0) || (money < currentBet && freeSpins === 0)}
          className={`flex items-center justify-center bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded-full text-xs ${spinning || (activePaylineCount === 0 && freeSpins === 0) ? 'opacity-50' : ''}`}
        >
          <span className="mr-0.5 text-xs">â–¶</span>
          {spinning ? '...' : (freeSpins > 0 ? `FS (${freeSpins})` : 'SPIN')}
        </button>
        
        <button
          onClick={() => setSoundEnabled(!soundEnabled)}
          className="bg-gray-700 hover:bg-gray-600 text-white p-1 rounded-full border-gray-600"
        >
          {soundEnabled ? <span className="text-xs">ðŸ”Š</span> : <span className="text-xs">ðŸ”‡</span>}
        </button>
      </div>
       {freeSpins > 0 && !bonusMode && (
        <div className="text-center text-xxs text-blue-400 mt-0.5 animate-bounce">
          {freeSpins} FREE SPINS!
        </div>
      )}
    </div>
  );
};

ReactDOM.render(<SlotMachine />, document.getElementById('root'));
    </script>
</body>
</html>
