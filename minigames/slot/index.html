<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Bit Dollar Frenzy - Deluxe</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a2e; /* Darker blueish background */
            color: #e0e0e0; /* Lighter text color */
            margin: 0;
            padding: 10px; /* Reduced padding */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        #root {
            width: 100%;
            max-width: 420px; /* Slightly smaller max width */
        }

        /* Basic Tailwind-like utilities */
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .gap-1 { gap: 0.25rem; }
        .gap-2 { gap: 0.5rem; }
        .p-1 { padding: 0.25rem; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-4 { padding: 1rem; }
        .my-1 { margin-top: 0.25rem; margin-bottom: 0.25rem; }
        .my-2 { margin-top: 0.5rem; margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-3 { margin-top: 0.75rem; }
        .mr-1 { margin-right: 0.25rem; }
        .ml-1 { margin-left: 0.25rem; }
        .w-full { width: 100%; }
        .text-xs { font-size: 0.75rem; }
        .text-sm { font-size: 0.875rem; }
        .text-base { font-size: 1rem; }
        .text-lg { font-size: 1.125rem; }
        .text-xl { font-size: 1.25rem; }
        .text-2xl { font-size: 1.5rem; }
        .font-bold { font-weight: bold; }
        .uppercase { text-transform: uppercase; }
        .tracking-wider { letter-spacing: 0.05em; }
        .rounded { border-radius: 0.25rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .rounded-full { border-radius: 9999px; }
        .border-2 { border-width: 2px; }
        .border-4 { border-width: 4px; }
        .border-amber-500 { border-color: #f59e0b; }
        .border-gray-700 { border-color: #374151; }
        .border-green-500 { border-color: #22c55e; }
        .bg-gray-950 { background-color: #0c0d1f; } /* Darker machine body */
        .bg-black { background-color: #000; }
        .bg-gray-800 { background-color: #1f2937; } /* Reel background */
        .bg-red-600 { background-color: #dc2626; }
        .hover\:bg-red-700:hover { background-color: #b91c1c; }
        .bg-blue-600 { background-color: #2563eb; }
        .hover\:bg-blue-700:hover { background-color: #1d4ed8; }
        .bg-green-600 { background-color: #16a34a; }
        .bg-yellow-500 { background-color: #eab308; }
        .bg-pink-600 { background-color: #db2777; }
        .text-white { color: #fff; }
        .text-black { color: #000; }
        .text-amber-400 { color: #fbbf24; }
        .text-green-500 { color: #22c55e; }
        .text-gray-400 { color: #9ca3af; }
        .opacity-50 { opacity: 0.5; }
        .absolute { position: absolute; }
        .relative { position: relative; }
        .top-0 { top: 0; }
        .left-0 { left: 0; }
        .right-0 { right: 0; }
        .bottom-0 { bottom: 0; }
        .top-12 { top: 3rem; } /* Adjusted for smaller layout */
        .top-20 { top: 5rem; } /* Adjusted */
        .right-2 { right: 0.5rem; } /* Adjusted */
        .text-center { text-align: center; }
        .z-10 { z-index: 10; }
        .z-20 { z-index: 20; }
        .max-w-sm { max-width: 24rem; } /* Adjusted for overall smaller game */
        .mx-auto { margin-left: auto; margin-right: auto; }
        .overflow-hidden { overflow: hidden; }
        .inline-block { display: inline-block; }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .6; } }
        .animate-pulse { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }

        @keyframes bounce { 0%, 100% { transform: translateY(-20%); animation-timing-function: cubic-bezier(0.8,0,1,1); } 50% { transform: translateY(0); animation-timing-function: cubic-bezier(0,0,0.2,1); } }
        .animate-bounce { animation: bounce 1s infinite; }

        .pixel-grid { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%; height: 100%; }
        .pixel { width: 100%; height: 100%; }
        
        button { cursor: pointer; transition: background-color 0.2s ease, opacity 0.2s ease; user-select: none; }
        button:disabled { cursor: not-allowed; opacity: 0.6; }
        
        .slot-symbol-container {
            width: 40px; /* Smaller symbols */
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #2a2a3e; /* Symbol background */
            border: 1px solid #444;
        }
         @media (min-width: 380px) {
             .slot-symbol-container {
                width: 48px; 
                height: 48px;
            }
        }

        .payline-info {
            font-size: 0.65rem;
            background-color: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 3px;
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
const SlotMachine = () => {
  const initialSymbols = [
    { id: 'cherry', value: 10, color: '#FF0000', pattern: [[0,0,0,0,0,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,0,0,1,0,0,0],[0,0,1,1,0,0,0,0],[0,1,1,1,1,0,0,0],[1,1,1,1,1,1,0,0],[0,1,1,1,1,0,0,0]] },
    { id: 'lemon', value: 20, color: '#FFFF00', pattern: [[0,0,1,1,1,0,0,0],[0,1,1,1,1,1,0,0],[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[0,1,1,1,1,1,0,0],[0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,0]] },
    { id: 'seven', value: 50, color: '#0000FF', pattern: [[1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,0],[0,0,0,0,0,1,1,0],[0,0,0,0,1,1,0,0],[0,0,0,1,1,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0],[0,0,1,1,0,0,0,0]] },
    { id: 'diamond', value: 100, color: '#00FFFF', pattern: [[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,1,1,0,0,0]] },
    { id: 'star', value: 200, color: '#FF00FF', pattern: [[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[1,1,0,0,0,0,1,1]] },
    { id: 'bonus', value: 0, color: '#00FF00', pattern: [[0,0,1,1,1,1,0,0],[0,0,1,0,0,1,0,0],[1,1,1,1,1,1,1,1],[1,0,1,0,0,1,0,1],[1,0,1,0,0,1,0,1],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0]] }, // Bonus can trigger free spins
    { id: 'wild', value: 0, color: '#FFACFC', pattern: [[1,1,0,0,0,0,1,1],[1,1,0,0,0,0,1,1],[1,1,0,1,1,0,1,1],[1,1,1,1,1,1,1,1],[1,1,1,0,0,1,1,1],[1,1,0,1,1,0,1,1],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0]] }, // Lighter Wild
    { id: 'jackpot', value: 500, color: '#FFAA00', pattern: [[0,0,0,1,1,0,0,0],[0,0,1,1,1,1,0,0],[0,1,1,0,0,1,1,0],[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0],[0,0,0,0,0,1,1,0],[0,1,1,0,0,1,1,0],[0,0,1,1,1,1,0,0]] }
  ];
  const symbols = React.useMemo(() => initialSymbols, []);

  const paylines = React.useMemo(() => [
    { id: 1, name: 'Top Row', coords: [[0,0], [1,0], [2,0]] },
    { id: 2, name: 'Middle Row', coords: [[0,1], [1,1], [2,1]] },
    { id: 3, name: 'Bottom Row', coords: [[0,2], [1,2], [2,2]] },
    { id: 4, name: 'Diagonal TL-BR', coords: [[0,0], [1,1], [2,2]] },
    { id: 5, name: 'Diagonal BL-TR', coords: [[0,2], [1,1], [2,0]] },
  ], []);

  const [money, setMoney] = React.useState(100);
  const [betPerSpin, setBetPerSpin] = React.useState(5); // Bet covers all 5 lines (1 per line)
  const [reels, setReels] = React.useState([
    [symbols[0], symbols[1], symbols[2]],
    [symbols[1], symbols[2], symbols[3]],
    [symbols[2], symbols[3], symbols[4]]
  ]);
  const [spinning, setSpinning] = React.useState(false);
  const [win, setWin] = React.useState(0);
  const [winMessage, setWinMessage] = React.useState('');
  const [bonusMode, setBonusMode] = React.useState(false);
  const [bonusMultiplier, setBonusMultiplier] = React.useState(1);
  const [freeSpins, setFreeSpins] = React.useState(0);
  const [soundEnabled, setSoundEnabled] = React.useState(true);
  const [winningPaylineDetails, setWinningPaylineDetails] = React.useState([]);
  
  const reelStrips = React.useMemo(() => {
    return [0,1,2].map(() => {
        let strip = [];
        for (let i = 0; i < 15; i++) { // Longer strips for smoother visuals
            strip = strip.concat([...symbols].sort(() => 0.5 - Math.random()));
        }
        return strip;
    });
  }, [symbols]);
  const reelOffsets = React.useRef([0,0,0]);

  const spinAudioRef = React.useRef(null);
  const winAudioRef = React.useRef(null);
  const bonusAudioRef = React.useRef(null);
  const jackpotAudioRef = React.useRef(null);
  const reelStopAudioRef = React.useRef(null);
  const spinningTimerRef = React.useRef(null);
  const reelsLandedRef = React.useRef([false,false,false]);

  React.useEffect(() => {
    spinAudioRef.current = new Audio('data:audio/wav;base64,UklGRl9CAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA');
    winAudioRef.current = new Audio('data:audio/wav;base64,UklGRl9CAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA');
    bonusAudioRef.current = new Audio('data:audio/wav;base64,UklGRl9CAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA');
    jackpotAudioRef.current = new Audio('data:audio/wav;base64,UklGRl9CAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA');
    reelStopAudioRef.current = new Audio('data:audio/wav;base64,UklGRl9CAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA');
    
    return () => {
      if (spinningTimerRef.current) clearInterval(spinningTimerRef.current);
    };
  }, []);

  const playSound = (sound) => {
    if (soundEnabled && sound && sound.current) {
      sound.current.currentTime = 0;
      sound.current.play().catch(e => console.warn("Audio play failed:", e));
    }
  };

  const getRandomSymbol = (biasFactor = 0) => {
    // biasFactor: 0 to 1. Higher means more chance of common/lower value symbols.
    const r = Math.random();
    if (r < 0.3 + biasFactor * 0.3) return symbols[Math.floor(Math.random() * 2)]; // Cherry, Lemon
    if (r < 0.6 + biasFactor * 0.2) return symbols[Math.floor(Math.random() * 3)]; // Cherry, Lemon, Seven
    if (r < 0.8) return symbols[Math.floor(Math.random() * (symbols.length - 3))]; // Avoid special
    return symbols[Math.floor(Math.random() * symbols.length)]; // Any symbol
  };

  const generateResultsInternal = () => {
    const newReels = [[], [], []];
    const luckySpinChance = Math.random() < 0.80 || bonusMode; // Very generous

    if (luckySpinChance) {
        // Try to force a win on at least one payline
        const targetPayline = paylines[Math.floor(Math.random() * paylines.length)];
        const winSymbol = symbols[Math.floor(Math.random() * 4)]; // Cherry, Lemon, Seven, Diamond
        const numToMatch = Math.random() < 0.7 ? 3 : 2; // Prefer 3 matches

        for(let i=0; i<3; i++) { // Initialize with random symbols
            newReels[i] = [getRandomSymbol(0.5), getRandomSymbol(0.5), getRandomSymbol(0.5)];
        }
        
        // Place winning symbols on the target payline
        for (let i = 0; i < numToMatch; i++) {
            const [reelIdx, rowIdx] = targetPayline.coords[i];
            newReels[reelIdx][rowIdx] = Math.random() < 0.2 ? symbols.find(s=>s.id==='wild') : winSymbol; // Chance of wild
        }
         // Fill remaining spots on the target payline if it was a 2-match
        if (numToMatch === 2) {
            const [reelIdx, rowIdx] = targetPayline.coords[2];
            newReels[reelIdx][rowIdx] = getRandomSymbol(0.2); // Less likely to match
        }

    } else {
      for (let i = 0; i < 3; i++) {
        newReels[i] = [getRandomSymbol(0.2), getRandomSymbol(0.2), getRandomSymbol(0.2)];
      }
    }

    // Sprinkle some special symbols
    if (Math.random() < 0.15 || (bonusMode && Math.random() < 0.3)) { // Increased bonus chance in bonus mode
      newReels[Math.floor(Math.random() * 3)][Math.floor(Math.random() * 3)] = symbols.find(s => s.id === 'bonus');
    }
    if (Math.random() < 0.20) {
      newReels[Math.floor(Math.random() * 3)][Math.floor(Math.random() * 3)] = symbols.find(s => s.id === 'wild');
    }
    if (Math.random() < 0.10) {
      newReels[Math.floor(Math.random() * 3)][Math.floor(Math.random() * 3)] = symbols.find(s => s.id === 'jackpot');
    }
    return newReels;
  };
  
  const evaluateWin = (currentReels) => {
    let totalWin = 0;
    let newWinningPaylineDetails = [];
    let messages = [];
    let bonusTriggeredThisSpin = false;
    let jackpotHit = false;

    paylines.forEach(payline => {
      const symbolsOnLine = payline.coords.map(coord => currentReels[coord[0]][coord[1]]);
      let matchCount = 0;
      let firstSymbol = symbolsOnLine[0];
      let wildValueIfFirst = 0; // If first is wild, what does it represent?

      if (firstSymbol.id === 'wild') {
        // Wild at start: check next non-wild symbol to determine line type
        let i = 1;
        while(i < symbolsOnLine.length && symbolsOnLine[i].id === 'wild') i++;
        if (i < symbolsOnLine.length) { // Found a non-wild symbol
            firstSymbol = symbolsOnLine[i]; // This is the symbol the wilds will substitute
            matchCount = i; // All wilds before it count
        } else { // All symbols on line are wild
            firstSymbol = symbols.find(s => s.id === 'wild'); // Treat as a line of wilds
            matchCount = 0; // Reset, count all wilds next
        }
        wildValueIfFirst = firstSymbol.value > 0 ? firstSymbol.value : 20; // Wilds-only line value
      }
      
      for (let i = 0; i < symbolsOnLine.length; i++) {
        if (symbolsOnLine[i].id === firstSymbol.id || symbolsOnLine[i].id === 'wild') {
          matchCount++;
        } else {
          break; 
        }
      }

      if (matchCount >= 2) {
        const lineSymbolValue = firstSymbol.id === 'wild' ? wildValueIfFirst : firstSymbol.value;
        const winMultiplier = matchCount === 3 ? 5 : (matchCount === 2 ? 1 : 0);
        const lineWin = (lineSymbolValue * winMultiplier * (betPerSpin / paylines.length) * bonusMultiplier);
        
        if (lineWin > 0) {
            totalWin += lineWin;
            newWinningPaylineDetails.push({ 
                lineId: payline.id, 
                coords: payline.coords, 
                symbols: symbolsOnLine, 
                amount: lineWin,
                matchedSymbol: firstSymbol.id,
                matchCount: matchCount
            });
            if (firstSymbol.id === 'jackpot' && matchCount === 3) jackpotHit = true;
             messages.push(`${payline.name}: ${matchCount}x ${firstSymbol.id.toUpperCase()}!`);
        }
      }
    });

    // Check for bonus symbols anywhere on the reels (3 needed for bonus)
    let bonusSymbolCount = 0;
    for (let r=0; r<3; r++) for (let c=0; c<3; c++) if(currentReels[r][c].id === 'bonus') bonusSymbolCount++;
    
    if (bonusSymbolCount >= 3 && !bonusMode) {
      bonusTriggeredThisSpin = true;
      activateBonus();
      messages.push("BONUS TRIGGERED!");
    }
    
    setWinningPaylineDetails(newWinningPaylineDetails);
    
    if (totalWin > 0) {
      const finalWin = Math.floor(totalWin);
      setWin(finalWin);
      setMoney(prev => prev + finalWin);
      setWinMessage(messages.length > 1 ? `Multiple Wins! +$${finalWin}` : messages[0] || `You Won $${finalWin}!`);
      if (jackpotHit) playSound(jackpotAudioRef); else playSound(winAudioRef);
    } else {
       setWinMessage(''); // Clear if no win
    }

    if (totalWin === 0 && Math.random() < 0.1) {
      const consolationPrize = Math.floor(betPerSpin * (Math.random() * 0.5 + 0.2)); // up to 70% of bet
      if (consolationPrize > 0) {
        setMoney(prev => prev + consolationPrize);
        setWinMessage(`Close! +$${consolationPrize}`);
        setWin(consolationPrize);
      }
    }
    
    if (money < betPerSpin && freeSpins === 0 && !bonusMode && totalWin < betPerSpin) {
      const refill = Math.max(betPerSpin * 5, 50); // Generous refill
      setMoney(prev => prev + refill);
      setWinMessage(prev => (prev ? prev + " " : "") + `Low Funds! +$${refill}`);
    }
  };

  const spin = () => {
    if (spinning) return;

    if (freeSpins > 0) {
      setFreeSpins(prev => prev - 1);
    } else {
      if (money < betPerSpin) {
        setWinMessage("Not enough money!");
        return;
      }
      setMoney(prev => prev - betPerSpin);
    }
    
    setSpinning(true);
    setWin(0);
    setWinMessage('');
    setWinningPaylineDetails([]);
    playSound(spinAudioRef);
    reelsLandedRef.current = [false, false, false];

    const finalCalculatedReels = generateResultsInternal();
    const spinFrameTime = 50; 
    const baseSpinDurationFrames = 30; // Approx 1.5s for first reel
    const staggerDurationFrames = 15; // Approx 0.75s between reel stops
    let framesPassed = 0;

    spinningTimerRef.current = setInterval(() => {
      framesPassed++;
      let allReelsLanded = true;

      const nextVisualReels = reels.map((_, rIndex) => {
        const stopFrameForThisReel = baseSpinDurationFrames + rIndex * staggerDurationFrames;
        if (framesPassed < stopFrameForThisReel) {
          allReelsLanded = false;
          reelOffsets.current[rIndex] = (reelOffsets.current[rIndex] + 1 + rIndex) % reelStrips[rIndex].length; // Vary speed slightly
          return [
            reelStrips[rIndex][(reelOffsets.current[rIndex] + 0) % reelStrips[rIndex].length],
            reelStrips[rIndex][(reelOffsets.current[rIndex] + 1) % reelStrips[rIndex].length],
            reelStrips[rIndex][(reelOffsets.current[rIndex] + 2) % reelStrips[rIndex].length],
          ];
        } else {
          if (!reelsLandedRef.current[rIndex]) {
             playSound(reelStopAudioRef);
             reelsLandedRef.current[rIndex] = true;
          }
          return finalCalculatedReels[rIndex];
        }
      });
      
      setReels(nextVisualReels);

      if (allReelsLanded) {
        clearInterval(spinningTimerRef.current);
        evaluateWin(finalCalculatedReels);
        setSpinning(false);
         if (bonusMode && freeSpins === 0) {
            setBonusMode(false);
            setBonusMultiplier(1);
            setWinMessage(prev => (prev ? prev + " " : "") + "Bonus Mode Ended.");
         }
      }
    }, spinFrameTime);
  };
  
  const activateBonus = () => {
    setBonusMode(true);
    setBonusMultiplier(2 + Math.floor(Math.random()*2)); // Multiplier 2x or 3x
    setFreeSpins(prev => prev + 5 + Math.floor(Math.random()*6)); // 5-10 free spins
    playSound(bonusAudioRef);
  };
  
  const changeBet = () => {
    if (spinning) return;
    const betOptions = [5, 10, 25, 50, 100]; 
    const currentIndex = betOptions.indexOf(betPerSpin);
    const nextIndex = (currentIndex + 1) % betOptions.length;
    setBetPerSpin(betOptions[nextIndex]);
  };
  
  const renderSymbol = (symbol, key, reelIdx, rowIdx) => {
    if (!symbol || !symbol.pattern) {
      return <div key={key} className="slot-symbol-container bg-gray-500"></div>;
    }
    const isWinning = winningPaylineDetails.some(detail => 
        detail.coords.some(coord => coord[0] === reelIdx && coord[1] === rowIdx)
    );

    return (
      <div 
        key={key} 
        className={`slot-symbol-container ${isWinning ? 'animate-pulse' : ''}`}
        style={{ 
          boxShadow: isWinning ? `0 0 6px ${symbol.color}, 0 0 12px ${symbol.color}` : 'none',
          transform: isWinning ? 'scale(1.05)' : 'scale(1)',
          transition: 'transform 0.2s, box-shadow 0.2s',
          border: isWinning ? `2px solid ${symbol.color}` : '1px solid #444',
          borderRadius: '3px'
        }}
      >
        <div className="pixel-grid">
          {symbol.pattern.flat().map((pixelState, i) => (
            <div 
              key={i} 
              className="pixel"
              style={{ backgroundColor: pixelState === 1 ? symbol.color : 'transparent' }}
            />
          ))}
        </div>
      </div>
    );
  };
    
  return (
    <div className="relative flex flex-col items-center justify-center bg-gray-950 p-2 md:p-3 rounded-lg border-4 border-amber-500 max-w-sm mx-auto overflow-hidden">
      {/* Decorative corners */}
      {[...Array(4)].map((_, i) => <div key={i} className={`absolute w-3 h-3 bg-amber-500 ${i===0?'top-0 left-0':i===1?'top-0 right-0':i===2?'bottom-0 left-0':'bottom-0 right-0'}`}></div>)}

      <div className="text-xl md:text-2xl font-bold text-amber-400 mb-1 uppercase tracking-wider" style={{textShadow: '2px 2px #000'}}>
        8-Bit <span style={{color: '#FFAA00', fontSize: '1.1em'}}>$$</span> Frenzy
      </div>
      
      {winMessage && (
        <div className="absolute top-12 left-0 right-0 text-center text-sm md:text-base font-bold text-white bg-green-600 py-1 px-1 animate-pulse z-20" style={{minHeight: '24px'}}>
          {winMessage}
        </div>
      )}
      
      {bonusMode && (
        <div className="absolute top-0 left-0 right-0 text-center text-xs md:text-sm font-bold text-white bg-pink-600 py-0.5 md:py-1 animate-pulse z-20">
          BONUS! x{bonusMultiplier} WINS!
        </div>
      )}
      
      {freeSpins > 0 && !bonusMode && ( // Show only if not in bonus mode title already
        <div className="absolute top-20 right-2 bg-blue-600 text-white px-1.5 py-0.5 rounded-md text-xs animate-bounce z-10">
          {freeSpins} FREE SPINS
        </div>
      )}
      
      <div className="relative bg-black p-1 md:p-2 rounded border-2 border-gray-700 my-2">
        <div className="flex gap-1 md:gap-1.5"> {/* Reduced gap */}
          {reels.map((reelSymbols, reelIndex) => (
            <div key={reelIndex} className="relative bg-gray-800 p-0.5 md:p-1 rounded">
              {reelSymbols.map((symbol, symbolIndex) => (
                <div key={`${reelIndex}-${symbol ? symbol.id : 'empty'}-${symbolIndex}`} className="my-0.5 md:my-1">
                  {renderSymbol(
                    symbol, 
                    `${reelIndex}-${symbol ? symbol.id : 's'}-${symbolIndex}`,
                    reelIndex,
                    symbolIndex
                  )}
                </div>
              ))}
            </div>
          ))}
        </div>
         <div className="payline-info text-gray-400">All 5 Paylines Active!</div>
      </div>
      
      {win > 0 && (
        <div className="bg-yellow-500 text-black text-base md:text-lg font-bold px-3 py-0.5 rounded-lg mb-1 animate-pulse">
          WIN: ${win}!
        </div>
      )}
      
      <div className="flex items-center justify-between w-full mt-1 md:mt-2">
        <div className="bg-black px-2 py-1 rounded-lg border-2 border-green-500 text-xs md:text-sm">
          <span className="text-green-500 font-bold">CASH:</span>
          <span className="text-white ml-1">${money}</span>
        </div>
        
        <button 
          onClick={spin}
          disabled={spinning || (money < betPerSpin && freeSpins === 0)}
          className={`flex items-center justify-center bg-red-600 hover:bg-red-700 text-white font-bold py-1.5 px-2 md:px-3 rounded-full text-sm md:text-base ${spinning ? 'opacity-50' : ''}`}
        >
          <span className="mr-1 text-base md:text-lg">â–¶</span>
          {spinning ? 'SPINNING...' : (freeSpins > 0 ? `SPIN (${freeSpins})` : 'SPIN')}
        </button>
        
        <button 
          onClick={changeBet}
          disabled={spinning}
          className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-1.5 md:px-2 rounded text-xs md:text-sm"
        >
          BET: ${betPerSpin}
        </button>
      </div>
      
      <div className="flex items-center justify-center w-full mt-2 md:mt-3">
        <button
          onClick={() => setSoundEnabled(!soundEnabled)}
          className="bg-gray-700 hover:bg-gray-600 text-white p-1.5 rounded-full"
        >
          {soundEnabled ? <span className="text-sm md:text-base">ðŸ”Š</span> : <span className="text-sm md:text-base">ðŸ”‡</span>}
        </button>
        <div className="text-xs text-gray-400 ml-2">
          {bonusMode ? `BONUS x${bonusMultiplier} ACTIVE! ${freeSpins} spins left.` : "Match 2+ symbols left-to-right!"}
        </div>
      </div>
    </div>
  );
};

ReactDOM.render(<SlotMachine />, document.getElementById('root'));
    </script>
</body>
</html>
