<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async RPG Adventure</title>
    <!-- jsrsasign library for JWT signing (Service Account Auth) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/10.8.6/jsrsasign-all-min.js"></script>
    <style>
        :root {
            --primary-color: #3f51b5;
            --primary-dark: #303f9f;
            --secondary-color: #ff4081;
            --text-color: #333;
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #9e9e9e;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
            --radius: 8px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light-gray);
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .login-container {
            width: 100%;
            max-width: 500px;
            margin: 80px auto;
            padding: 30px;
            background-color: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }
        
        .main-container {
            display: none;
            width: 100%;
        }
        
        .dm-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .player-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Sidebar for DM long-term thoughts */
        .dm-sidebar {
            width: 300px;
            background-color: white;
            box-shadow: var(--shadow);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 20px;
            border-right: 1px solid var(--medium-gray);
        }
        
        .dm-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        
        /* Common elements */
        h1, h2, h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
        }
        
        h1 {
            font-size: 28px;
            text-align: center;
            margin-bottom: 25px;
        }
        
        h2 {
            font-size: 22px;
            margin-top: 20px;
        }
        
        h3 {
            font-size: 18px;
            margin-top: 15px;
        }
        
        input, textarea, button {
            font-family: inherit;
            font-size: 1rem;
        }
        
        input[type="password"], input[type="text"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid var(--medium-gray);
            border-radius: var(--radius);
            transition: var(--transition);
        }
        
        input[type="password"]:focus, input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(63, 81, 181, 0.2);
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid var(--medium-gray);
            border-radius: var(--radius);
            resize: vertical;
            margin-bottom: 15px;
            transition: var(--transition);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }
        
        button:hover {
            background-color: var(--primary-dark);
        }
        
        button:disabled {
            background-color: var(--dark-gray);
            cursor: not-allowed;
        }
        
        button.secondary {
            background-color: white;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }
        
        button.secondary:hover {
            background-color: rgba(63, 81, 181, 0.1);
        }
        
        button.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .search-box {
            width: 100%;
            margin-bottom: 15px;
            position: relative;
        }
        
        .search-box input {
            width: 100%;
            padding: 12px;
            padding-left: 35px;
            border: 1px solid var(--medium-gray);
            border-radius: var(--radius);
        }
        
        .search-box::before {
            content: "üîç";
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--dark-gray);
        }
        
        .error {
            color: #e74c3c;
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
        
        .status {
            color: #2ecc71;
            font-size: 0.9rem;
            margin-top: 15px;
            text-align: center;
        }
        
        /* Game log area */
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }
        
        .game-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .step {
            margin-bottom: 30px;
            padding: 15px;
            background-color: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }
        
        .step-header {
            display: flex;
            justify-content: space-between;
            padding-bottom: 10px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--medium-gray);
            color: var(--primary-color);
            font-weight: bold;
        }
        
        .step-content {
            margin-bottom: 10px;
        }
        
        .prompt, .action, .outcome {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: var(--radius);
        }
        
        .prompt {
            background-color: #e8f5e9;
            border-left: 4px solid #66bb6a;
        }
        
        .action {
            background-color: #e3f2fd;
            border-left: 4px solid #42a5f5;
        }
        
        .outcome {
            background-color: #fff3e0;
            border-left: 4px solid #ffa726;
        }
        
        .step-meta {
            font-size: 0.8rem;
            color: var(--dark-gray);
        }
        
        /* DM thoughts */
        .thoughts-container {
            margin-top: 20px;
        }
        
        .thought {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: var(--radius);
            position: relative;
        }
        
        .thought {
            background-color: #f9f9f9;
            border-left: 4px solid #9e9e9e;
        }
        
        .watsonian {
            color: #673ab7; /* Purple for watsonian */
        }
        
        .doylist {
            color: #f44336; /* Red for doylist */
        }
        
        .long-term {
            text-decoration: underline;
        }
        
        .thought-meta {
            font-size: 0.8rem;
            color: var(--dark-gray);
            margin-bottom: 8px;
        }
        
        .thought-type {
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: bold;
        }
        
        /* Thought formatting buttons */
        .formatting-toolbar {
            display: flex;
            gap: 5px;
            margin-top: 5px;
            margin-bottom: 10px;
        }
        
        .format-btn {
            padding: 5px 10px;
            font-size: 0.8rem;
            background-color: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .format-btn.watsonian {
            color: #673ab7;
            border-color: #673ab7;
        }
        
        .format-btn.doylist {
            color: #f44336;
            border-color: #f44336;
        }
        
        .format-btn.long-term {
            text-decoration: underline;
        }
        
        .format-btn.active {
            background-color: #eeeeee;
        }
        
        /* Action input area */
        .input-area {
            padding: 20px;
            background-color: white;
            border-top: 1px solid var(--medium-gray);
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
        }
        
        .locked-message {
            text-align: center;
            padding: 20px;
            background-color: #fff8e1;
            border-radius: var(--radius);
            margin-bottom: 15px;
            font-weight: bold;
            color: #f57c00;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .dm-container {
                flex-direction: column;
            }
            
            .dm-sidebar {
                width: 100%;
                height: auto;
                max-height: 200px;
                border-right: none;
                border-bottom: 1px solid var(--medium-gray);
            }
        }
    </style>
</head>
<body>
    <!-- Login container -->
    <div class="login-container" id="loginContainer">
        <h1>Async RPG Adventure</h1>
        
        <div id="playerLoginSection">
            <h2>Player Login</h2>
            <input type="password" id="playerPassword" placeholder="Player Password">
            <button id="playerLoginBtn">Login as Player</button>
            <p id="playerLoginError" class="error"></p>
        </div>
        
        <div id="adminLoginSection">
            <h2>DM Login</h2>
            <input type="password" id="adminPassword" placeholder="DM Password">
            <button id="adminLoginBtn">Login as DM</button>
            <p id="adminLoginError" class="error"></p>
        </div>
        
        <p id="loginStatusMessage" class="status"></p>
    </div>
    
    <!-- DM interface -->
    <div class="main-container" id="dmMainContainer">
        <div class="dm-container">
            <!-- Long-term thoughts sidebar -->
            <div class="dm-sidebar">
                <h2>Long-term Thoughts</h2>
                <div class="search-box">
                    <input type="text" id="thoughtSearchInput" placeholder="Search thoughts...">
                </div>
                <div id="longTermThoughtsContainer"></div>
            </div>
            
            <div class="dm-content">
                <!-- Game log area -->
                <div class="log-container">
                    <div class="game-log-header">
                        <h2>Game Log</h2>
                        <button id="refreshGameBtn">Refresh</button>
                    </div>
                    <div id="gameLogDisplay"></div>
                </div>
                
                <!-- DM input area -->
                <div class="input-area">
                    <div id="dmTurnLockedMessage" class="locked-message" style="display: none;">
                        Waiting for player's action...
                    </div>
                    
                    <div id="dmInputControls">
                        <h3>DM Thoughts</h3>
                        <div class="button-group">
                            <button id="watsonian-btn" class="active">Watsonian</button>
                            <button id="doylist-btn" class="secondary">Doylist</button>
                            <button id="long-term-btn" class="secondary">Long-term</button>
                        </div>
                        <textarea id="dmThoughtInput" placeholder="DM Thoughts (only visible to you)"></textarea>
                        
                        <h3>Game Message</h3>
                        <div id="messageTypeIndicator">Current: <span id="currentMessageType">Prompt</span></div>
                        <textarea id="dmMessageInput" placeholder="Enter a prompt or outcome for the player"></textarea>
                        <button id="postDmMessageBtn">Post Message</button>
                    </div>
                    
                    <p id="dmStatusMessage" class="status"></p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Player interface -->
    <div class="main-container" id="playerMainContainer">
        <div class="player-container">
            <!-- Game log area -->
            <div class="log-container">
                <div class="game-log-header">
                    <h2>Adventure Log</h2>
                    <button id="playerRefreshBtn">Refresh</button>
                </div>
                <div id="playerGameLogDisplay"></div>
            </div>
            
            <!-- Player input area -->
            <div class="input-area">
                <div id="playerTurnLockedMessage" class="locked-message" style="display: none;">
                    Waiting for DM's response...
                </div>
                
                <div id="playerInputControls">
                    <h3>Your Action</h3>
                    <textarea id="playerActionInput" placeholder="What do you do next?"></textarea>
                    <button id="submitPlayerActionBtn">Submit Action</button>
                </div>
                
                <p id="playerStatusMessage" class="status"></p>
            </div>
        </div>
    </div>
    
    <script>
    /* ---------- CONFIG ---------- */
    const PLAYER_PASSWORD = 'space';
    const DM_PASSWORD = 'dm2';
    
    /* Google Sheet IDs */
    const SPREADSHEET_ID = '1SXE6BwnRqVR93MFp-zSI83bBgcqZ5y53Hg197VrzjSo';
    const SHEET_NAME = 'Sheet1';
    const DATA_RANGE = `${SHEET_NAME}!A:E`; // Added column for thought type
    
    /* ---------- DB SCHEMA ---------- */
    /*
     * Database Schema:
     *
     * [timestamp, author, type, content, formatInfo]
     *
     * author: "DM" or "PLAYER"
     * type: "PROMPT", "ACTION", "OUTCOME", or "DM_THOUGHT"
     * content: The actual content
     * formatInfo: For thoughts, this is always "formatted". For other types, null.
     *
     * Formatted Thought Structure:
     * - Text is stored as HTML with appropriate span tags
     * - <span class="watsonian">...</span> for watsonian thoughts (purple)
     * - <span class="doylist">...</span> for doylist thoughts (red)
     * - <span class="watsonian long-term">...</span> or <span class="doylist long-term">...</span> for long-term thoughts
     * - Long-term thoughts are displayed in the sidebar and in the timeline
     */
    
    /* ---------- GLOBAL STATE ---------- */
    let isPlayerLoggedIn = false;
    let isAdminLoggedIn = false;
    let serviceAccountCredentials = null;
    let accessToken = null;
    let tokenExpiryTime = 0;
    let isLoading = false;
    let playerCredentials = null;
    let dmCredentials = null;
    let currentDefaultThoughtType = 'watsonian'; // Default thought type
    let currentMessageType = 'PROMPT'; // Default message type
    let gameData = []; // Store game data for turn tracking
    let isPlayerTurn = false; // Track whose turn it is
    let isSearching = false; // Track search state
    let selectionRange = null; // Track text selection in the thought input
    
    /* ---------- DOM ELEMENTS ---------- */
    // Login elements
    const loginContainer = document.getElementById('loginContainer');
    const playerLoginBtn = document.getElementById('playerLoginBtn');
    const adminLoginBtn = document.getElementById('adminLoginBtn');
    const playerPasswordInput = document.getElementById('playerPassword');
    const adminPasswordInput = document.getElementById('adminPassword');
    const playerLoginError = document.getElementById('playerLoginError');
    const adminLoginError = document.getElementById('adminLoginError');
    const loginStatusMessage = document.getElementById('loginStatusMessage');
    
    // Main containers
    const dmMainContainer = document.getElementById('dmMainContainer');
    const playerMainContainer = document.getElementById('playerMainContainer');
    
    // DM elements
    const refreshGameBtn = document.getElementById('refreshGameBtn');
    const gameLogDisplay = document.getElementById('gameLogDisplay');
    const dmThoughtInput = document.getElementById('dmThoughtInput');
    const dmMessageInput = document.getElementById('dmMessageInput');
    const postDmMessageBtn = document.getElementById('postDmMessageBtn');
    const dmStatusMessage = document.getElementById('dmStatusMessage');
    const watsonianBtn = document.getElementById('watsonian-btn');
    const doylistBtn = document.getElementById('doylist-btn');
    const longTermBtn = document.getElementById('long-term-btn');
    const longTermThoughtsContainer = document.getElementById('longTermThoughtsContainer');
    const thoughtSearchInput = document.getElementById('thoughtSearchInput');
    const currentMessageTypeSpan = document.getElementById('currentMessageType');
    const dmTurnLockedMessage = document.getElementById('dmTurnLockedMessage');
    const dmInputControls = document.getElementById('dmInputControls');
    
    // Player elements
    const playerRefreshBtn = document.getElementById('playerRefreshBtn');
    const playerGameLogDisplay = document.getElementById('playerGameLogDisplay');
    const playerActionInput = document.getElementById('playerActionInput');
    const submitPlayerActionBtn = document.getElementById('submitPlayerActionBtn');
    const playerStatusMessage = document.getElementById('playerStatusMessage');
    const playerTurnLockedMessage = document.getElementById('playerTurnLockedMessage');
    const playerInputControls = document.getElementById('playerInputControls');
    
    /* ---------- UI HELPERS ---------- */
    function showLoading(element, msg = 'Processing...') {
        isLoading = true;
        element.textContent = msg;
        document.querySelectorAll('button').forEach(b => b.disabled = true);
    }
    
    function hideLoading(element, msg = 'Ready.') {
        isLoading = false;
        element.textContent = msg;
        document.querySelectorAll('button').forEach(b => b.disabled = false);
    }
    
    function formatDate(isoString) {
        const date = new Date(isoString);
        return {
            time: date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}),
            date: date.toLocaleDateString([], {weekday: 'short', month: 'short', day: 'numeric'})
        };
    }
    
    /* ---------- CREDENTIALS LOADING ---------- */
    async function loadCredentials() {
        try {
            // Load player credentials
            const playerResponse = await fetch('player_credentials.hex');
            if (!playerResponse.ok) throw new Error('Failed to load player credentials');
            playerCredentials = await playerResponse.text();
            
            // Load DM credentials
            const dmResponse = await fetch('dm_credentials.hex');
            if (!dmResponse.ok) throw new Error('Failed to load DM credentials');
            dmCredentials = await dmResponse.text();
            
            loginStatusMessage.textContent = 'Credentials loaded successfully.';
            return true;
        } catch (e) {
            console.error('Error loading credentials', e);
            loginStatusMessage.textContent = 'CRITICAL: Could not load credentials files.';
            return false;
        }
    }
    
    /* ---------- XOR HELPER ---------- */
    function xorDecrypt(hex, key) {
        const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)));
        const keyB = new TextEncoder().encode(key);
        const plain = bytes.map((b, i) => b ^ keyB[i % keyB.length]);
        return new TextDecoder().decode(plain);
    }
    
    /* ---------- LOGIN ---------- */
    async function initialiseCredentials(cipherHex, pass) {
        if (serviceAccountCredentials) return true;
        try {
            const json = xorDecrypt(cipherHex, pass);
            serviceAccountCredentials = JSON.parse(json);
            return true;
        } catch (e) {
            console.error('SA decrypt/parse error', e);
            loginStatusMessage.textContent = 'CRITICAL: Could not load service account creds.';
            return false;
        }
    }
    
    async function loginAsPlayer() {
        if (playerPasswordInput.value !== PLAYER_PASSWORD) {
            playerLoginError.textContent = 'Incorrect password.';
            return;
        }
        
        if (!playerCredentials) {
            if (!await loadCredentials()) {
                playerLoginError.textContent = 'Failed to load credentials.';
                return;
            }
        }
        
        if (!await initialiseCredentials(playerCredentials, PLAYER_PASSWORD)) {
            playerLoginError.textContent = 'Failed to initialize credentials.';
            return;
        }
        
        playerLoginError.textContent = '';
        isPlayerLoggedIn = true;
        loginContainer.style.display = 'none';
        playerMainContainer.style.display = 'block';
        playerStatusMessage.textContent = 'Logged in as Player.';
        await loadGameData();
    }
    
    async function loginAsAdmin() {
        if (adminPasswordInput.value !== DM_PASSWORD) {
            adminLoginError.textContent = 'Incorrect password.';
            return;
        }
        
        if (!dmCredentials) {
            if (!await loadCredentials()) {
                adminLoginError.textContent = 'Failed to load credentials.';
                return;
            }
        }
        
        if (!await initialiseCredentials(dmCredentials, DM_PASSWORD)) {
            adminLoginError.textContent = 'Failed to initialize credentials.';
            return;
        }
        
        adminLoginError.textContent = '';
        isAdminLoggedIn = true;
        loginContainer.style.display = 'none';
        dmMainContainer.style.display = 'block';
        dmStatusMessage.textContent = 'Logged in as DM.';
        await loadGameData();
    }
    
    /* ---------- GOOGLE AUTH ---------- */
    async function getAccessToken() {
        if (accessToken && Date.now() < tokenExpiryTime) return accessToken;
        if (!serviceAccountCredentials) throw new Error('Not logged in.');
        const header = { alg: 'RS256', typ: 'JWT' };
        const now = Math.floor(Date.now() / 1000);
        const claims = {
            iss: serviceAccountCredentials.client_email,
            scope: 'https://www.googleapis.com/auth/spreadsheets',
            aud: 'https://oauth2.googleapis.com/token',
            exp: now + 3500,
            iat: now
        };
        const sJWT = KJUR.jws.JWS.sign(
            'RS256',
            JSON.stringify(header),
            JSON.stringify(claims),
            serviceAccountCredentials.private_key
        );
        const res = await fetch('https://oauth2.googleapis.com/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=' + sJWT
        });
        if (!res.ok) {
            const err = await res.json(); throw new Error('Token exchange failed: ' + JSON.stringify(err));
        }
        const data = await res.json();
        accessToken = data.access_token;
        tokenExpiryTime = Date.now() + data.expires_in * 1000 - 60000;
        return accessToken;
    }
    
    /* ---------- SHEET HELPERS ---------- */
    async function appendToSheet(values) {
        const token = await getAccessToken();
        const rangeForAppend = `${SHEET_NAME}!A1`;
        const body = { values };
        const res = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${rangeForAppend}:append?valueInputOption=USER_ENTERED&insertDataOption=INSERT_ROWS`, {
            method: 'POST',
            headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        if (!res.ok) {
            const err = await res.json(); throw new Error('Append failed: ' + err.error.message);
        }
        return res.json();
    }
    
    async function readSheet() {
        const token = await getAccessToken();
        const res = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${DATA_RANGE}`, {
            headers: { 'Authorization': 'Bearer ' + token }
        });
        if (!res.ok) {
            const err = await res.json(); throw new Error('Read failed: ' + err.error.message);
        }
        const data = await res.json();
        return data.values || [];
    }
    
    /* ---------- TEXT FORMATTING CONTROLS ---------- */
    function setDefaultThoughtType(type) {
        currentDefaultThoughtType = type;
        
        // Update UI to show active button for default type
        watsonianBtn.classList.remove('active');
        doylistBtn.classList.remove('active');
        
        if (type === 'watsonian') {
            watsonianBtn.classList.add('active');
        } else if (type === 'doylist') {
            doylistBtn.classList.add('active');
        }
    }
    
    function applyFormattingToSelection(format) {
        const textarea = dmThoughtInput;
        if (!textarea.selectionStart && textarea.selectionStart !== 0) return;
        
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        
        if (start === end) return; // No text selected
        
        const selectedText = textarea.value.substring(start, end);
        
        // Create a span with the appropriate class
        let formattedText;
        
        if (format === 'watsonian') {
            formattedText = `<span class="watsonian">${selectedText}</span>`;
        } else if (format === 'doylist') {
            formattedText = `<span class="doylist">${selectedText}</span>`;
        } else if (format === 'long-term') {
            // Check if already has watsonian or doylist class
            if (selectedText.includes('class="watsonian"')) {
                formattedText = selectedText.replace('class="watsonian"', 'class="watsonian long-term"');
            } else if (selectedText.includes('class="doylist"')) {
                formattedText = selectedText.replace('class="doylist"', 'class="doylist long-term"');
            } else if (selectedText.includes('<span')) {
                // Already has some formatting but not watsonian/doylist
                formattedText = selectedText.replace('<span', '<span class="long-term"');
            } else {
                // No formatting yet, apply default type + long-term
                formattedText = `<span class="${currentDefaultThoughtType} long-term">${selectedText}</span>`;
            }
        } else {
            return; // Unknown format
        }
        
        // Replace the selected text with the formatted text
        textarea.value = 
            textarea.value.substring(0, start) + 
            formattedText + 
            textarea.value.substring(end);
        
        // Restore focus and selection
        textarea.focus();
        textarea.selectionStart = start;
        textarea.selectionEnd = start + formattedText.length;
    }
    
    async function postDmMessage() {
        if (isLoading) return;
        if (!isAdminLoggedIn) {
            dmStatusMessage.textContent = 'You must be logged in as DM.';
            return;
        }
        
        const thought = dmThoughtInput.value.trim();
        const message = dmMessageInput.value.trim();
        
        if (!message) {
            dmStatusMessage.textContent = 'Game message is required.';
            return;
        }
        
        showLoading(dmStatusMessage, 'Posting message...');
        
        const ts = new Date().toISOString();
        const rows = [];
        
        // Add thought row if present (thoughts go before prompt/outcome)
        if (thought) {
            rows.push([ts, 'DM', 'DM_THOUGHT', thought, 'formatted']);
        }
        
        // Add message row
        rows.push([ts, 'DM', currentMessageType, message, null]);
        
        try {
            await appendToSheet(rows);
            dmThoughtInput.value = '';
            dmMessageInput.value = '';
            
            // Update message type for next turn
            if (currentMessageType === 'PROMPT') {
                currentMessageType = 'OUTCOME';
                currentMessageTypeSpan.textContent = 'Outcome';
            } else {
                currentMessageType = 'PROMPT';
                currentMessageTypeSpan.textContent = 'Prompt';
            }
            
            await loadGameData();
            hideLoading(dmStatusMessage, 'Message posted.');
        } catch (e) {
            hideLoading(dmStatusMessage, 'Error: ' + e.message);
        }
    }
    
    function searchThoughts() {
        const searchTerm = thoughtSearchInput.value.toLowerCase();
        const allThoughts = document.querySelectorAll('.thought');
        
        if (searchTerm === '') {
            allThoughts.forEach(thought => {
                thought.style.display = 'block';
            });
            return;
        }
        
        allThoughts.forEach(thought => {
            const content = thought.querySelector('.thought-content').textContent.toLowerCase();
            if (content.includes(searchTerm)) {
                thought.style.display = 'block';
            } else {
                thought.style.display = 'none';
            }
        });
    }
    
    /* ---------- PLAYER ACTIONS ---------- */
    async function submitPlayerAction() {
        if (isLoading) return;
        if (!isPlayerLoggedIn) {
            playerStatusMessage.textContent = 'You must be logged in as a player.';
            return;
        }
        
        if (!isPlayerTurn) {
            playerStatusMessage.textContent = "It's not your turn yet.";
            return;
        }
        
        const actionText = playerActionInput.value.trim();
        if (!actionText) {
            playerStatusMessage.textContent = 'Please enter your action.';
            return;
        }
        
        showLoading(playerStatusMessage, 'Submitting action...');
        const ts = new Date().toISOString();
        
        try {
            await appendToSheet([[ts, 'PLAYER', 'ACTION', actionText, null]]);
            playerActionInput.value = '';
            await loadGameData();
            hideLoading(playerStatusMessage, 'Action submitted.');
        } catch (e) {
            hideLoading(playerStatusMessage, 'Error: ' + e.message);
        }
    }
    
    /* ---------- GAME DATA LOADING ---------- */
    async function loadGameData() {
        try {
            const statusMsg = isPlayerLoggedIn ? playerStatusMessage : dmStatusMessage;
            showLoading(statusMsg, 'Loading game data...');
            
            const rows = await readSheet();
            gameData = rows; // Store for turn tracking
            
            if (isAdminLoggedIn) {
                renderDmGameLog(rows);
                updateDmTurnStatus(rows);
            }
            
            if (isPlayerLoggedIn) {
                renderPlayerGameLog(rows);
                updatePlayerTurnStatus(rows);
            }
            
            hideLoading(statusMsg, 'Game data loaded.');
        } catch (e) {
            const statusMsg = isPlayerLoggedIn ? playerStatusMessage : dmStatusMessage;
            hideLoading(statusMsg, 'Failed to load data: ' + e.message);
            
            if (isAdminLoggedIn) {
                gameLogDisplay.innerHTML = '<p class="error">Error loading game data: ' + e.message + '</p>';
            }
            
            if (isPlayerLoggedIn) {
                playerGameLogDisplay.innerHTML = '<p class="error">Error loading game data: ' + e.message + '</p>';
            }
        }
    }
    
    function updateDmTurnStatus(rows) {
        // Check turn status based on last entry
        if (rows.length === 0) {
            // No entries yet, DM needs to post the first prompt
            isPlayerTurn = false;
            currentMessageType = 'PROMPT';
            currentMessageTypeSpan.textContent = 'Prompt';
            dmTurnLockedMessage.style.display = 'none';
            dmInputControls.style.display = 'block';
            return;
        }
        
        // Find the last non-thought entry to determine turn status
        let lastActionRow = null;
        for (let i = rows.length - 1; i >= 0; i--) {
            if (rows[i] && rows[i].length >= 3 && rows[i][2] !== 'DM_THOUGHT') {
                lastActionRow = rows[i];
                break;
            }
        }
        
        if (!lastActionRow) {
            // No action rows yet, DM's turn
            isPlayerTurn = false;
            currentMessageType = 'PROMPT';
            currentMessageTypeSpan.textContent = 'Prompt';
            dmTurnLockedMessage.style.display = 'none';
            dmInputControls.style.display = 'block';
            return;
        }
        
        const [_, author, type] = lastActionRow;
        
        if (author === 'PLAYER' && type === 'ACTION') {
            // Player just submitted an action, DM's turn to respond with OUTCOME
            isPlayerTurn = false;
            currentMessageType = 'OUTCOME';
            currentMessageTypeSpan.textContent = 'Outcome';
            dmTurnLockedMessage.style.display = 'none';
            dmInputControls.style.display = 'block';
        } else if (author === 'DM' && type === 'OUTCOME') {
            // After an outcome, DM posts a prompt
            isPlayerTurn = false;
            currentMessageType = 'PROMPT';
            currentMessageTypeSpan.textContent = 'Prompt';
            dmTurnLockedMessage.style.display = 'none';
            dmInputControls.style.display = 'block';
        } else if (author === 'DM' && type === 'PROMPT') {
            // DM posted a prompt, waiting for player action
            isPlayerTurn = true;
            dmTurnLockedMessage.style.display = 'block';
            dmInputControls.style.display = 'none';
        } else {
            // Default case, let DM post
            isPlayerTurn = false;
            dmTurnLockedMessage.style.display = 'none';
            dmInputControls.style.display = 'block';
        }
    }
    
    function updatePlayerTurnStatus(rows) {
        // Check turn status based on last entry
        if (rows.length === 0) {
            // No entries yet, waiting for DM to post the first prompt
            isPlayerTurn = false;
            playerTurnLockedMessage.style.display = 'block';
            playerTurnLockedMessage.textContent = 'Waiting for the DM to start the adventure...';
            playerInputControls.style.display = 'none';
            return;
        }
        
        // Find the last non-thought entry to determine turn status
        let lastActionRow = null;
        for (let i = rows.length - 1; i >= 0; i--) {
            if (rows[i] && rows[i].length >= 3 && rows[i][2] !== 'DM_THOUGHT') {
                lastActionRow = rows[i];
                break;
            }
        }
        
        if (!lastActionRow) {
            // No action rows yet, waiting for DM
            isPlayerTurn = false;
            playerTurnLockedMessage.style.display = 'block';
            playerInputControls.style.display = 'none';
            return;
        }
        
        const [_, author, type] = lastActionRow;
        
        if (author === 'DM' && (type === 'PROMPT' || type === 'OUTCOME')) {
            // DM just posted, player's turn
            isPlayerTurn = true;
            playerTurnLockedMessage.style.display = 'none';
            playerInputControls.style.display = 'block';
        } else if (author === 'PLAYER' && type === 'ACTION') {
            // Player just submitted, waiting for DM
            isPlayerTurn = false;
            playerTurnLockedMessage.style.display = 'block';
            playerInputControls.style.display = 'none';
        } else {
            // Default case, lock player input
            isPlayerTurn = false;
            playerTurnLockedMessage.style.display = 'block';
            playerInputControls.style.display = 'none';
        }
    }
    
    function renderDmGameLog(rows) {
        gameLogDisplay.innerHTML = '';
        longTermThoughtsContainer.innerHTML = '';
        
        if (rows.length === 0) {
            gameLogDisplay.innerHTML = '<div class="step"><p>No game entries yet. Start by posting a prompt!</p></div>';
            return;
        }
        
        // Process rows into a sequence with proper order
        let gameSequence = [];
        let pendingThoughts = [];
        
        // First pass - group thoughts with their associated messages
        for (const row of rows) {
            if (!row || row.length < 3) continue;
            
            const [timestamp, author, type, content, formatInfo] = row;
            
            if (type === 'DM_THOUGHT') {
                // Store the thought to associate with next prompt/outcome or add to sequence
                // Check if this is a long-term thought (contains long-term class)
                if (content.includes('class="long-term"') || 
                    content.includes('class="watsonian long-term"') || 
                    content.includes('class="doylist long-term"')) {
                    // Extract the long-term thought for the sidebar
                    renderLongTermThought(timestamp, content);
                }
                
                // Add the thought to pending queue regardless if it contains long-term parts
                // This way it will also be shown in the main timeline
                pendingThoughts.push({
                    timestamp,
                    content
                });
            } else {
                // For prompt/action/outcome, add any pending thoughts first
                if (pendingThoughts.length > 0) {
                    for (const thought of pendingThoughts) {
                        gameSequence.push({
                            type: 'thought',
                            data: thought
                        });
                    }
                    pendingThoughts = [];
                }
                
                // Then add the actual message
                gameSequence.push({
                    type: type.toLowerCase(),
                    data: {
                        timestamp,
                        content
                    }
                });
            }
        }
        
        // Add any remaining thoughts at the end
        for (const thought of pendingThoughts) {
            gameSequence.push({
                type: 'thought',
                data: thought
            });
        }
        
        // Second pass - group into steps
        const steps = [];
        let currentStep = { 
            number: 1,
            sequence: []  // Array of {type, data} objects in order
        };
        
        for (const item of gameSequence) {
            if (item.type === 'prompt' && currentStep.sequence.some(s => s.type === 'prompt' || s.type === 'outcome')) {
                // If we already have a prompt or outcome in this step, start a new step
                steps.push({...currentStep});
                currentStep = {
                    number: steps.length + 1,
                    sequence: [item]
                };
            } else {
                // Add to current step
                currentStep.sequence.push(item);
            }
        }
        
        // Add the last step if it has content
        if (currentStep.sequence.length > 0) {
            steps.push(currentStep);
        }
        
        // Render each step
        steps.forEach(step => {
            const stepEl = document.createElement('div');
            stepEl.className = 'step';
            
            // Step header
            const stepHeader = document.createElement('div');
            stepHeader.className = 'step-header';
            stepHeader.innerHTML = `<span>Step ${step.number}</span>`;
            stepEl.appendChild(stepHeader);
            
            // Render each item in the sequence
            const stepContent = document.createElement('div');
            stepContent.className = 'step-content';
            
            for (const item of step.sequence) {
                if (item.type === 'thought') {
                    const { time, date } = formatDate(item.data.timestamp);
                    const thoughtEl = document.createElement('div');
                    thoughtEl.className = 'thought';
                    
                    thoughtEl.innerHTML = `
                        <div class="thought-meta">Thought: ${date} at ${time}</div>
                        <div class="thought-content">${item.data.content}</div>
                    `;
                    
                    stepContent.appendChild(thoughtEl);
                } else if (item.type === 'prompt') {
                    const { time, date } = formatDate(item.data.timestamp);
                    const promptEl = document.createElement('div');
                    promptEl.className = 'prompt';
                    promptEl.innerHTML = `
                        <strong>Prompt:</strong>
                        <div>${item.data.content}</div>
                        <div class="step-meta">Posted: ${date} at ${time}</div>
                    `;
                    stepContent.appendChild(promptEl);
                } else if (item.type === 'action') {
                    const { time, date } = formatDate(item.data.timestamp);
                    const actionEl = document.createElement('div');
                    actionEl.className = 'action';
                    actionEl.innerHTML = `
                        <strong>Player's Action:</strong>
                        <div>${item.data.content}</div>
                        <div class="step-meta">Posted: ${date} at ${time}</div>
                    `;
                    stepContent.appendChild(actionEl);
                } else if (item.type === 'outcome') {
                    const { time, date } = formatDate(item.data.timestamp);
                    const outcomeEl = document.createElement('div');
                    outcomeEl.className = 'outcome';
                    outcomeEl.innerHTML = `
                        <strong>Outcome:</strong>
                        <div>${item.data.content}</div>
                        <div class="step-meta">Posted: ${date} at ${time}</div>
                    `;
                    stepContent.appendChild(outcomeEl);
                }
            }
            
            stepEl.appendChild(stepContent);
            gameLogDisplay.appendChild(stepEl);
        });
        
        // Scroll to bottom
        gameLogDisplay.scrollTop = gameLogDisplay.scrollHeight;
    }
    
    function renderLongTermThought(timestamp, content) {
        const { time, date } = formatDate(timestamp);
        const thoughtEl = document.createElement('div');
        thoughtEl.className = 'thought';
        
        thoughtEl.innerHTML = `
            <div class="thought-meta">Added: ${date} at ${time}</div>
            <div class="thought-content">${content}</div>
        `;
        
        longTermThoughtsContainer.appendChild(thoughtEl);
    }
    
    function renderPlayerGameLog(rows) {
        playerGameLogDisplay.innerHTML = '';
        
        if (rows.length === 0) {
            playerGameLogDisplay.innerHTML = '<div class="step"><p>The adventure has not yet begun. Wait for the DM to start!</p></div>';
            return;
        }
        
        // Process rows into a sequence with proper order (similar to DM view but without thoughts)
        let gameSequence = [];
        
        // First pass - filter out thoughts
        for (const row of rows) {
            if (!row || row.length < 3) continue;
            
            const [timestamp, author, type, content] = row;
            
            if (type === 'DM_THOUGHT') {
                // Skip DM thoughts for player view
                continue;
            } else {
                // Add the actual message
                gameSequence.push({
                    type: type.toLowerCase(),
                    data: {
                        timestamp,
                        content
                    }
                });
            }
        }
        
        // Second pass - group into steps
        const steps = [];
        let currentStep = { 
            number: 1,
            sequence: []  // Array of {type, data} objects in order
        };
        
        for (const item of gameSequence) {
            if (item.type === 'prompt' && currentStep.sequence.some(s => s.type === 'prompt' || s.type === 'outcome')) {
                // If we already have a prompt or outcome in this step, start a new step
                steps.push({...currentStep});
                currentStep = {
                    number: steps.length + 1,
                    sequence: [item]
                };
            } else {
                // Add to current step
                currentStep.sequence.push(item);
            }
        }
        
        // Add the last step if it has content
        if (currentStep.sequence.length > 0) {
            steps.push(currentStep);
        }
        
        // Render each step
        steps.forEach(step => {
            const stepEl = document.createElement('div');
            stepEl.className = 'step';
            
            // Step header
            const stepHeader = document.createElement('div');
            stepHeader.className = 'step-header';
            stepHeader.innerHTML = `<span>Step ${step.number}</span>`;
            stepEl.appendChild(stepHeader);
            
            // Render each item in the sequence
            const stepContent = document.createElement('div');
            stepContent.className = 'step-content';
            
            for (const item of step.sequence) {
                if (item.type === 'prompt') {
                    const { time, date } = formatDate(item.data.timestamp);
                    const promptEl = document.createElement('div');
                    promptEl.className = 'prompt';
                    promptEl.innerHTML = `
                        <strong>Prompt:</strong>
                        <div>${item.data.content}</div>
                        <div class="step-meta">Posted: ${date} at ${time}</div>
                    `;
                    stepContent.appendChild(promptEl);
                } else if (item.type === 'action') {
                    const { time, date } = formatDate(item.data.timestamp);
                    const actionEl = document.createElement('div');
                    actionEl.className = 'action';
                    actionEl.innerHTML = `
                        <strong>Your Action:</strong>
                        <div>${item.data.content}</div>
                        <div class="step-meta">Posted: ${date} at ${time}</div>
                    `;
                    stepContent.appendChild(actionEl);
                } else if (item.type === 'outcome') {
                    const { time, date } = formatDate(item.data.timestamp);
                    const outcomeEl = document.createElement('div');
                    outcomeEl.className = 'outcome';
                    outcomeEl.innerHTML = `
                        <strong>Outcome:</strong>
                        <div>${item.data.content}</div>
                        <div class="step-meta">Posted: ${date} at ${time}</div>
                    `;
                    stepContent.appendChild(outcomeEl);
                }
            }
            
            stepEl.appendChild(stepContent);
            playerGameLogDisplay.appendChild(stepEl);
        });
        
        // Scroll to bottom
        playerGameLogDisplay.scrollTop = playerGameLogDisplay.scrollHeight;
    }
    
    /* ---------- EVENT LISTENERS ---------- */
    // Login buttons
    playerLoginBtn.addEventListener('click', loginAsPlayer);
    adminLoginBtn.addEventListener('click', loginAsAdmin);
    
    // Enter key for login
    playerPasswordInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') loginAsPlayer();
    });
    
    adminPasswordInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') loginAsAdmin();
    });
    
    // DM format controls
    watsonianBtn.addEventListener('click', () => {
        setDefaultThoughtType('watsonian');
        if (dmThoughtInput.selectionStart !== dmThoughtInput.selectionEnd) {
            applyFormattingToSelection('watsonian');
        }
    });
    
    doylistBtn.addEventListener('click', () => {
        setDefaultThoughtType('doylist');
        if (dmThoughtInput.selectionStart !== dmThoughtInput.selectionEnd) {
            applyFormattingToSelection('doylist');
        }
    });
    
    longTermBtn.addEventListener('click', () => {
        if (dmThoughtInput.selectionStart !== dmThoughtInput.selectionEnd) {
            applyFormattingToSelection('long-term');
        }
    });
    
    // Text selection in thought input
    dmThoughtInput.addEventListener('mouseup', () => {
        // Check if text is selected
        if (dmThoughtInput.selectionStart !== dmThoughtInput.selectionEnd) {
            // Text is selected, enable formatting buttons
            watsonianBtn.disabled = false;
            doylistBtn.disabled = false;
            longTermBtn.disabled = false;
        } else {
            // No text selected
            watsonianBtn.disabled = false;
            doylistBtn.disabled = false;
            longTermBtn.disabled = false;
        }
    });
    
    // Other DM controls
    postDmMessageBtn.addEventListener('click', postDmMessage);
    refreshGameBtn.addEventListener('click', loadGameData);
    
    // Search functionality
    thoughtSearchInput.addEventListener('input', searchThoughts);
    
    // Player controls
    submitPlayerActionBtn.addEventListener('click', submitPlayerAction);
    playerRefreshBtn.addEventListener('click', loadGameData);
    
    playerActionInput.addEventListener('keyup', (e) => {
        if (e.ctrlKey && e.key === 'Enter') submitPlayerAction();
    });
    
    /* ---------- INITIALIZATION ---------- */
    window.onload = async () => {
        if (typeof KJUR === 'undefined') {
            loginStatusMessage.textContent = 'CRITICAL: jsrsasign failed to load.';
            document.querySelectorAll('button').forEach(b => b.disabled = true);
        } else {
            loadCredentials();
            loginStatusMessage.textContent = 'Welcome! Please log in.';
        }
    };
    </script>
</body>
</html>
